{"version":3,"file":"bundle.js","sources":["../node_modules/svelte/internal/index.mjs","../node_modules/svelte/store/index.mjs","../src/stores.js","../src/utils/cnn.js","../src/detail-view/DetailviewUtils.js","../src/detail-view/Dataview.svelte","../src/detail-view/KernelMathView.svelte","../src/detail-view/ConvolutionAnimator.svelte","../src/detail-view/Convolutionview.svelte","../src/detail-view/ActivationAnimator.svelte","../src/detail-view/Activationview.svelte","../src/detail-view/PoolAnimator.svelte","../src/detail-view/Poolview.svelte","../src/detail-view/Softmaxview.svelte","../src/overview/Modal.svelte","../src/utils/cnn-tf.js","../src/config.js","../src/overview/draw-utils.js","../src/overview/overview-draw.js","../src/overview/intermediate-utils.js","../src/overview/intermediate-draw.js","../src/overview/flatten-draw.js","../src/overview/Overview.svelte","../src/Explainer.svelte","../src/Header.svelte","../src/App.svelte","../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\nfunction is_promise(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n    return style.sheet;\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data_map(node, data_map) {\n    Object.keys(data_map).forEach((key) => {\n        set_custom_element_data(node, key, data_map[key]);\n    });\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value === null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nfunction head_selector(nodeId, head) {\n    const result = [];\n    let started = 0;\n    for (const node of head.childNodes) {\n        if (node.nodeType === 8 /* comment node */) {\n            const comment = node.textContent.trim();\n            if (comment === `HEAD_${nodeId}_END`) {\n                started -= 1;\n                result.push(node);\n            }\n            else if (comment === `HEAD_${nodeId}_START`) {\n                started += 1;\n                result.push(node);\n            }\n        }\n        else if (started > 0) {\n            result.push(node);\n        }\n    }\n    return result;\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            else\n                this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\nfunction construct_svelte_component(component, props) {\n    return new component(props);\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { ownerNode } = info.stylesheet;\n            // there is no ownerNode if it runs on jsdom.\n            if (ownerNode)\n                detach(ownerNode);\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs#run-time-svelte-beforeupdate\n */\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs#run-time-svelte-onmount\n */\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n */\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs#run-time-svelte-ondestroy\n */\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * https://svelte.dev/docs#run-time-svelte-createeventdispatcher\n */\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-setcontext\n */\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-getcontext\n */\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs#run-time-svelte-getallcontexts\n */\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-hascontext\n */\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    // Do not reenter flush while dirty components are updated, as this can\n    // result in an infinite loop. Instead, let the inner flush handle it.\n    // Reentrancy is ok afterwards for bindings etc.\n    if (flushidx !== 0) {\n        return;\n    }\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        try {\n            while (flushidx < dirty_components.length) {\n                const component = dirty_components[flushidx];\n                flushidx++;\n                set_current_component(component);\n                update(component.$$);\n            }\n        }\n        catch (e) {\n            // reset dirty state to not end up in a deadlocked state and then rethrow\n            dirty_components.length = 0;\n            flushidx = 0;\n            throw e;\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    const options = { direction: 'in' };\n    let config = fn(node, params, options);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config(options);\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    const options = { direction: 'out' };\n    let config = fn(node, params, options);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config(options);\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    const options = { direction: 'both' };\n    let config = fn(node, params, options);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro  we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro  needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config(options);\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'inert',\n    'ismap',\n    'itemscope',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\n/** regex of all html void element names */\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${escape_attribute_value(style_object[key])};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n            // if the component was destroyed immediately\n            // it will update the `$$.on_destroy` reference to `null`.\n            // the destructured on_destroy may still reference to the old array\n            if (component.$$.on_destroy) {\n                component.$$.on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: [],\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            if (!is_function(callback)) {\n                return noop;\n            }\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        if (!is_function(callback)) {\n            return noop;\n        }\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.55.1' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\nfunction construct_svelte_component_dev(component, props) {\n    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n    try {\n        const instance = new component(props);\n        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n            throw new Error(error_message);\n        }\n        return instance;\n    }\n    catch (err) {\n        const { message } = err;\n        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n            throw new Error(error_message);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, head_selector, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import { writable } from 'svelte/store';\n\nexport const cnnStore = writable([]);\nexport const svgStore = writable(undefined);\n\nexport const vSpaceAroundGapStore = writable(undefined);\nexport const hSpaceAroundGapStore = writable(undefined);\n\nexport const nodeCoordinateStore = writable([]);\nexport const selectedScaleLevelStore = writable(undefined);\n\nexport const cnnLayerRangesStore = writable({});\nexport const cnnLayerMinMaxStore = writable([]);\n\nexport const needRedrawStore = writable([undefined, undefined]);\n\nexport const detailedModeStore = writable(true);\n\nexport const shouldIntermediateAnimateStore = writable(false);\n\nexport const isInSoftmaxStore = writable(false);\nexport const softmaxDetailViewStore = writable({});\nexport const allowsSoftmaxAnimationStore = writable(false);\n\nexport const hoverInfoStore = writable({});\n\nexport const modalStore = writable({});\n\nexport const intermediateLayerPositionStore = writable({});","// Enum of node types\nconst nodeType = {\n  INPUT: 'input',\n  CONV: 'conv',\n  POOL: 'pool',\n  RELU: 'relu',\n  FC: 'fc',\n  FLATTEN: 'flatten'\n}\n\nclass Node {\n  /**\n   * Class structure for each neuron node.\n   * \n   * @param {string} layerName Name of the node's layer.\n   * @param {int} index Index of this node in its layer.\n   * @param {string} type Node type {input, conv, pool, relu, fc}. \n   * @param {number} bias The bias assocated to this node.\n   * @param {[[number]]} output Output of this node.\n   */\n  constructor(layerName, index, type, bias, output) {\n    this.layerName = layerName;\n    this.index = index;\n    this.type = type;\n    this.bias = bias;\n    this.output = output;\n\n    // Weights are stored in the links\n    this.inputLinks = [];\n    this.outputLinks = [];\n  }\n}\n\nclass Link {\n  constructor(source, dest, weight) {\n    this.source = source;\n    this.dest = dest;\n    this.weight = weight;\n  }\n}\n\nconst constructNNFromJSON = (nnJSON, inputImageArray) => {\n  console.log(nnJSON);\n  console.log(inputImageArray);\n  let nn = [];\n\n  // Add the first layer (input layer)\n  let inputLayer = [];\n  let inputShape = nnJSON[0].input_shape;\n\n  // First layer's three nodes' outputs are the channels of inputImageArray\n  for (let i = 0; i < inputShape[2]; i++) {\n    let node = new Node('input', i, nodeType.INPUT, 0, inputImageArray[i]);\n    inputLayer.push(node);\n  }\n                                                                                                                   \n  nn.push(inputLayer);\n  let curLayerIndex = 1;\n\n  nnJSON.forEach(layer => {\n    let curLayerNodes = [];\n    let curLayerType;\n\n    if (layer.name.includes('conv')) {\n      curLayerType = nodeType.CONV;\n    } else if (layer.name.includes('pool')) {\n      curLayerType = nodeType.POOL;\n    } else if (layer.name.includes('relu')) {\n      curLayerType = nodeType.RELU;\n    } else if (layer.name.includes('output')) {\n      curLayerType = nodeType.FC;\n    } else if (layer.name.includes('flatten')) {\n      curLayerType = nodeType.FLATTEN;\n    } else {\n      console.log('Find unknown type');\n    }\n\n    let shape = layer.output_shape.slice(0, 2);\n    let bias = 0;\n    let output;\n    if (curLayerType === nodeType.FLATTEN || curLayerType === nodeType.FC) {\n      output = 0;\n    } else {\n      output = init2DArray(shape[0], shape[1], 0);\n    }\n\n    // Add neurons into this layer\n    for (let i = 0; i < layer.num_neurons; i++) {\n      if (curLayerType === nodeType.CONV || curLayerType === nodeType.FC) {\n        bias = layer.weights[i].bias;\n      }\n      let node = new Node(layer.name, i, curLayerType, bias, output)\n\n      // Connect this node to all previous nodes (create links)\n      if (curLayerType === nodeType.CONV || curLayerType === nodeType.FC) {\n        // CONV and FC layers have weights in links. Links are one-to-multiple\n        for (let j = 0; j < nn[curLayerIndex - 1].length; j++) {\n          let preNode = nn[curLayerIndex - 1][j];\n          let curLink = new Link(preNode, node, layer.weights[i].weights[j]);\n          preNode.outputLinks.push(curLink);\n          node.inputLinks.push(curLink);\n        }\n      } else if (curLayerType === nodeType.RELU || curLayerType === nodeType.POOL) {\n        // RELU and POOL layers have no weights. Links are one-to-one\n        let preNode = nn[curLayerIndex - 1][i];\n        let link = new Link(preNode, node, null);\n        preNode.outputLinks.push(link);\n        node.inputLinks.push(link);\n      } else if (curLayerType === nodeType.FLATTEN) {\n        // Flatten layer has no weights. Links are multiple-to-one.\n        // Use dummy weights to store the corresponding entry in the previsou\n        // node as (row, column)\n        // The flatten() in tf2.keras has order: channel -> row -> column\n        let preNodeWidth = nn[curLayerIndex - 1][0].output.length,\n          preNodeNum = nn[curLayerIndex - 1].length,\n          preNodeIndex = i % preNodeNum,\n          preNodeRow = Math.floor(Math.floor(i / preNodeNum) / preNodeWidth),\n          preNodeCol = Math.floor(i / preNodeNum) % preNodeWidth,\n          link = new Link(nn[curLayerIndex - 1][preNodeIndex],\n            node, [preNodeRow, preNodeCol]);\n\n        nn[curLayerIndex - 1][preNodeIndex].outputLinks.push(link);\n        node.inputLinks.push(link);\n      }\n      curLayerNodes.push(node);\n    }\n\n    // Add current layer to the NN\n    nn.push(curLayerNodes);\n    curLayerIndex++;\n  });\n\n  return nn;\n}\n\nexport const constructNN = (inputImageFile) => {\n  // Load the saved model file\n  return new Promise((resolve, reject) => {\n    fetch('PUBLIC_URL/assets/data/nn_10.json')\n      .then(response => {\n        response.json().then(nnJSON => {\n          getInputImageArray(inputImageFile)\n            .then(inputImageArray => {\n              let nn = constructNNFromJSON(nnJSON, inputImageArray);\n              resolve(nn);\n            })\n        });\n      })\n      .catch(error => {\n        reject(error);\n      });\n  });\n}\n\n// Helper functions\n\n/**\n * Create a 2D array (matrix) with given size and default value.\n * \n * @param {int} height Height (number of rows) for the matrix\n * @param {int} width Width (number of columns) for the matrix\n * @param {int} fill Default value to fill this matrix\n */\nexport const init2DArray = (height, width, fill) => {\n  let array = [];\n  // Itereate through rows\n  for (let r = 0; r < height; r++) {\n    let row = new Array(width).fill(fill);\n    array.push(row);\n  }\n  return array;\n}\n\n/**\n * Dot product of two matrices.\n * @param {[[number]]} mat1 Matrix 1\n * @param {[[number]]} mat2 Matrix 2\n */\nconst matrixDot = (mat1, mat2) => {\n  console.assert(mat1.length === mat2.length, 'Dimension not matching');\n  console.assert(mat1[0].length === mat2[0].length, 'Dimension not matching');\n\n  let result = 0;\n  for (let i = 0; i < mat1.length; i++){\n    for (let j = 0; j < mat1[0].length; j++){\n      result += mat1[i][j] * mat2[i][j];\n    }\n  }\n  \n  return result;\n}\n\n/**\n * Matrix elementwise addition.\n * @param {[[number]]} mat1 Matrix 1\n * @param {[[number]]} mat2 Matrix 2\n */\nexport const matrixAdd = (mat1, mat2) => {\n  console.assert(mat1.length === mat2.length, 'Dimension not matching');\n  console.assert(mat1[0].length === mat2[0].length, 'Dimension not matching');\n\n  let result = init2DArray(mat1.length, mat1.length, 0);\n\n  for (let i = 0; i < mat1.length; i++) {\n    for (let j = 0; j < mat1.length; j++) {\n      result[i][j] = mat1[i][j] + mat2[i][j];\n    }\n  }\n\n  return result;\n}\n\n/**\n * 2D slice on a matrix.\n * @param {[[number]]} mat Matrix\n * @param {int} xs First dimension (row) starting index\n * @param {int} xe First dimension (row) ending index\n * @param {int} ys Second dimension (column) starting index\n * @param {int} ye Second dimension (column) ending index\n */\nexport const matrixSlice = (mat, xs, xe, ys, ye) => {\n  return mat.slice(xs, xe).map(s => s.slice(ys, ye));\n}\n\n/**\n * Compute the maximum of a matrix.\n * @param {[[number]]} mat Matrix\n */\nconst matrixMax = (mat) => {\n  let curMax = -Infinity;\n  for (let i = 0; i < mat.length; i++) {\n    for (let j = 0; j < mat[0].length; j++) {\n      if (mat[i][j] > curMax) {\n        curMax = mat[i][j];\n      }\n    }\n  }\n  return curMax;\n}\n\n/**\n * Convert canvas image data into a 3D array with dimension [height, width, 3].\n * Each pixel is in 0-255 scale.\n * @param {[int8]} imageData Canvas image data\n */\nconst imageDataTo3DArray = (imageData) => {\n  // Get image dimension (assume square image)\n  let width = Math.sqrt(imageData.length / 4);\n\n  // Create array placeholder for each channel\n  let imageArray = [init2DArray(width, width, 0), init2DArray(width, width, 0),\n    init2DArray(width, width, 0)];\n  \n  // Iterate through the data to fill out channel arrays above\n  for (let i = 0; i < imageData.length; i++) {\n    let pixelIndex = Math.floor(i / 4),\n      channelIndex = i % 4,\n      row = Math.floor(pixelIndex / width),\n      column = pixelIndex % width;\n    \n    if (channelIndex < 3) {\n      imageArray[channelIndex][row][column] = imageData[i];\n    }\n  }\n\n  return imageArray;\n}\n\n/**\n * Get the 3D pixel value array of the given image file.\n * @param {string} imgFile File path to the image file\n * @returns A promise with the corresponding 3D array\n */\nconst getInputImageArray = (imgFile) => {\n  let canvas = document.createElement('canvas');\n  canvas.style.cssText = 'display:none;';\n  document.getElementsByTagName('body')[0].appendChild(canvas);\n  let context = canvas.getContext('2d');\n\n  return new Promise((resolve, reject) => {\n    let inputImage = new Image();\n    inputImage.src = imgFile;\n    inputImage.onload = () => {\n      context.drawImage(inputImage, 0, 0,);\n      // Get image data and convert it to a 3D array\n      let imageData = context.getImageData(0, 0, inputImage.width,\n        inputImage.height).data;\n\n      // Remove this newly created canvas element\n      canvas.parentNode.removeChild(canvas);\n\n      console.log(imageDataTo3DArray(imageData));\n      resolve(imageDataTo3DArray(imageData));\n    }\n    inputImage.onerror = reject;\n  })\n}\n\n/**\n * Compute convolutions of one kernel on one matrix (one slice of a tensor).\n * @param {[[number]]} input Input, square matrix\n * @param {[[number]]} kernel Kernel weights, square matrix\n * @param {int} stride Stride size\n * @param {int} padding Padding size\n */\nexport const singleConv = (input, kernel, stride=1, padding=0) => {\n  // TODO: implement padding\n\n  // Only support square input and kernel\n  console.assert(input.length === input[0].length,\n     'Conv input is not square');\n  console.assert(kernel.length === kernel[0].length,\n    'Conv kernel is not square');\n\n  let stepSize = (input.length - kernel.length) / stride + 1;\n\n  let result = init2DArray(stepSize, stepSize, 0);\n\n  // Window sliding\n  for (let r = 0; r < stepSize; r++) {\n    for (let c = 0; c < stepSize; c++) {\n      let curWindow = matrixSlice(input, r * stride, r * stride + kernel.length,\n        c * stride, c * stride + kernel.length);\n      let dot = matrixDot(curWindow, kernel);\n      result[r][c] = dot;\n    }\n  }\n  return result;\n}\n\n/**\n * Convolution operation. This function update the outputs property of all nodes\n * in the given layer. Previous layer is accessed by the reference in nodes'\n * links.\n * @param {[Node]} curLayer Conv layer.\n */\nconst convolute = (curLayer) => {\n  console.assert(curLayer[0].type === 'conv', 'Wrong layer type');\n\n  // Itereate through all nodes in curLayer to update their outputs\n  curLayer.forEach(node => {\n    /*\n     * Accumulate the single conv result matrices from previous channels.\n     * Previous channels (node) are accessed by the reference in Link objects.\n     */\n    let newOutput = init2DArray(node.output.length, node.output.length, 0);\n\n    for (let i = 0; i < node.inputLinks.length; i++) {\n      let curLink = node.inputLinks[i];\n      let curConvResult = singleConv(curLink.source.output, curLink.weight);\n      newOutput = matrixAdd(newOutput, curConvResult);\n    }\n\n    // Add bias to all element in the output\n    let biasMatrix = init2DArray(newOutput.length, newOutput.length, node.bias);\n    newOutput = matrixAdd(newOutput, biasMatrix);\n\n    node.output = newOutput;\n  })\n}\n\n/**\n * Activate matrix mat using ReLU (max(0, x)).\n * @param {[[number]]} mat Matrix\n */\nconst singleRelu = (mat) => {\n  // Only support square matrix\n  console.assert(mat.length === mat[0].length, 'Activating non-square matrix!');\n\n  let width = mat.length;\n  let result = init2DArray(width, width, 0);\n\n  for (let i = 0; i < width; i++) {\n    for (let j = 0; j < width; j++) {\n      result[i][j] = Math.max(0, mat[i][j]);\n    }\n  }\n  return result;\n}\n\n/**\n * Update outputs of all nodes in the current ReLU layer. Values of previous\n * layer nodes are accessed by the links stored in the current layer.\n * @param {[Node]} curLayer ReLU layer\n */\nconst relu = (curLayer) => {\n  console.assert(curLayer[0].type === 'relu', 'Wrong layer type');\n\n  // Itereate through all nodes in curLayer to update their outputs\n  for (let i = 0; i < curLayer.length; i++) {\n    let curNode = curLayer[i];\n    let preNode = curNode.inputLinks[0].source;\n    curNode.output = singleRelu(preNode.output);\n  }\n}\n\n/**\n * Max pool one matrix.\n * @param {[[number]]} mat Matrix\n * @param {int} kernelWidth Pooling kernel length (only supports 2)\n * @param {int} stride Pooling sliding stride (only supports 2)\n * @param {string} padding Pading method when encountering odd number mat,\n * currently this function only supports 'VALID'\n */\nexport const singleMaxPooling = (mat, kernelWidth=2, stride=2, padding='VALID') => {\n  console.assert(kernelWidth === 2, 'Only supports kernen = [2,2]');\n  console.assert(stride === 2, 'Only supports stride = 2');\n  console.assert(padding === 'VALID', 'Only support valid padding');\n\n  // Handle odd length mat\n  // 'VALID': ignore edge rows and columns\n  // 'SAME': add zero padding to make the mat have even length\n  if (mat.length % 2 === 1 && padding === 'VALID') {\n    mat = matrixSlice(mat, 0, mat.length - 1, 0, mat.length - 1);\n  }\n\n  let stepSize = (mat.length - kernelWidth) / stride + 1;\n  let result = init2DArray(stepSize, stepSize, 0);\n\n  for (let r = 0; r < stepSize; r++) {\n    for (let c = 0; c < stepSize; c++) {\n      let curWindow = matrixSlice(mat, r * stride, r * stride + kernelWidth,\n        c * stride, c * stride + kernelWidth);\n      result[r][c] = matrixMax(curWindow);\n    }\n }\n return result;\n}\n\n/**\n * Max pooling one layer.\n * @param {[Node]} curLayer MaxPool layer\n */\nconst maxPooling = (curLayer) => {\n  console.assert(curLayer[0].type === 'pool', 'Wrong layer type');\n\n  // Itereate through all nodes in curLayer to update their outputs\n  for (let i = 0; i < curLayer.length; i++) {\n    let curNode = curLayer[i];\n    let preNode = curNode.inputLinks[0].source;\n    curNode.output = singleMaxPooling(preNode.output);\n  }\n}\n\n/**\n * Flatten a previous 2D layer (conv2d or maxpool2d). The flatten order matches\n * tf2.keras' implementation: channel -> row -> column.\n * @param {[Node]} curLayer Flatten layer\n */\nconst flatten = (curLayer) => {\n  console.assert(curLayer[0].type === 'flatten', 'Wrong layer type');\n\n  // Itereate through all nodes in curLayer to update their outputs\n  for (let i = 0; i < curLayer.length; i++) {\n    let curNode = curLayer[i];\n    let preNode = curNode.inputLinks[0].source;\n    let coordinate = curNode.inputLinks[0].weight;\n    // Take advantage of the dummy weights\n    curNode.output = preNode.output[coordinate[0]][coordinate[1]];\n  }\n}\n\nconst fullyConnect = (curLayer) => {\n  console.assert(curLayer[0].type === 'fc', 'Wrong layer type');\n  // TODO\n}\n\nexport const tempMain = async () => {\n  let nn = await constructNN('PUBLIC_URL/assets/img/koala.jpeg');\n  convolute(nn[1]);\n  relu(nn[2])\n  convolute(nn[3]);\n  relu(nn[4]);\n  maxPooling(nn[5]);\n  convolute(nn[6]);\n  relu(nn[7])\n  convolute(nn[8]);\n  relu(nn[9]);\n  maxPooling(nn[10]);\n  convolute(nn[11]);\n  relu(nn[12])\n  convolute(nn[13]);\n  relu(nn[14]);\n  maxPooling(nn[15]);\n  flatten(nn[16]);\n  console.log(nn[16].map(d => d.output));\n}","import { matrixSlice } from '../utils/cnn.js';\n\nexport function array1d(length, f) {\n  return Array.from({length: length}, f ? ((v, i) => f(i)) : undefined);\n}\n\nfunction array2d(height, width, f) {\n  return Array.from({length: height}, (v, i) => Array.from({length: width}, f ? ((w, j) => f(i, j)) : undefined));\n}\n\nexport function generateOutputMappings(stride, output, kernelLength, padded_input_size, dilation) {\n  const outputMapping = array2d(output.length, output.length, (i, j) => array2d(kernelLength, kernelLength));\n  for (let h_out = 0; h_out < output.length; h_out++) {\n    for (let w_out = 0; w_out < output.length; w_out++) {\n      for (let h_kern = 0; h_kern < kernelLength; h_kern++) {\n        for (let w_kern = 0; w_kern < kernelLength; w_kern++) {\n          const h_im = h_out * stride + h_kern * dilation;\n          const w_im = w_out * stride + w_kern * dilation;\n          outputMapping[h_out][w_out][h_kern][w_kern] = h_im * padded_input_size + w_im;\n        }\n      }\n    }\n  }\n  return outputMapping;\n}\n\nexport function compute_input_multiplies_with_weight(hoverH, hoverW, \n                                              padded_input_size, weight_dims, outputMappings, kernelLength) {\n  \n  const [h_weight, w_weight] = weight_dims;\n  const input_multiplies_with_weight = array1d(padded_input_size * padded_input_size);\n  for (let h_weight = 0; h_weight < kernelLength; h_weight++) {\n    for (let w_weight = 0; w_weight < kernelLength; w_weight++) {\n      const flat_input = outputMappings[hoverH][hoverW][h_weight][w_weight];\n      if (typeof flat_input === \"undefined\") continue;\n      input_multiplies_with_weight[flat_input] = [h_weight, w_weight];\n    }\n  }\n  return input_multiplies_with_weight;\n}\n\nexport function getMatrixSliceFromInputHighlights(matrix, highlights, kernelLength) {\n  var indices = highlights.reduce((total, value, index) => {\n  if (value != undefined) total.push(index);\n    return total;\n  }, []);\n  return matrixSlice(matrix, Math.floor(indices[0] / matrix.length), Math.floor(indices[0] / matrix.length) + kernelLength, indices[0] % matrix.length, indices[0] % matrix.length + kernelLength);\n}\n\nexport function getMatrixSliceFromOutputHighlights(matrix, highlights) {\n  var indices = highlights.reduce((total, value, index) => {\n  if (value != false) total.push(index);\n    return total;\n  }, []);\n  return matrixSlice(matrix, Math.floor(indices[0] / matrix.length), Math.floor(indices[0] / matrix.length) + 1, indices[0] % matrix.length, indices[0] % matrix.length + 1);\n}\n\n// Edit these values to change size of low-level conv visualization.\nexport function getVisualizationSizeConstraint(imageLength) {\n  let sizeOfGrid = 150;\n  let maxSizeOfGridCell = 20;\n  return sizeOfGrid / imageLength > maxSizeOfGridCell ? maxSizeOfGridCell : sizeOfGrid / imageLength;\n}\n\nexport function getDataRange(image) {\n  let maxRow = image.map(function(row){ return Math.max.apply(Math, row); });\n  let max = Math.max.apply(null, maxRow);\n  let minRow = image.map(function(row){ return Math.min.apply(Math, row); });\n  let min = Math.min.apply(null, minRow);\n  let range = {\n    range: 2 * Math.max(Math.abs(min), Math.abs(max)),\n    min: min,\n    max: max\n  };\n  return range;\n}\n\nexport function gridData(image, constraint=getVisualizationSizeConstraint(image.length)) {\n  // Constrain grids based on input image size.\n  var data = new Array();\n  var xpos = 1;\n  var ypos = 1;\n  var width = constraint;\n  var height = constraint;\n  for (var row = 0; row < image.length; row++) {\n    data.push( new Array() );\n    for (var column = 0; column < image[0].length; column++) {\n      data[row].push({\n        text: Math.round(image[row][column] * 100) / 100,\n        row: row,\n        col: column,\n        x: xpos,\n        y: ypos,\n        width: width,\n        height: height\n      })\n      xpos += width;\n    }\n    xpos = 1;\n    ypos += height; \n  }\n  return data;\n}","<script>\n  export let data;\n  export let highlights;\n  export let isKernelMath;\n  export let constraint;\n  export let dataRange;\n  export let outputLength = undefined;\n  export let stride = undefined;\n  export let colorScale = d3.interpolateRdBu;\n  export let isInputLayer = false;\n\n  import { onMount } from 'svelte';\n  import { onDestroy } from 'svelte';\n  import { beforeUpdate, afterUpdate } from 'svelte';\n  import { createEventDispatcher } from 'svelte';\n\n  let grid_final;\n  const textConstraintDivisor = 2.6;\n  const standardCellColor = \"ddd\";\n  const dispatch = createEventDispatcher();\n\n  let oldHighlight = highlights;\n  let oldData = data;\n\n  const redraw = () => {\n    d3.select(grid_final).selectAll(\"#grid > *\").remove();\n    const constrainedSvgSize = data.length * constraint + 2;\n    var grid = d3.select(grid_final).select(\"#grid\")\n      .attr(\"width\", constrainedSvgSize + \"px\")\n      .attr(\"height\", constrainedSvgSize + \"px\")\n      .append(\"svg\")\n      .attr(\"width\", constrainedSvgSize + \"px\")\n      .attr(\"height\", constrainedSvgSize + \"px\")\n    var row = grid.selectAll(\".row\")\n      .data(data)\n      .enter().append(\"g\")\n      .attr(\"class\", \"row\");\n    var column = row.selectAll(\".square\")\n      .data(function(d) { return d; })\n      .enter().append(\"rect\")\n      .attr(\"class\",\"square\")\n      .attr(\"x\", function(d) { return d.x; })\n      .attr(\"y\", function(d) { return d.y; })\n      .attr(\"width\", function(d) { return d.width; })\n      .attr(\"height\", function(d) { return d.height; })\n      .style(\"opacity\", 0.8)\n      .style(\"fill\", function(d) {\n        let normalizedValue = d.text;\n        if (isInputLayer){\n          normalizedValue = 1 - d.text;\n        } else {\n          normalizedValue = (d.text + dataRange / 2) / dataRange;\n        }\n        return colorScale(normalizedValue);\n      })\n      .on('mouseover', function(d) {\n        if (data.length != outputLength) {\n          dispatch('message', {\n            hoverH: Math.min(Math.floor(d.row / stride), outputLength - 1),\n            hoverW: Math.min(Math.floor(d.col / stride), outputLength - 1)\n          });\n        } else {\n          dispatch('message', {\n            hoverH: Math.min(Math.floor(d.row / 1), outputLength - 1),\n            hoverW: Math.min(Math.floor(d.col / 1), outputLength - 1)\n          });\n        }\n      });\n    if (isKernelMath) {\n      var text = row.selectAll(\".text\")\n        .data(function(d) { return d; })\n        .enter().append(\"text\")\n        .attr(\"class\",\"text\")\n        .style(\"font-size\", Math.floor(constraint / textConstraintDivisor) + \"px\")\n        .attr(\"x\", function(d) { return d.x + d.width / 2; })\n        .attr(\"y\", function(d) { return d.y + d.height / 2; })\n        .style(\"fill\", function(d) {\n        let normalizedValue = d.text;\n          if (isInputLayer){\n            normalizedValue = 1 - d.text;\n          } else {\n            normalizedValue = (d.text + dataRange / 2) / dataRange;\n          }\n          if (normalizedValue < 0.2 || normalizedValue > 0.8) {\n            return 'white';\n          } else {\n            return 'black';\n          }\n        })\n        .style(\"text-anchor\", \"middle\")\n        .style(\"dominant-baseline\", \"middle\")\n        .text(function(d) {\n          return d.text.toString().replace('-', '');\n        })\n    }\n  }\n\n  afterUpdate(() => {\n    if (data != oldData) {\n      redraw();\n      oldData = data;\n    }\n\n    if (highlights != oldHighlight) {\n      var grid = d3.select(grid_final).select('#grid').select(\"svg\")\n      grid.selectAll(\".square\")\n        .style(\"stroke\", (d) => isKernelMath || (highlights.length && highlights[d.row * data.length + d.col]) ? \"black\" : null )\n      oldHighlight = highlights;\n    }\n\n  });\n\n  onMount(() => {\n    redraw();\n  });\n\n</script>\n\n<div style=\"display: inline-block; vertical-align: middle;\" class=\"grid\"\n  bind:this={grid_final}>\n  <svg id=\"grid\" width=100% height=100%></svg>\n</div>","<script>\n  export let data;\n  export let kernel;\n  export let constraint;\n  export let dataRange;\n  export let kernelRange;\n  export let colorScale = d3.interpolateRdBu;\n  export let kernelColorScale = d3.interpolateBrBG;\n  export let isInputLayer = false;\n\n  import { onMount } from 'svelte';\n  import { afterUpdate } from 'svelte';\n\n  let gridFinal;\n  let legendFinal;\n  const textConstraintDivisor = 2.6;\n  const multiplicationSymbolPadding = Math.floor(constraint / 3);\n\n  let oldData = data;\n  let oldKernel = kernel;\n\n  // Legend drawn similarly to legends in overview/intermediate-view.\n  const addOverlayGradient = (gradientID, stops, group) => {\n    if (group === undefined) {\n      group = svg;\n    }\n\n    // Create a gradient\n    let defs = group.append(\"defs\")\n      .attr('class', 'overlay-gradient');\n\n    let gradient = defs.append(\"linearGradient\")\n      .attr(\"id\", gradientID)\n      .attr(\"x1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y1\", \"100%\")\n      .attr(\"y2\", \"100%\");\n    \n    stops.forEach(s => {\n      gradient.append('stop')\n        .attr('offset', s.offset)\n        .attr('stop-color', s.color)\n        .attr('stop-opacity', s.opacity);\n    })\n  }\n\n  // Draw the legend for intermediate layer\n  const redrawDetailedConvViewLegend = (arg) => {\n    let legendHeight = arg.legendHeight,\n      range = arg.range,\n      minMax = arg.minMax,\n      width = arg.width,\n      colorScale = arg.colorScale,\n      gradientGap = arg.gradientGap;\n\n    d3.select(legendFinal).selectAll(\"#legend > *\").remove();\n    let legend = d3.select(legendFinal).select(\"#legend\")\n      .attr(\"width\", 150 + \"px\")\n      .attr(\"height\", 25 + \"px\")\n      .attr(\"align\",\"center\")\n      .style(\"dominant-baseline\", \"middle\");\n    let detailedViewKernel = legend.append('g')\n      .attr('transform', `translate(10, 0)`);\n    \n    if (colorScale === undefined) { colorScale = layerColorScales.conv; }\n    if (gradientGap === undefined) { gradientGap = 0; }\n    \n    // Add a legend color gradient\n    let gradientName = `url(#detailed-kernel-gradient)`;\n    let normalizedColor = v => colorScale(v * (1 - 2 * gradientGap) + gradientGap);\n\n    let leftValue = (minMax.min + range / 2) / range,\n      zeroValue = (0 + range / 2) / range,\n      rightValue = (minMax.max + range / 2) / range,\n      totalRange = minMax.max - minMax.min,\n      zeroLocation = (0 - minMax.min) / totalRange,\n      leftMidValue = leftValue + (zeroValue - leftValue)/2,\n      rightMidValue = zeroValue + (rightValue - zeroValue)/2;\n\n    let stops = [\n      {offset: 0, color: normalizedColor(leftValue), opacity: 1},\n      {offset: zeroLocation / 2,\n        color: normalizedColor(leftMidValue),\n        opacity: 1},\n      {offset: zeroLocation,\n        color: normalizedColor(zeroValue),\n        opacity: 1},\n      {offset: zeroLocation + (1 - zeroValue) / 2,\n        color: normalizedColor(rightMidValue),\n        opacity: 1},\n      {offset: 1, color: normalizedColor(rightValue), opacity: 1}\n    ];\n\n    addOverlayGradient(`detailed-kernel-gradient`, stops, detailedViewKernel);\n\n    let legendScale = d3.scaleLinear()\n      .range([0, width - 1.2])\n      .domain([minMax.min, minMax.max]);\n\n    let legendAxis = d3.axisBottom()\n      .scale(legendScale)\n      .tickFormat(d3.format('.2f'))\n      .tickValues([minMax.min, 0, minMax.max]);\n    \n    let detailedLegend = detailedViewKernel.append('g')\n      .attr('id', `detailed-legend-0`)\n    \n    let legendGroup = detailedLegend.append('g')\n      .attr('transform', `translate(0, ${legendHeight - 3})`)\n      .call(legendAxis);\n    \n    legendGroup.selectAll('text')\n      .style('font-size', '9px')\n      .style('fill', \"black\");\n    \n    legendGroup.selectAll('path, line')\n      .style('stroke', \"black\");\n\n    detailedLegend.append('rect')\n      .attr('width', width)\n      .attr('height', legendHeight)\n      .style('fill', gradientName);\n  }\n\n  // Draw the elementwise dot-product math.\n  const redraw = () => {\n    d3.select(gridFinal).selectAll(\"#grid > *\").remove();\n    const constrainedSvgSize = kernel ? 2 * (data.length * constraint) + 2 : data.length * constraint + 2;\n    var grid = d3.select(gridFinal).select(\"#grid\")\n      .attr(\"width\", constrainedSvgSize + \"px\")\n      .attr(\"height\", constrainedSvgSize + \"px\")\n      .append(\"svg\")\n      .attr(\"width\", constrainedSvgSize + \"px\")\n      .attr(\"height\", constrainedSvgSize + \"px\")\n    var row = grid.selectAll(\".row\")\n      .data(data)\n      .enter().append(\"g\")\n      .attr(\"class\", \"row\");\n    \n    var columns = row.selectAll(\".square\")\n      .data(function(d) { return d; })\n      .enter();\n    // Draw cells for slice from input matrix.\n    columns.append(\"rect\")\n      .attr(\"class\",\"square\")\n      .attr(\"x\", function(d) { return d.x === 1 ? d.x + multiplicationSymbolPadding : d.x * 2 + multiplicationSymbolPadding})\n      .attr(\"y\", function(d) { return d.y === 1 ? d.y : d.y * 2 })\n      .attr(\"width\", function(d) { return d.width; })\n      .attr(\"height\", function(d) { return d.height; })\n      .style(\"opacity\", 0.5)\n      .style(\"fill\", function(d) { \n        let normalizedValue = d.text;\n        if (isInputLayer){\n          normalizedValue = 1 - d.text;\n        } else {\n          normalizedValue = (d.text + dataRange / 2) / dataRange;\n        }\n        return colorScale(normalizedValue); \n      })\n      .style(\"stroke\", \"black\");\n    // Draw cells for the kernel.\n    columns.append(\"rect\")\n      .attr(\"class\",\"square\")\n      .attr(\"x\", function(d) { return d.x === 1 ? d.x + multiplicationSymbolPadding: d.x * 2 + multiplicationSymbolPadding})\n      .attr(\"y\", function(d) { return d.y === 1 ? d.y + d.height : d.y * 2 + d.height })\n      .attr(\"width\", function(d) { return d.width; })\n      .attr(\"height\", function(d) { return d.height / 2; })\n      .style(\"opacity\", 0.5)\n      // Same colorscale as is used for the flatten layers.\n      .style(\"fill\", function(d) { \n        let normalizedValue = (kernel[d.row][d.col].text + kernelRange.range / 2) / kernelRange.range;\n        const gap = 0.2;\n        let normalizedValueWithGap = normalizedValue * (1 - 2 * gap) + gap;\n        return kernelColorScale(normalizedValueWithGap); \n      })\n\n    var texts = row.selectAll(\".text\")\n      .data(function(d) { return d; })\n      .enter();\n    // Draw numbers from input matrix slice.\n    texts.append(\"text\")\n      .attr(\"class\",\"text\")\n      .style(\"font-size\", Math.floor(constraint / textConstraintDivisor) + \"px\")\n      .attr(\"x\", function(d) { return d.x === 1 ? d.x + d.width / 2 + multiplicationSymbolPadding: d.x * 2 + d.width / 2 + multiplicationSymbolPadding})\n      .attr(\"y\", function(d) { return d.y === 1 ? d.y + d.height / 2 : d.y * 2 + d.height / 2 })\n      .style(\"fill\", function(d) { \n        let normalizedValue = d.text;\n        if (isInputLayer){\n          normalizedValue = 1 - d.text;\n        } else {\n          normalizedValue = (d.text + dataRange / 2) / dataRange;\n        }\n        if (normalizedValue < 0.2 || normalizedValue > 0.8) {\n          if (isInputLayer && normalizedValue < 0.2) {\n            return 'black';\n          } \n          return 'white';\n        } else {\n          return 'black';\n        }\n      })\n      .style(\"text-anchor\", \"middle\")\n      .style(\"dominant-baseline\", \"middle\")\n      .text(function(d) { return d.text; })\n    // Attempted to use FontAwesome icons for the 'x', '+', and '=', but none of these strategies work: https://github.com/FortAwesome/Font-Awesome/issues/12268\n    // Draw 'x' to signify multiplication.\n    texts.append(\"text\")\n      .attr(\"class\",\"text\")\n      .style(\"font-size\", Math.floor(constraint / (textConstraintDivisor)) + \"px\")\n      .attr('font-weight', 600)\n      .attr(\"x\", function(d) { return d.x === 1 ? d.x + multiplicationSymbolPadding / 2: d.x * 2 + multiplicationSymbolPadding / 2})\n      .attr(\"y\", function(d) { return d.y === 1 ? d.y + d.height + (d.height / 4) : d.y * 2 + d.height + (d.height / 4) })\n      .style(\"fill\", \"black\")\n      .style(\"text-anchor\", \"middle\")\n      .style(\"dominant-baseline\", \"middle\")\n      .text(function(d) { return '' })\n    // Draw kernel values.\n    texts.append(\"text\")\n      .attr(\"class\",\"text\")\n      .style(\"font-size\", Math.floor(constraint / textConstraintDivisor) + \"px\")\n      .attr(\"x\", function(d) { return d.x === 1 ? d.x + d.width / 2 + multiplicationSymbolPadding: d.x * 2 + d.width / 2 + multiplicationSymbolPadding})\n      .attr(\"y\", function(d) { return d.y === 1 ? d.y + d.height + (d.height / 4) : d.y * 2 + d.height + (d.height / 4) })\n      .style(\"fill\", function(d) { \n        let normalizedValue = (kernel[d.row][d.col].text + kernelRange.range / 2) / kernelRange.range;\n        const gap = 0.2;\n        let normalizedValueWithGap = normalizedValue * (1 - 2 * gap) + gap;\n        if (normalizedValueWithGap < 0.2 || normalizedValueWithGap > 0.8) {\n          return 'white';\n        } else {\n          return 'black';\n        }\n      })\n      .style(\"text-anchor\", \"middle\")\n      .style(\"dominant-baseline\", \"middle\")\n      .text(function(d) { return kernel[d.row][d.col].text; })\n    // Draw '+' to signify the summing of products except for the last kernel cell where '=' is drawn.\n    texts.append(\"text\")\n      .attr(\"class\",\"text\")\n      .style(\"font-size\", Math.floor(constraint / (textConstraintDivisor - 1)) + \"px\")\n      .attr(\"x\", function(d) { return d.x === 1 ? d.x + d.width + d.width / 2 + multiplicationSymbolPadding: d.x * 2 + d.width + d.width / 2 + multiplicationSymbolPadding})\n      .attr(\"y\", function(d) { return d.y === 1 ? d.y + d.height / 2 : d.y * 2 + d.height / 2 })\n      .style(\"text-anchor\", \"middle\")\n      .style(\"dominant-baseline\", \"middle\")\n      .text(function(d) { return d.row == kernel.length - 1 && d.col == kernel.length - 1 ? '=' : '+'; })\n    }\n\n  afterUpdate(() => {\n    if (data != oldData) {\n      redraw();\n      oldData = data;\n    }\n    if (kernel != oldKernel) {\n      /*\n      redrawDetailedConvViewLegend({\n          legendHeight: 5,\n          range: kernelRange.range,\n          minMax: {min: kernelRange.min, max: kernelRange.max},\n          width: 130,\n          colorScale: kernelColorScale,\n          gradientGap: 0.35,\n      });\n      */\n      oldKernel = kernel;\n    }\n  });\n\n  onMount(() => {\n    redraw();\n    /*\n    redrawDetailedConvViewLegend({\n          legendHeight: 5,\n          range: kernelRange.range,\n          minMax: {min: kernelRange.min, max: kernelRange.max},\n          width: 130,\n          colorScale: kernelColorScale,\n          gradientGap: 0.35,\n    });\n    */\n  });\n\n</script>\n\n<div class=\"legend\"\n  bind:this={legendFinal}>\n  <!-- <svg id=\"legend\" width=100% height=100%></svg> -->\n</div>\n\n<div class=\"grid\"\n  bind:this={gridFinal}>\n  <svg id=\"grid\" width=100% height=100%></svg>\n</div>","<script>\n  import { createEventDispatcher } from 'svelte';\n  import { array1d, getMatrixSliceFromOutputHighlights,\n    compute_input_multiplies_with_weight, getDataRange,\n    getVisualizationSizeConstraint, generateOutputMappings,\n    getMatrixSliceFromInputHighlights, gridData\n  } from './DetailviewUtils.js';\n  import Dataview from './Dataview.svelte';\n  import KernelMathView from './KernelMathView.svelte';\n  // image: nxn array -- prepadded.\n  // kernel: mxm array.\n  // stride: int\n  export let stride;\n  export let dilation\n  export let kernel;\n  export let image;\n  export let output;\n  export let isPaused;\n  export let dataRange;\n  export let colorScale;\n  export let isInputInputLayer = false;\n\n  const dispatch = createEventDispatcher();\n  const padding = 0;\n  let padded_input_size = image.length + padding * 2;\n  $: padded_input_size = image.length + padding * 2;\n\n  // Dummy data for original state of component.\n  let testInputMatrixSlice = [];\n  for (let i = 0; i < kernel.length; i++) {\n    testInputMatrixSlice.push([]);\n    for (let j = 0; j < kernel.length; j++) {\n      testInputMatrixSlice[i].push(0)\n    }\n  }\n  testInputMatrixSlice = gridData(testInputMatrixSlice)\n  let testOutputMatrixSlice = gridData([0]);\n\n  let inputHighlights = [];\n  let outputHighlights = array1d(output.length * output.length, (i) => true);\n  let interval;\n  $ : {\n    let inputHighlights = [];\n    let outputHighlights = array1d(output.length * output.length, (i) => true);\n    let interval;\n  }\n\n  let counter;\n  // lots of replication between mouseover and start-conv. TODO: fix this.\n  function startConvolution(stride) {\n    counter = 0;\n    let outputMappings = generateOutputMappings(stride, output, kernel.length, padded_input_size, dilation);\n    if (stride <= 0) return;\n    if (interval) clearInterval(interval);\n    interval = setInterval(() => {\n      if (isPaused) return;\n      const flat_animated = counter % (output.length * output.length);\n      outputHighlights = array1d(output.length * output.length, (i) => false);\n      const animatedH = Math.floor(flat_animated / output.length);\n      const animatedW = flat_animated % output.length;\n      outputHighlights[animatedH * output.length + animatedW] = true;\n      inputHighlights = compute_input_multiplies_with_weight(animatedH, animatedW, padded_input_size, kernel.length, outputMappings, kernel.length)\n      const inputMatrixSlice = getMatrixSliceFromInputHighlights(image, inputHighlights, kernel.length);\n      testInputMatrixSlice = gridData(inputMatrixSlice);\n      const outputMatrixSlice = getMatrixSliceFromOutputHighlights(output, outputHighlights);\n      testOutputMatrixSlice = gridData(outputMatrixSlice);\n      counter++;\n    }, 250)\n  }\n\n  function handleMouseover(event) {\n    let outputMappings = generateOutputMappings(stride, output, kernel.length, padded_input_size, dilation);\n    outputHighlights = array1d(output.length * output.length, (i) => false);\n    const animatedH = event.detail.hoverH;\n    const animatedW = event.detail.hoverW;\n    outputHighlights[animatedH * output.length + animatedW] = true;\n    inputHighlights = compute_input_multiplies_with_weight(animatedH, animatedW, padded_input_size, kernel.length, outputMappings, kernel.length)\n    const inputMatrixSlice = getMatrixSliceFromInputHighlights(image, inputHighlights, kernel.length);\n    testInputMatrixSlice = gridData(inputMatrixSlice);\n    const outputMatrixSlice = getMatrixSliceFromOutputHighlights(output, outputHighlights);\n    testOutputMatrixSlice = gridData(outputMatrixSlice);\n    isPaused = true;\n    dispatch('message', {\n      text: isPaused\n    });\n  }\n\n  startConvolution(stride);\n  let testImage = gridData(image)\n  let testOutput = gridData(output)\n  let testKernel = gridData(kernel)\n  $ : {\n    startConvolution(stride);\n    testImage = gridData(image)\n    testOutput = gridData(output)\n    testKernel = gridData(kernel)\n  }\n</script>\n\n<style>\n  .column {\n    padding: 5px;\n  }\n</style>\n\n<div class=\"column has-text-centered\">\n  <div class=\"header-text\">\n    Input ({image.length}, {image[0].length})\n  </div>\n  <Dataview on:message={handleMouseover} data={testImage} highlights={inputHighlights} outputLength={output.length}\n      isKernelMath={false} constraint={getVisualizationSizeConstraint(image.length)}\n      dataRange={dataRange} stride={stride} colorScale={colorScale}\n      isInputLayer={isInputInputLayer}/>\n</div>\n<div class=\"column has-text-centered\">\n  <KernelMathView data={testInputMatrixSlice} kernel={testKernel} constraint={getVisualizationSizeConstraint(kernel.length)}\n                  dataRange={dataRange} kernelRange={getDataRange(kernel)} colorScale={colorScale}\n                  isInputLayer={isInputInputLayer}/>\n  <Dataview data={testOutputMatrixSlice} highlights={outputHighlights} isKernelMath={true} \n      constraint={getVisualizationSizeConstraint(kernel.length)} dataRange={dataRange}/>\n</div>\n<div class=\"column has-text-centered\">\n  <div class=\"header-text\">\n    Output ({output.length}, {output[0].length})\n  </div>\n  <Dataview on:message={handleMouseover} data={testOutput} highlights={outputHighlights} isKernelMath={false}\n      outputLength={output.length} constraint={getVisualizationSizeConstraint(output.length)} dataRange={dataRange} stride={stride}/>\n</div>","<script>\n\timport ConvolutionAnimator from './ConvolutionAnimator.svelte';\n  import { singleConv } from '../utils/cnn.js';\n  import { createEventDispatcher } from 'svelte';\n\n  export let input;\n  export let kernel;\n  export let dataRange;\n  export let colorScale = d3.interpolateRdBu;\n  export let isInputInputLayer = false;\n  export let isExited = false;\n  // export let output;\n  \n  const dispatch = createEventDispatcher();\n\tlet stride = 1;\n  const dilation = 1;\n  var isPaused = false;\n  var outputFinal = singleConv(input, kernel, stride);\n  $: if (stride > 0) {\n    try { \n      outputFinal = singleConv(input, kernel, stride);\n    } catch {\n      console.log(\"Cannot handle stride of \" + stride);\n    }\n  }\n  \n  function handleClickPause() {\n    isPaused = !isPaused;\n  }\n\n  function handleScroll() {\n    let svgHeight = Number(d3.select('#cnn-svg').style('height').replace('px', '')) + 150;\n    let scroll = new SmoothScroll('a[href*=\"#\"]', {offset: -svgHeight});\n    let anchor = document.querySelector(`#article-convolution`);\n    scroll.animateScroll(anchor);\n  }\n\n  function handlePauseFromInteraction(event) {\n    isPaused = event.detail.text;\n  }\n\n  function handleClickX() {\n    isExited = true;\n    dispatch('message', {\n      text: isExited\n    });\n  }\n</script>\n\n<style>\n  .control-pannel {\n    display: flex;\n    position: relative;\n    flex-direction: column;\n    align-items: center;\n  }\n\n  .buttons {\n    cursor: pointer;\n    position: absolute;\n    top: 0px;\n    right: 0px;\n  }\n\n  .control-button {\n    color: gray;\n    font-size: 15px;\n    opacity: 0.4;\n    cursor: pointer;\n  }\n\n  .control-button:not(:first-child) {\n    margin-left: 5px;\n  }\n\n  .annotation {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding-left : 10px;\n    font-size: 12px;\n  }\n\n  .annotation > img {\n    width: 17px;\n    margin-right: 5px;\n  }\n\n  .control-button:hover {\n    opacity: 0.8;\n  }\n\n  .box {\n    padding: 5px 15px 10px 15px;\n  }\n\n  .container {\n    display: flex;\n    justify-content: space-between;\n    align-items: flex-end;\n  }\n\n  .title-text {\n    font-size: 1.2em;\n    font-weight: 500;\n    color: #4a4a4a;\n  }\n</style>\n\n{#if !isExited}\n  <div class=\"container\" id=\"detailview-container\">\n\n    <!-- old stride input -->\n    <!-- <div class=\"columns is-mobile\">\n      <div class=\"column is-half is-offset-one-quarter\">\n        <div class=\"field is-grouped\">\n          <p class=\"control is-expanded\">\n            <input class=\"input\" type=\"text\" placeholder=\"Stride\" bind:value={stride} />\n          </p>\n          <p class=\"control\">\n            <button class=\"button is-success\" on:click={handleClickPause}>\n              Toggle Movement\n            </button>\n          </p>\n        </div>\n      </div>\n    </div> -->\n\n    <div class=\"box\">\n\n      <div class=\"control-pannel\">\n\n        <div class=\"title-text\">\n          Convolution\n        </div>\n\n        <div class=\"buttons\">\n          <div class=\"control-button\" on:click={handleScroll} title=\"Jump to article section\">\n            <i class=\"fas fa-info-circle\"></i>\n          </div>\n\n          <div class=\"play-button control-button\" on:click={handleClickPause} title=\"Play animation\">\n            {@html isPaused ?\n              '<i class=\"fas fa-play-circle play-icon\"></i>' :\n              '<i class=\"fas fa-pause-circle\"></i>'}\n          </div>\n\n          <div class=\"delete-button control-button\" on:click={handleClickX} title=\"Close\">\n            <i class=\"fas control-icon fa-times-circle\"></i>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"container is-centered\">\n        <ConvolutionAnimator on:message={handlePauseFromInteraction} \n          kernel={kernel} image={input} output={outputFinal} \n          stride={stride} dilation={dilation} isPaused={isPaused}\n          dataRange={dataRange} colorScale={colorScale}\n          isInputInputLayer={isInputInputLayer} />\n      </div>\n\n      <div class=\"annotation\">\n        <img src='PUBLIC_URL/assets/img/pointer.svg' alt='pointer icon'>\n        <div class=\"annotation-text\">\n          <span style=\"font-weight:600\">Hover over</span> the matrices to change kernel position.\n        </div>\n      </div>\n\n    </div>\n  </div>\n{/if}","<script>\n  import { createEventDispatcher } from 'svelte';\n  import { array1d, getMatrixSliceFromOutputHighlights,\n    getVisualizationSizeConstraint, getMatrixSliceFromInputHighlights, gridData\n  } from './DetailviewUtils.js';\n  import Dataview from './Dataview.svelte';\n\n  export let image;\n  export let output;\n  export let isPaused;\n  export let dataRange;\n\n  const dispatch = createEventDispatcher();\n  const padding = 0;\n  let padded_input_size = image.length + padding * 2;\n  $: padded_input_size = image.length + padding * 2;\n\n  let gridInputMatrixSlice = gridData([[0]]);\n  let gridOutputMatrixSlice = gridData([[0]]);\n  let inputHighlights = array1d(image.length * image.length, (i) => true);\n  let outputHighlights = array1d(output.length * output.length, (i) => true);\n  let interval;\n  $ : {\n    let inputHighlights = array1d(image.length * image.length, (i) => true);\n    let outputHighlights = array1d(output.length * output.length, (i) => true);\n    let interval;\n  }\n\n  let counter;\n\n  // lots of replication between mouseover and start-relu. TODO: fix this.\n  function startRelu() {\n    counter = 0;\n    if (interval) clearInterval(interval);\n    interval = setInterval(() => {\n      if (isPaused) return;\n      const flat_animated = counter % (output.length * output.length);\n      outputHighlights = array1d(output.length * output.length, (i) => false);\n      inputHighlights = array1d(image.length * image.length, (i) => undefined);\n      const animatedH = Math.floor(flat_animated / output.length);\n      const animatedW = flat_animated % output.length;\n      outputHighlights[animatedH * output.length + animatedW] = true;\n      inputHighlights[animatedH * output.length + animatedW] = true;\n      const inputMatrixSlice = getMatrixSliceFromInputHighlights(image, inputHighlights, 1);\n      gridInputMatrixSlice = gridData(inputMatrixSlice);\n      const outputMatrixSlice = getMatrixSliceFromOutputHighlights(output, outputHighlights);\n      gridOutputMatrixSlice = gridData(outputMatrixSlice);\n      counter++;\n    }, 250)\n  }\n\n  function handleMouseover(event) {\n    outputHighlights = array1d(output.length * output.length, (i) => false);\n    const animatedH = event.detail.hoverH;\n    const animatedW = event.detail.hoverW;\n    outputHighlights[animatedH * output.length + animatedW] = true;\n    inputHighlights = array1d(image.length * image.length, (i) => undefined);\n    inputHighlights[animatedH * output.length + animatedW] = true;\n    const inputMatrixSlice = getMatrixSliceFromInputHighlights(image, inputHighlights, 1);\n    gridInputMatrixSlice = gridData(inputMatrixSlice);\n    const outputMatrixSlice = getMatrixSliceFromOutputHighlights(output, outputHighlights);\n    gridOutputMatrixSlice = gridData(outputMatrixSlice);\n    isPaused = true;\n    dispatch('message', {\n      text: isPaused\n    });\n  }\n\n  startRelu();\n  let gridImage = gridData(image)\n  let gridOutput = gridData(output)\n  $ : {\n    startRelu();\n    gridImage = gridData(image)\n    gridOutput = gridData(output)\n  }\n</script>\n\n<style>\n  .column {\n    padding: 5px;\n  }\n</style>\n\n<div class=\"column has-text-centered\">\n  <div class=\"header-text\">\n    Input ({image.length}, {image[0].length})\n  </div>\n  <Dataview on:message={handleMouseover} data={gridImage} highlights={inputHighlights} outputLength={output.length}\n      isKernelMath={false} constraint={getVisualizationSizeConstraint(image.length)} dataRange={dataRange} stride={1}/>  \n</div>\n<div class=\"column has-text-centered\">\n  <span>\n    max(\n    <Dataview data={gridData([[0]])} highlights={outputHighlights} isKernelMath={true} \n    constraint={20} dataRange={dataRange}/>\n    ,\n    <Dataview data={gridInputMatrixSlice} highlights={outputHighlights} isKernelMath={true} \n    constraint={20} dataRange={dataRange}/>\n    )\n    =\n    <Dataview data={gridOutputMatrixSlice} highlights={outputHighlights} isKernelMath={true} \n      constraint={20} dataRange={dataRange}/>\n  </span> \n</div>\n<div class=\"column has-text-centered\">\n  <div class=\"header-text\">\n    Output ({output.length}, {output[0].length})\n  </div>\n  <Dataview on:message={handleMouseover} data={gridOutput} highlights={outputHighlights} isKernelMath={false} \n      outputLength={output.length} constraint={getVisualizationSizeConstraint(output.length)} dataRange={dataRange} stride={1}/>\n</div>","<script>\n\timport ActivationAnimator from './ActivationAnimator.svelte';\n  import { createEventDispatcher } from 'svelte';\n\n  export let input;\n  export let output;\n  export let dataRange;\n  export let isExited;\n\n  const dispatch = createEventDispatcher();\n  let isPaused = false;\n  \n  function handleClickPause() {\n    isPaused = !isPaused;\n  }\n\n  function handlePauseFromInteraction(event) {\n    isPaused = event.detail.text;\n  }\n\n  function handleClickX() {\n    dispatch('message', {\n      text: true\n    });\n  }\n\n  function handleScroll() {\n    let svgHeight = Number(d3.select('#cnn-svg').style('height').replace('px', '')) + 150;\n    let scroll = new SmoothScroll('a[href*=\"#\"]', {offset: -svgHeight});\n    let anchor = document.querySelector(`#article-relu`);\n    scroll.animateScroll(anchor);\n  }\n</script>\n\n<style>\n  .control-pannel {\n    display: flex;\n    position: relative;\n    flex-direction: column;\n    align-items: center;\n  }\n\n  .buttons {\n    cursor: pointer;\n    position: absolute;\n    top: 0px;\n    right: 0px;\n  }\n\n  .control-button {\n    color: gray;\n    font-size: 15px;\n    opacity: 0.4;\n    cursor: pointer;\n  }\n\n  .control-button:not(:first-child) {\n    margin-left: 5px;\n  }\n\n  .annotation {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding-left : 10px;\n    font-size: 12px;\n  }\n\n  .annotation > img {\n    width: 17px;\n    margin-right: 5px;\n  }\n\n  .control-button:hover {\n    opacity: 0.8;\n  }\n\n  .box {\n    padding: 5px 15px 10px 15px;\n  }\n\n  .container {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n  }\n\n  .title-text {\n    font-size: 1.2em;\n    font-weight: 500;\n    color: #4a4a4a;\n  }\n</style>\n\n{#if !isExited}\n  <div class=\"container\">\n    <div class=\"box\">\n\n      <div class=\"control-pannel\">\n\n        <div class=\"title-text\">\n          ReLU Activation\n        </div>\n\n        <div class=\"buttons\">\n\n          <div class=\"control-button\" on:click={handleScroll} title=\"Jump to article section\">\n            <i class=\"fas fa-info-circle\"></i>\n          </div>\n\n          <div class=\"play-button control-button\" on:click={handleClickPause} title=\"Play animation\">\n            {@html isPaused ?\n              '<i class=\"fas fa-play-circle play-icon\"></i>' :\n              '<i class=\"fas fa-pause-circle\"></i>'}\n          </div>\n\n          <div class=\"delete-button control-button\" on:click={handleClickX} title=\"Close\">\n              <i class=\"fas control-icon fa-times-circle\"></i>\n          </div>\n        </div>\n\n      </div>\n\n      <div class=\"container is-centered is-vcentered\">\n        <ActivationAnimator on:message={handlePauseFromInteraction} \n          image={input} output={output} isPaused={isPaused}\n          dataRange={dataRange}/>\n      </div>\n\n      <div class=\"annotation\">\n        <img src='PUBLIC_URL/assets/img/pointer.svg' alt='pointer icon'>\n        <div class=\"annotation-text\">\n          <span style=\"font-weight:600\">Hover over</span> the matrices to change pixel.\n        </div>\n      </div>\n\n    </div>\n  </div>\n{/if}","<script>\n  import { createEventDispatcher } from 'svelte';\n  import { array1d, getMatrixSliceFromOutputHighlights,\n    compute_input_multiplies_with_weight, getVisualizationSizeConstraint,\n    generateOutputMappings, getMatrixSliceFromInputHighlights, gridData\n  } from './DetailviewUtils.js';\n  import Dataview from './Dataview.svelte';\n\n  export let stride;\n  export let dilation\n  export let kernelLength;\n  export let image;\n  export let output;\n  export let isPaused;\n  export let dataRange;\n\n  const dispatch = createEventDispatcher();\n  const padding = 0;\n  let padded_input_size = image.length + padding * 2;\n  $: padded_input_size = image.length + padding * 2;\n\n  // Dummy data for original state of component.\n  let testInputMatrixSlice = [];\n  for (let i = 0; i < kernelLength; i++) {\n    testInputMatrixSlice.push([]);\n    for (let j = 0; j < kernelLength; j++) {\n      testInputMatrixSlice[i].push(0)\n    }\n  }\n  testInputMatrixSlice = gridData(testInputMatrixSlice)\n  let testOutputMatrixSlice = gridData([[0]]);\n\n  let inputHighlights = [];\n  let outputHighlights = array1d(output.length * output.length, (i) => true);\n  let interval;\n  $ : {\n    let inputHighlights = [];\n    let outputHighlights = array1d(output.length * output.length, (i) => true);\n    let interval;\n  }\n  \n  let counter;\n\n  // lots of replication between mouseover and start-pool. TODO: fix this.\n  function startMaxPool(stride) {\n    counter = 0;\n    let outputMappings = generateOutputMappings(stride, output, kernelLength, padded_input_size, dilation);\n    if (stride <= 0) return;\n    if (interval) clearInterval(interval);\n    interval = setInterval(() => {\n      if (isPaused) return;\n      const flat_animated = counter % (output.length * output.length);\n      outputHighlights = array1d(output.length * output.length, (i) => false);\n      const animatedH = Math.floor(flat_animated / output.length);\n      const animatedW = flat_animated % output.length;\n      outputHighlights[animatedH * output.length + animatedW] = true;\n      inputHighlights = compute_input_multiplies_with_weight(animatedH, animatedW, padded_input_size, kernelLength, outputMappings, kernelLength)\n      const inputMatrixSlice = getMatrixSliceFromInputHighlights(image, inputHighlights, kernelLength);\n      testInputMatrixSlice = gridData(inputMatrixSlice);\n      const outputMatrixSlice = getMatrixSliceFromOutputHighlights(output, outputHighlights);\n      testOutputMatrixSlice = gridData(outputMatrixSlice);\n      counter++;\n    }, 250)\n  }\n\n  function handleMouseover(event) {\n    let outputMappings = generateOutputMappings(stride, output, kernelLength, padded_input_size, dilation);\n    outputHighlights = array1d(output.length * output.length, (i) => false);\n    const animatedH = event.detail.hoverH;\n    const animatedW = event.detail.hoverW;\n    outputHighlights[animatedH * output.length + animatedW] = true;\n    inputHighlights = compute_input_multiplies_with_weight(animatedH, animatedW, padded_input_size, kernelLength, outputMappings, kernelLength)\n    const inputMatrixSlice = getMatrixSliceFromInputHighlights(image, inputHighlights, kernelLength);\n    testInputMatrixSlice = gridData(inputMatrixSlice);\n    const outputMatrixSlice = getMatrixSliceFromOutputHighlights(output, outputHighlights);\n    testOutputMatrixSlice = gridData(outputMatrixSlice);\n    isPaused = true;\n    dispatch('message', {\n      text: isPaused\n    });\n  }\n\n  startMaxPool(stride);\n  let testImage = gridData(image)\n  let testOutput = gridData(output)\n  $ : {\n    startMaxPool(stride);\n    testImage = gridData(image)\n    testOutput = gridData(output)\n  }\n</script>\n\n<style>\n  .column {\n    padding: 5px;\n  }\n</style>\n\n<div class=\"column has-text-centered\">\n  <div class=\"header-text\">\n    Input ({testImage.length}, {testImage[0].length})\n  </div>\n\n  <Dataview on:message={handleMouseover} data={testImage} highlights={inputHighlights} outputLength={output.length}\n      isKernelMath={false} constraint={getVisualizationSizeConstraint(image.length)} dataRange={dataRange} stride={stride}/>  \n</div>\n<div class=\"column has-text-centered\">\n  <span>\n    max(\n    <Dataview data={testInputMatrixSlice} highlights={outputHighlights} isKernelMath={true} \n      constraint={getVisualizationSizeConstraint(kernelLength)} dataRange={dataRange}/>\n    )\n    =\n    <Dataview data={testOutputMatrixSlice} highlights={outputHighlights} isKernelMath={true} \n      constraint={getVisualizationSizeConstraint(kernelLength)} dataRange={dataRange}/>\n  </span> \n</div>\n<div class=\"column has-text-centered\">\n  <div class=\"header-text\">\n    Output ({testOutput.length}, {testOutput[0].length})\n  </div>\n  <Dataview on:message={handleMouseover} data={testOutput} highlights={outputHighlights} isKernelMath={false} \n      outputLength={output.length} constraint={getVisualizationSizeConstraint(output.length)} dataRange={dataRange} stride={stride}/>\n</div>","<script>\n\timport PoolAnimator from './PoolAnimator.svelte';\n  import { singleMaxPooling } from '../utils/cnn.js';\n  import { createEventDispatcher } from 'svelte';\n\n  export let input;\n  export let kernelLength;\n  export let dataRange;\n  export let isExited;\n  \n  const dispatch = createEventDispatcher();\n  // let isExited = false;\n\tlet stride = 2;\n  const dilation = 1;\n  var isPaused = false;\n  var outputFinal = singleMaxPooling(input);\n  // let dragging = false;\n  // let dragInfo = {x1: 0, x2: 0, y1: 0, y2: 0};\n  // let detailView = d3.select('#detailview').node();\n  $: if (stride > 0) {\n    try { \n      outputFinal = singleMaxPooling(input);\n    } catch {\n      console.log(\"Cannot handle stride of \" + stride);\n    }\n  }\n  \n  function handleClickPause() {\n    isPaused = !isPaused;\n    console.log(isPaused)\n  }\n\n  function handlePauseFromInteraction(event) {\n    isPaused = event.detail.text;\n  }\n\n  function handleClickX() {\n    dispatch('message', {\n      text: true\n    });\n  }\n\n  function handleScroll() {\n    let svgHeight = Number(d3.select('#cnn-svg').style('height').replace('px', '')) + 150;\n    let scroll = new SmoothScroll('a[href*=\"#\"]', {offset: -svgHeight});\n    let anchor = document.querySelector(`#article-pooling`);\n    scroll.animateScroll(anchor);\n  }\n\n  // Test dragging detail view, need more work\n  // const detailViewDragStart = (e) => {\n  //   // Record the starting pos\n  //   dragInfo.x1 = 0;\n  //   dragInfo.y1 = 0;\n  //   dragInfo.x2 = e.clientX;\n  //   dragInfo.y2 = e.clientY;\n  \n  //   dragging = true;\n  // }\n\n  // const detailViewDragEnd = (e) => {\n  //   dragging = false;\n  // }\n\n  // const detailViewDragMove = (e) => {\n  //   // Add up move to the starting pos\n  //   dragInfo.x1 = dragInfo.x2 - e.clientX;\n  //   dragInfo.y1 = dragInfo.y2 - e.clientY;\n  //   dragInfo.x2 = e.clientX;\n  //   dragInfo.y2 = e.clientY;\n\n  //   // Move detail view\n  //   detailView.style.top = (detailView.offsetTop - dragInfo.y1) + 'px';\n  //   detailView.style.left = (detailView.offsetLeft - dragInfo.x1) + 'px';\n  // }\n</script>\n\n<style>\n  .control-pannel {\n    display: flex;\n    position: relative;\n    flex-direction: column;\n    align-items: center;\n  }\n\n  .buttons {\n    cursor: pointer;\n    position: absolute;\n    top: 0px;\n    right: 0px;\n  }\n\n  .control-button {\n    color: gray;\n    font-size: 15px;\n    opacity: 0.4;\n    cursor: pointer;\n  }\n\n  .control-button:not(:first-child) {\n    margin-left: 5px;\n  }\n\n  .annotation {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding-left : 10px;\n    font-size: 12px;\n  }\n\n  .annotation > img {\n    width: 17px;\n    margin-right: 5px;\n  }\n\n\n  .control-button:hover {\n    opacity: 0.8;\n  }\n\n  .box {\n    padding: 5px 15px 10px 15px;\n  }\n\n  .container {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n  }\n\n  .title-text {\n    font-size: 1.2em;\n    font-weight: 500;\n    color: #4a4a4a;\n  }\n</style>\n\n{#if !isExited}\n  <div class=\"container\">\n\n    <!-- old stride input -->\n    <!-- <div class=\"columns is-mobile\">\n      <div class=\"column is-half is-offset-one-quarter\">\n        <div class=\"field is-grouped\">\n          <p class=\"control is-expanded\">\n            <input class=\"input\" type=\"text\" placeholder=\"Stride\" bind:value={stride} />\n          </p>\n          <p class=\"control\">\n            <button class=\"button is-success\" on:click={handleClickPause}>\n              Toggle Movement\n            </button>\n          </p>\n        </div>\n      </div>\n    </div> -->\n    <div class=\"box\">\n\n      <div class=\"control-pannel\">\n      \n        <div class=\"title-text\">\n          Max Pooling\n        </div>\n\n        <div class=\"buttons\">\n\n          <div class=\"control-button\" on:click={handleScroll} title=\"Jump to article section\">\n            <i class=\"fas fa-info-circle\"></i>\n          </div>\n\n          <div class=\"play-button control-button\" on:click={handleClickPause} title=\"Play animation\">\n            {@html isPaused ?\n              '<i class=\"fas fa-play-circle play-icon\"></i>' :\n              '<i class=\"fas fa-pause-circle\"></i>'}\n          </div>\n\n          <div class=\"delete-button control-button\" on:click={handleClickX} title=\"Close\">\n            <i class=\"fas control-icon fa-times-circle\"></i>\n          </div>\n        </div>\n\n      </div>\n\n      <div class=\"container is-centered is-vcentered\">\n        <PoolAnimator on:message={handlePauseFromInteraction} \n          kernelLength={kernelLength} image={input} output={outputFinal} \n          stride={stride} dilation={dilation} isPaused={isPaused}\n          dataRange={dataRange} />\n      </div>\n\n      <div class=\"annotation\">\n        <img src='PUBLIC_URL/assets/img/pointer.svg' alt='pointer icon'>\n          <div class=\"annotation-text\">\n            <span style=\"font-weight:600\">Hover over</span> the matrices to change kernel position.\n          </div>\n      </div>\n\n    </div>\n  </div>\n{/if}","<script>\n  import { onMount, afterUpdate, createEventDispatcher } from 'svelte';\n  export let logits;\n  export let logitColors;\n  export let selectedI;\n  export let highlightI = -1;\n  export let outputName;\n  export let outputValue;\n  export let startAnimation;\n\n  let softmaxViewComponent;\n  let svg = null;\n  const dispatch = createEventDispatcher();\n  const formater = (n, d) => {\n    if (d === undefined) {\n      return d3.format('.2f')(n);\n    } else {\n      return d3.format(`.${d}f`)(n);\n    }\n  }\n\n  $: highlightI, (() => {\n    if (svg !== null) {\n      svg.selectAll(`.formula-term`)\n        .style('text-decoration', 'none')\n        .style('font-weight', 'normal');\n\n      svg.selectAll(`.formula-term-${highlightI}`)\n      .style('font-weight', 'bold')\n      .style('text-decoration', 'underline');\n    }\n  })();\n\n  $: startAnimation, (() => {\n    if (svg !== null) {\n      svg.select(`.formula-term-${startAnimation.i}`)\n        .transition('softmax-edge')\n        .duration(startAnimation.duration)\n        .style('fill-opacity', 1);\n    }\n  })();\n\n  const mouseOverHandler = (d, i, g, curI) => {\n    highlightI = curI;\n    dispatch('mouseOver', {curI: curI});\n  }\n\n  const mouseLeaveHandler = (d, i, g, curI) => {\n    highlightI = -1;\n    dispatch('mouseLeave', {curI: curI});\n  }\n\n  const handleClickX = () => {\n    dispatch('xClicked', {});\n  }\n\n  function handleScroll() {\n    let svgHeight = Number(d3.select('#cnn-svg').style('height').replace('px', '')) + 150;\n    let scroll = new SmoothScroll('a[href*=\"#\"]', {offset: -svgHeight});\n    let anchor = document.querySelector(`#article-softmax`);\n    scroll.animateScroll(anchor);\n  }\n\n  onMount(() => {\n    svg = d3.select(softmaxViewComponent)\n      .select('#softmax-svg');\n\n    let formulaRightGroup = svg.append('g')\n      .attr('class', 'formula-right')\n      .attr('transform', `translate(${10}, ${0})`)\n      .style('font-size', '15px');\n\n    // Denominator\n    let denominatorGroup = formulaRightGroup.append('g')\n      .attr('class', 'denominator')\n      .attr('transform', `translate(${0}, ${58})`);\n      \n    // Add the left (\n    denominatorGroup.append('text')\n      .attr('x', 0)\n      .attr('y', 0)\n      .style('fill', 'gray')\n      .text('(');\n\n    // Need to loop through the logits array instead of data-binding because\n    // we want dynamic positioning based on prior '-' occurance\n    let curX = 8;\n    let numOfRows = 4;\n\n    logits.forEach((d, i) => {\n      if (i / numOfRows >= 1 && i % numOfRows === 0) {\n          curX = 8;\n      }\n\n      let curText = denominatorGroup.append('text')\n        .attr('x', curX)\n        .attr('y', Math.floor(i / numOfRows) * 20)\n        .style('cursor', 'crosshair')\n        .style('pointer-events', 'all')\n        .on('mouseover', (d, n, g) => mouseOverHandler(d, n, g, i))\n        .on('mouseleave', (d, n, g) => mouseLeaveHandler(d, n, g, i))\n        .text(`exp(`);\n      \n      curText.append('tspan')\n        .attr('class', `formula-term-${i} formula-term`)\n        .attr('dx', '1')\n        .style('fill', logitColors[i])\n        .style('fill-opacity', (i === selectedI) || startAnimation.hasInitialized ? 1 : 0)\n        .text(formater(d));\n      \n      curText.append('tspan')\n        .attr('dx', '1')\n        .text(')');\n      \n      let curBBox = curText.node().getBBox();\n      curX += curBBox.width + 4;\n\n      if (i !== logits.length - 1) {\n        denominatorGroup.append('text')\n          .attr('x', curX)\n          .attr('y', Math.floor(i / numOfRows) * 20)\n          .text('+');\n        curX += 14;\n      } else {\n        denominatorGroup.append('text')\n          .attr('x', curX-2)\n          .attr('y', Math.floor(i / numOfRows) * 20)\n          .style('fill', 'gray')\n          .text(')');\n      }\n    })\n\n    denominatorGroup.selectAll('text')\n      .data(logits)\n      .enter()\n      .append('text')\n      .attr('x', (d, i) => 40 * i)\n      .attr('y', 0)\n      .text(d => formater(d));\n    \n    // Calculate the dynamic denominator group width\n    let denominatorGroupBBox = denominatorGroup.node().getBBox();\n\n    // Draw the fraction line\n    formulaRightGroup.append('line')\n      .attr('class', 'separation-line')\n      .attr('x1', -5)\n      .attr('x2', denominatorGroupBBox.width + 5)\n      .attr('y1', 32)\n      .attr('y2', 32)\n      .style('stroke-width', 1.2)\n      .style('stroke', 'gray');\n    \n    // Draw the numerator\n    let numeratorGroup = formulaRightGroup.append('g')\n      .attr('class', 'numerator-group')\n      .attr('transform', `translate(${0}, ${20})`);\n    \n    let numeratorText = numeratorGroup.append('text')\n      .attr('x', denominatorGroupBBox.x + denominatorGroupBBox.width / 2)\n      .attr('y', 0)\n      .on('mouseover', (d, n, g) => mouseOverHandler(d, n, g, selectedI))\n      .on('mouseleave', (d, n, g) => mouseLeaveHandler(d, n, g, selectedI))\n      .style('pointer-events', 'all')\n      .style('cursor', 'crosshair')\n      .style('text-anchor', 'middle')\n      .text('exp(');\n\n    numeratorText.append('tspan')\n      .attr('class', `formula-term-${selectedI} formula-term`)\n      .attr('dx', 1)\n      .style('fill', logitColors[selectedI])\n      .text(`${formater(logits[selectedI])}`);\n\n    numeratorText.append('tspan')\n       .attr('dx', 1)\n      .text(')');\n    \n    // Draw the left part of the formula\n    let formulaLeftGroup = svg.append('g')\n      .attr('class', 'formula-left')\n      .attr('transform', `translate(${395}, ${32})`);\n    \n    let softmaxText = formulaLeftGroup.append('text')\n      .attr('x', 20)\n      .attr('dominant-baseline', 'middle')\n      .text(`${formater(outputValue, 4)}`);\n    \n    let softmaxTextBBox = softmaxText.node().getBBox();\n    \n    formulaLeftGroup.append('text')\n      .attr('dominant-baseline', 'middle')\n      .attr('x', 0)\n      .attr('y', 0)\n      .style('fill', 'gray')\n      .style('font-weight', 'bold')\n      .text('=');\n\n  })\n\n</script>\n\n<style>\n  .buttons {\n    cursor: pointer;\n    position: absolute;\n    top: 6px;\n    right: 10px;\n  }\n\n  .control-button {\n    color: gray;\n    font-size: 15px;\n    opacity: 0.4;\n  }\n\n  .control-button:hover {\n    opacity: 0.8;\n  }\n\n  .control-button:not(:first-child) {\n    margin-left: 5px;\n  }\n\n  .title-text {\n    font-size: 1.2em;\n    font-weight: 500;\n    color: #4a4a4a;\n  }\n\n  .annotation {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding-left : 10px;\n    font-size: 12px;\n  }\n\n  .annotation > img {\n    width: 17px;\n    margin-right: 5px;\n  }\n\n  .box {\n    padding: 5px 10px 15px 10px;\n    position: relative;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n  }\n\n  svg {\n    margin: 10px 0 12px 0;\n  }\n</style>\n\n<div class=\"container\" bind:this={softmaxViewComponent}>\n  <div class=\"box\">\n\n    <div class=\"buttons\">\n      <div class=\"control-button\" on:click={handleScroll} title=\"Jump to article section\">\n        <i class=\"fas fa-info-circle\"></i>\n      </div>\n\n      <div class=\"delete-button control-button\" on:click={handleClickX} title=\"Close\">\n        <i class=\"fas control-icon fa-times-circle\"></i>\n      </div>\n    </div>\n\n    <div class=\"title-text\">\n      Softmax Score for <i>\"{outputName}\"</i>\n    </div>\n\n    <svg id=\"softmax-svg\" width=\"470\" height=\"105\"/>\n\n    <div class=\"annotation\">\n      <img src='PUBLIC_URL/assets/img/pointer.svg' alt='pointer icon'>\n      <div class=\"annotation-text\">\n        <span style=\"font-weight:600\">Hover over</span> the numbers to highlight logit circles.\n      </div>\n    </div>\n\n  </div>\n</div>\n\n","<script>\n  /* global d3 */\n\n  import { onMount, createEventDispatcher } from 'svelte';\n  import { modalStore } from '../stores.js';\n\n  let modalComponent;\n  let valiImg;\n  let inputValue = '';\n  let showLoading = false;\n  let files;\n  let usingURL = true;\n  let errorInfo = {\n    show: false,\n    error: ''\n  };\n  const dispatch = createEventDispatcher();\n\n  let modalInfo = {\n    show: false\n  };\n  modalStore.set(modalInfo);\n  modalStore.subscribe(value => {modalInfo = value});\n\n  const errorCallback = () => {\n    // The URL is invalid, show an error message on the UI\n    showLoading = false;\n    errorInfo.show = true;\n    errorInfo.error = usingURL ? \"We can't find the image at that URL.\" :\n      \"Not a valid image file.\";\n  }\n\n  const loadCallback = () => {\n    // The URL is valid, but we are not sure if loading it to canvas would be\n    // blocked by crossOrigin setting. Try it here before dispatch to parent.\n\n    // https://stackoverflow.com/questions/13674835/canvas-tainted-by-cross-origin-data\n    let canvas = document.createElement(\"canvas\");\n    let context = canvas.getContext(\"2d\");\n\n    canvas.width = valiImg.width;\n    canvas.height = valiImg.height;\n    context.drawImage(valiImg, 0, 0);\n\n    try {\n      context.getImageData(0, 0, valiImg.width, valiImg.height);\n      // If the foreign image does support CORS -> use this image\n      // dispatch to parent component to use the input image\n      showLoading = false;\n      modalInfo.show = false;\n      modalStore.set(modalInfo);\n      dispatch('urlTyped', {url: valiImg.src});\n      inputValue = null;\n    } catch(err) {\n      // If the foreign image does not support CORS -> use this image\n      showLoading = false;\n      errorInfo.show = true;\n      errorInfo.error = \"No permission to load this image.\"\n    }\n  }\n\n  const imageUpload = () => {\n    usingURL = false;\n    let reader = new FileReader();\n    reader.onload = (event) => {\n      valiImg.src = event.target.result;\n    }\n    reader.readAsDataURL(files[0]);\n  }\n\n  const crossClicked = () => {\n    modalInfo.show = false;\n    modalStore.set(modalInfo);\n    // Dispatch the parent component\n    dispatch('xClicked', {preImage: modalInfo.preImage});\n  }\n\n  const addClicked = () => {\n    // Validate the input URL\n    showLoading = true;\n    errorInfo.show = false;\n    valiImg.crossOrigin = \"Anonymous\";\n    valiImg.src = inputValue;\n  }\n\n  onMount(() => {\n    let modal = d3.select(modalComponent)\n      .select('#input-modal');\n  })\n\n</script>\n\n<style>\n  .modal-card {\n    max-width: 500px;\n  }\n\n  .modal-card-title {\n    font-size: 20px;\n  }\n\n  .modal-card-head {\n    padding: 15px 20px;\n  }\n\n  .modal-card-foot {\n    padding: 12px 20px;\n    justify-content: space-between;\n  }\n\n  .is-smaller {\n    font-size: 15px;\n    padding: 0.5em 0.8em;\n    max-height: 2.2em;\n  }\n\n  .small-font {\n    font-size: 15px;\n  }\n\n  .error-message {\n    font-size: 15px;\n    padding: 0.5em 0;\n    color: #F22B61;\n  }\n\n  .control {\n    width: 100%;\n  }\n\n  .or-label {\n    font-size: 15px;\n    margin: 0 10px;\n    padding: 0.5em 0;\n  }\n\n  .field {\n    display: flex;\n    justify-content: space-between;\n  }\n\n</style>\n\n\n<div class=\"modal-component\"\n  bind:this={modalComponent}>\n\n  <div class=\"modal\"\n    id=\"input-modal\"\n    class:is-active={modalInfo.show}>\n\n    <div class=\"modal-background\" on:click={crossClicked}></div>\n\n    <div class=\"modal-card\">\n      <header class=\"modal-card-head\">\n        <p class=\"modal-card-title\">Add Input Image</p>\n        <button class=\"delete\" aria-label=\"close\" on:click={crossClicked}></button>\n      </header>\n\n      <section class=\"modal-card-body\">\n        <div class=\"field\">\n          <div class=\"control has-icons-left\"\n            class:is-loading={showLoading}>\n\n            <input class=\"input small-font\" type=\"url\"\n              bind:value={inputValue}\n              placeholder=\"Paste URL of image...\">\n\n            <span class=\"icon small-font is-left\">\n              <i class=\"fas fa-link\"></i>\n            </span>\n\n          </div>\n\n          <div class=\"or-label\">or</div>\n\n          <div class=\"file\">\n            <label class=\"file-label\">\n              <input class=\"file-input\" type=\"file\" name=\"image\"\n                accept=\".png,.jpeg,.tiff,.jpg,.png\"\n                bind:files={files}\n                on:change={imageUpload}>\n              <span class=\"file-cta small-font\">\n                <span class=\"file-icon\">\n                  <i class=\"fas fa-upload\"></i>\n                </span>\n                <span class=\"file-label\">\n                  Upload\n                </span>\n              </span>\n            </label>\n          </div>\n\n        </div>\n\n      </section>\n\n      <footer class=\"modal-card-foot\">\n\n        <div class=\"error-message\"\n          class:hidden={!errorInfo.show}>\n          {errorInfo.error}\n        </div>\n\n        <div class=\"button-container\">\n          <button class=\"button is-smaller\"\n            on:click={crossClicked}>\n            Cancel\n          </button>\n\n          <button class=\"button is-success is-smaller\"\n            on:click={addClicked}>\n            Add\n          </button>\n        </div>\n\n\n      </footer>\n    </div>\n\n  </div>\n\n  <!-- An invisible image to check if the user input URL is valid -->\n  <img style=\"display: none\"\n    id=\"vali-image\"\n    alt=\"hidden image\"\n    bind:this={valiImg}\n    on:error={errorCallback}\n    on:load={loadCallback} />\n\n</div>\n","/* global tf */\n\n// Network input image size\nconst networkInputSize = 64;\n\n// Enum of node types\nconst nodeType = {\n  INPUT: 'input',\n  CONV: 'conv',\n  POOL: 'pool',\n  RELU: 'relu',\n  FC: 'fc',\n  FLATTEN: 'flatten'\n}\n\nclass Node {\n  /**\n   * Class structure for each neuron node.\n   * \n   * @param {string} layerName Name of the node's layer.\n   * @param {int} index Index of this node in its layer.\n   * @param {string} type Node type {input, conv, pool, relu, fc}. \n   * @param {number} bias The bias assocated to this node.\n   * @param {number[]} output Output of this node.\n   */\n  constructor(layerName, index, type, bias, output) {\n    this.layerName = layerName;\n    this.index = index;\n    this.type = type;\n    this.bias = bias;\n    this.output = output;\n\n    // Weights are stored in the links\n    this.inputLinks = [];\n    this.outputLinks = [];\n  }\n}\n\nclass Link {\n  /**\n   * Class structure for each link between two nodes.\n   * \n   * @param {Node} source Source node.\n   * @param {Node} dest Target node.\n   * @param {number} weight Weight associated to this link. It can be a number,\n   *  1D array, or 2D array.\n   */\n  constructor(source, dest, weight) {\n    this.source = source;\n    this.dest = dest;\n    this.weight = weight;\n  }\n}\n\n/**\n * Construct a CNN with given extracted outputs from every layer.\n * \n * @param {number[][]} allOutputs Array of outputs for each layer.\n *  allOutputs[i][j] is the output for layer i node j.\n * @param {Model} model Loaded tf.js model.\n * @param {Tensor} inputImageTensor Loaded input image tensor.\n */\nconst constructCNNFromOutputs = (allOutputs, model, inputImageTensor) => {\n  let cnn = [];\n\n  // Add the first layer (input layer)\n  let inputLayer = [];\n  let inputShape = model.layers[0].batchInputShape.slice(1);\n  let inputImageArray = inputImageTensor.transpose([2, 0, 1]).arraySync();\n\n  // First layer's three nodes' outputs are the channels of inputImageArray\n  for (let i = 0; i < inputShape[2]; i++) {\n    let node = new Node('input', i, nodeType.INPUT, 0, inputImageArray[i]);\n    inputLayer.push(node);\n  }\n                                                                                                                   \n  cnn.push(inputLayer);\n  let curLayerIndex = 1;\n\n  for (let l = 0; l < model.layers.length; l++) {\n    let layer = model.layers[l];\n    // Get the current output\n    let outputs = allOutputs[l].squeeze();\n    outputs = outputs.arraySync();\n\n    let curLayerNodes = [];\n    let curLayerType;\n\n    // Identify layer type based on the layer name\n    if (layer.name.includes('conv')) {\n      curLayerType = nodeType.CONV;\n    } else if (layer.name.includes('pool')) {\n      curLayerType = nodeType.POOL;\n    } else if (layer.name.includes('relu')) {\n      curLayerType = nodeType.RELU;\n    } else if (layer.name.includes('output')) {\n      curLayerType = nodeType.FC;\n    } else if (layer.name.includes('flatten')) {\n      curLayerType = nodeType.FLATTEN;\n    } else {\n      console.log('Find unknown type');\n    }\n\n    // Construct this layer based on its layer type\n    switch (curLayerType) {\n      case nodeType.CONV: {\n        let biases = layer.bias.val.arraySync();\n        // The new order is [output_depth, input_depth, height, width]\n        let weights = layer.kernel.val.transpose([3, 2, 0, 1]).arraySync();\n\n        // Add nodes into this layer\n        for (let i = 0; i < outputs.length; i++) {\n          let node = new Node(layer.name, i, curLayerType, biases[i],\n            outputs[i]);\n\n          // Connect this node to all previous nodes (create links)\n          // CONV layers have weights in links. Links are one-to-multiple.\n          for (let j = 0; j < cnn[curLayerIndex - 1].length; j++) {\n            let preNode = cnn[curLayerIndex - 1][j];\n            let curLink = new Link(preNode, node, weights[i][j]);\n            preNode.outputLinks.push(curLink);\n            node.inputLinks.push(curLink);\n          }\n          curLayerNodes.push(node);\n        }\n        break;\n      }\n      case nodeType.FC: {\n        let biases = layer.bias.val.arraySync();\n        // The new order is [output_depth, input_depth]\n        let weights = layer.kernel.val.transpose([1, 0]).arraySync();\n\n        // Add nodes into this layer\n        for (let i = 0; i < outputs.length; i++) {\n          let node = new Node(layer.name, i, curLayerType, biases[i],\n            outputs[i]);\n\n          // Connect this node to all previous nodes (create links)\n          // FC layers have weights in links. Links are one-to-multiple.\n\n          // Since we are visualizing the logit values, we need to track\n          // the raw value before softmax\n          let curLogit = 0;\n          for (let j = 0; j < cnn[curLayerIndex - 1].length; j++) {\n            let preNode = cnn[curLayerIndex - 1][j];\n            let curLink = new Link(preNode, node, weights[i][j]);\n            preNode.outputLinks.push(curLink);\n            node.inputLinks.push(curLink);\n            curLogit += preNode.output * weights[i][j];\n          }\n          curLogit += biases[i];\n          node.logit = curLogit;\n          curLayerNodes.push(node);\n        }\n\n        // Sort flatten layer based on the node TF index\n        cnn[curLayerIndex - 1].sort((a, b) => a.realIndex - b.realIndex);\n        break;\n      }\n      case nodeType.RELU:\n      case nodeType.POOL: {\n        // RELU and POOL have no bias nor weight\n        let bias = 0;\n        let weight = null;\n\n        // Add nodes into this layer\n        for (let i = 0; i < outputs.length; i++) {\n          let node = new Node(layer.name, i, curLayerType, bias, outputs[i]);\n\n          // RELU and POOL layers have no weights. Links are one-to-one\n          let preNode = cnn[curLayerIndex - 1][i];\n          let link = new Link(preNode, node, weight);\n          preNode.outputLinks.push(link);\n          node.inputLinks.push(link);\n\n          curLayerNodes.push(node);\n        }\n        break;\n      }\n      case nodeType.FLATTEN: {\n        // Flatten layer has no bias nor weights.\n        let bias = 0;\n\n        for (let i = 0; i < outputs.length; i++) {\n          // Flatten layer has no weights. Links are multiple-to-one.\n          // Use dummy weights to store the corresponding entry in the previsou\n          // node as (row, column)\n          // The flatten() in tf2.keras has order: channel -> row -> column\n          let preNodeWidth = cnn[curLayerIndex - 1][0].output.length,\n            preNodeNum = cnn[curLayerIndex - 1].length,\n            preNodeIndex = i % preNodeNum,\n            preNodeRow = Math.floor(Math.floor(i / preNodeNum) / preNodeWidth),\n            preNodeCol = Math.floor(i / preNodeNum) % preNodeWidth,\n            // Use channel, row, colume to compute the real index with order\n            // row -> column -> channel\n            curNodeRealIndex = preNodeIndex * (preNodeWidth * preNodeWidth) +\n              preNodeRow * preNodeWidth + preNodeCol;\n          \n          let node = new Node(layer.name, i, curLayerType,\n              bias, outputs[i]);\n          \n          // TF uses the (i) index for computation, but the real order should\n          // be (curNodeRealIndex). We will sort the nodes using the real order\n          // after we compute the logits in the output layer.\n          node.realIndex = curNodeRealIndex;\n\n          let link = new Link(cnn[curLayerIndex - 1][preNodeIndex],\n              node, [preNodeRow, preNodeCol]);\n\n          cnn[curLayerIndex - 1][preNodeIndex].outputLinks.push(link);\n          node.inputLinks.push(link);\n\n          curLayerNodes.push(node);\n        }\n\n        // Sort flatten layer based on the node TF index\n        curLayerNodes.sort((a, b) => a.index - b.index);\n        break;\n      }\n      default:\n        console.error('Encounter unknown layer type');\n        break;\n    }\n\n    // Add current layer to the NN\n    cnn.push(curLayerNodes);\n    curLayerIndex++;\n  }\n\n  return cnn;\n}\n\n/**\n * Construct a CNN with given model and input.\n * \n * @param {string} inputImageFile filename of input image.\n * @param {Model} model Loaded tf.js model.\n */\nexport const constructCNN = async (inputImageFile, model) => {\n  // Load the image file\n  let inputImageTensor = await getInputImageArray(inputImageFile, true);\n\n  // Need to feed the model with a batch\n  let inputImageTensorBatch = tf.stack([inputImageTensor]);\n\n  // To get intermediate layer outputs, we will iterate through all layers in\n  // the model, and sequencially apply transformations.\n  let preTensor = inputImageTensorBatch;\n  let outputs = [];\n\n  // Iterate through all layers, and build one model with that layer as output\n  for (let l = 0; l < model.layers.length; l++) {\n    let curTensor = model.layers[l].apply(preTensor);\n\n    // Record the output tensor\n    // Because there is only one element in the batch, we use squeeze()\n    // We also want to use CHW order here\n    let output = curTensor.squeeze();\n    if (output.shape.length === 3) {\n      output = output.transpose([2, 0, 1]);\n    }\n    outputs.push(output);\n\n    // Update preTensor for next nesting iteration\n    preTensor = curTensor;\n  }\n\n  let cnn = constructCNNFromOutputs(outputs, model, inputImageTensor);\n  return cnn;\n}\n\n// Helper functions\n\n/**\n * Crop the largest central square of size 64x64x3 of a 3d array.\n * \n * @param {[int8]} arr array that requires cropping and padding (if a 64x64 crop\n * is not present)\n * @returns 64x64x3 array\n */\nconst cropCentralSquare = (arr) => {\n  let width = arr.length;\n  let height = arr[0].length;\n  let croppedArray;\n\n  // Crop largest square from image if the image is smaller than 64x64 and pad the\n  // cropped image.\n  if (width < networkInputSize || height < networkInputSize) {\n    // TODO(robert): Finish the padding logic.  Pushing now for Omar to work on when he is ready.\n    let cropDimensions = Math.min(width, height);\n    let startXIdx = Math.floor(width / 2) - (cropDimensions / 2);\n    let startYIdx = Math.floor(height / 2) - (cropDimensions / 2);\n    let unpaddedSubarray = arr.slice(startXIdx, startXIdx + cropDimensions).map(i => i.slice(startYIdx, startYIdx + cropDimensions));\n  } else {\n    let startXIdx = Math.floor(width / 2) - Math.floor(networkInputSize / 2);\n    let startYIdx = Math.floor(height / 2) - Math.floor(networkInputSize / 2);\n    croppedArray = arr.slice(startXIdx, startXIdx + networkInputSize).map(i => i.slice(startYIdx, startYIdx + networkInputSize));\n  }\n  return croppedArray;\n}\n\n/**\n * Convert canvas image data into a 3D tensor with dimension [height, width, 3].\n * Recall that tensorflow uses NHWC order (batch, height, width, channel).\n * Each pixel is in 0-255 scale.\n * \n * @param {[int8]} imageData Canvas image data\n * @param {int} width Canvas image width\n * @param {int} height Canvas image height\n */\nconst imageDataTo3DTensor = (imageData, width, height, normalize=true) => {\n  // Create array placeholder for the 3d array\n  let imageArray = tf.fill([width, height, 3], 0).arraySync();\n\n  // Iterate through the data to fill out channel arrays above\n  for (let i = 0; i < imageData.length; i++) {\n    let pixelIndex = Math.floor(i / 4),\n      channelIndex = i % 4,\n      row = width === height ? Math.floor(pixelIndex / width)\n                              : pixelIndex % width,\n      column = width === height ? pixelIndex % width\n                              : Math.floor(pixelIndex / width);\n    \n    if (channelIndex < 3) {\n      let curEntry  = imageData[i];\n      // Normalize the original pixel value from [0, 255] to [0, 1]\n      if (normalize) {\n        curEntry /= 255;\n      }\n      imageArray[row][column][channelIndex] = curEntry;\n    }\n  }\n\n  // If the image is not 64x64, crop and or pad the image appropriately.\n  if (width != networkInputSize && height != networkInputSize) {\n    imageArray = cropCentralSquare(imageArray)\n  }\n\n  let tensor = tf.tensor3d(imageArray);\n  return tensor;\n}\n\n/**\n * Get the 3D pixel value array of the given image file.\n * \n * @param {string} imgFile File path to the image file\n * @returns A promise with the corresponding 3D array\n */\nconst getInputImageArray = (imgFile, normalize=true) => {\n  let canvas = document.createElement('canvas');\n  canvas.style.cssText = 'display:none;';\n  document.getElementsByTagName('body')[0].appendChild(canvas);\n  let context = canvas.getContext('2d');\n\n  return new Promise((resolve, reject) => {\n    let inputImage = new Image();\n    inputImage.crossOrigin = \"Anonymous\";\n    inputImage.src = imgFile;\n    let canvasImage;\n    inputImage.onload = () => {\n      canvas.width = inputImage.width;\n      canvas.height = inputImage.height;\n      // Resize the input image of the network if it is too large to simply crop\n      // the center 64x64 portion in order to still provide a representative\n      // input image into the network.\n      if (inputImage.width > networkInputSize || inputImage.height > networkInputSize) {\n        // Step 1 - Resize using smaller dimension to scale the image down. \n        let resizeCanvas = document.createElement('canvas'),\n            resizeContext = resizeCanvas.getContext('2d');\n        let smallerDimension = Math.min(inputImage.width, inputImage.height);\n        const resizeFactor = (networkInputSize + 1) / smallerDimension;\n        resizeCanvas.width = inputImage.width * resizeFactor;\n        resizeCanvas.height = inputImage.height * resizeFactor;\n        resizeContext.drawImage(inputImage, 0, 0, resizeCanvas.width,\n          resizeCanvas.height);\n\n        // Step 2 - Flip non-square images horizontally and rotate them 90deg since\n        // non-square images are not stored upright.\n        if (inputImage.width != inputImage.height) {\n          context.translate(resizeCanvas.width, 0);\n          context.scale(-1, 1);\n          context.translate(resizeCanvas.width / 2, resizeCanvas.height / 2);\n          context.rotate(90 * Math.PI / 180);\n        }\n\n        // Step 3 - Draw resized image on original canvas.\n        if (inputImage.width != inputImage.height) {\n          context.drawImage(resizeCanvas, -resizeCanvas.width / 2, -resizeCanvas.height / 2);\n        } else {\n          context.drawImage(resizeCanvas, 0, 0);\n        }\n        canvasImage = context.getImageData(0, 0, resizeCanvas.width,\n          resizeCanvas.height);\n\n      } else {\n        context.drawImage(inputImage, 0, 0);\n        canvasImage = context.getImageData(0, 0, inputImage.width,\n          inputImage.height);\n      }\n      // Get image data and convert it to a 3D array\n      let imageData = canvasImage.data;\n      let imageWidth = canvasImage.width;\n      let imageHeight = canvasImage.height;\n\n      // Remove this newly created canvas element\n      canvas.parentNode.removeChild(canvas);\n\n      resolve(imageDataTo3DTensor(imageData, imageWidth, imageHeight, normalize));\n    }\n    inputImage.onerror = reject;\n  })\n}\n\n/**\n * Wrapper to load a model.\n * \n * @param {string} modelFile Filename of converted (through tensorflowjs.py)\n *  model json file.\n */\nexport const loadTrainedModel = (modelFile) => {\n  return tf.loadLayersModel(modelFile);\n}\n","/* global d3 */\n\nconst layerColorScales = {\n  input: [d3.interpolateGreys, d3.interpolateGreys, d3.interpolateGreys],\n  conv: d3.interpolateRdBu,\n  relu: d3.interpolateRdBu,\n  pool: d3.interpolateRdBu,\n  fc: d3.interpolateGreys,\n  weight: d3.interpolateBrBG,\n  logit: d3.interpolateOranges\n};\n\nlet nodeLength = 40;\n\nexport const overviewConfig = {\n  nodeLength : nodeLength,\n  plusSymbolRadius : nodeLength / 5,\n  numLayers : 12,\n  edgeOpacity : 0.8,\n  edgeInitColor : 'rgb(230, 230, 230)',\n  edgeHoverColor : 'rgb(130, 130, 130)',\n  edgeHoverOuting : false,\n  edgeStrokeWidth : 0.7,\n  intermediateColor : 'gray',\n  layerColorScales: layerColorScales,\n  svgPaddings: {top: 25, bottom: 25, left: 50, right: 50},\n  kernelRectLength: 8/3,\n  gapRatio: 4,\n  overlayRectOffset: 12,\n  classLists: ['lifeboat', 'ladybug', 'pizza', 'bell pepper', 'school bus',\n    'koala', 'espresso', 'red panda', 'orange', 'sport car']\n};","import { overviewConfig } from '../config.js';\n\n// Configs\nconst nodeLength = overviewConfig.nodeLength;\n\n/**\n * Compute the [minimum, maximum] of a 1D or 2D array.\n * @param {[number]} array \n */\nexport  const getExtent = (array) => {\n  let min = Infinity;\n  let max = -Infinity;\n\n  // Scalar\n  if (array.length === undefined) {\n    return [array, array];\n  }\n\n  // 1D array\n  if (array[0].length === undefined) {\n    for (let i = 0; i < array[0].length; i++) {\n      if (array[i] < min) {\n        min = array[i];\n      } else if (array[i] > max) {\n        max = array[i];\n      }\n    }\n    return [min, max];\n  }\n\n  // 2D array\n  for (let i = 0; i < array.length; i++) {\n    for (let j = 0; j < array[0].length; j++) {\n      if (array[i][j] < min) {\n        min = array[i][j];\n      } else if (array[i][j] > max) {\n        max = array[i][j];\n      }\n    }\n  }\n  return [min, max];\n}\n\n/**\n * Convert the svg element center coord to document absolute value\n * // Inspired by https://github.com/caged/d3-tip/blob/master/index.js#L286\n * @param {elem} elem \n */\nexport const getMidCoords = (svg, elem) => {\n  if (svg !== undefined) {\n    let targetel = elem;\n    while (targetel.getScreenCTM == null && targetel.parentNode != null) {\n      targetel = targetel.parentNode;\n    }\n    // Get the absolute coordinate of the E point of element bbox\n    let point = svg.node().ownerSVGElement.createSVGPoint();\n    let matrix = targetel.getScreenCTM();\n    let tbbox = targetel.getBBox();\n    // let width = tbbox.width;\n    let height = tbbox.height;\n\n    point.x += 0;\n    point.y -= height / 2;\n    let bbox = point.matrixTransform(matrix);\n    return {\n      top: bbox.y,\n      left: bbox.x\n    };\n  }\n}\n\n/**\n * Return the output knot (right boundary center)\n * @param {object} point {x: x, y:y}\n */\nexport const getOutputKnot = (point) => {\n  return {\n    x: point.x + nodeLength,\n    y: point.y + nodeLength / 2\n  };\n}\n\n/**\n * Return the output knot (left boundary center)\n * @param {object} point {x: x, y:y}\n */\nexport const getInputKnot = (point) => {\n  return {\n    x: point.x,\n    y: point.y + nodeLength / 2\n  }\n}\n\n/**\n * Compute edge data\n * @param {[[[number, number]]]} nodeCoordinate Constructed neuron svg locations\n * @param {[object]} cnn Constructed CNN model\n */\nexport const getLinkData = (nodeCoordinate, cnn) => {\n  let linkData = [];\n  // Create links backward (starting for the first conv layer)\n  for (let l = 1; l < cnn.length; l++) {\n    for (let n = 0; n < cnn[l].length; n++) {\n      let isOutput = cnn[l][n].layerName === 'output';\n      let curTarget = getInputKnot(nodeCoordinate[l][n]);\n      for (let p = 0; p < cnn[l][n].inputLinks.length; p++) {\n        // Specially handle output layer (since we are ignoring the flatten)\n        let inputNodeIndex = cnn[l][n].inputLinks[p].source.index;\n        \n        if (isOutput) {\n          let flattenDimension = cnn[l-1][0].output.length *\n            cnn[l-1][0].output.length;\n          if (inputNodeIndex % flattenDimension !== 0){\n              continue;\n          }\n          inputNodeIndex = Math.floor(inputNodeIndex / flattenDimension);\n        }\n        let curSource = getOutputKnot(nodeCoordinate[l-1][inputNodeIndex]);\n        let curWeight = cnn[l][n].inputLinks[p].weight;\n        linkData.push({\n          source: curSource,\n          target: curTarget,\n          weight: curWeight,\n          targetLayerIndex: l,\n          targetNodeIndex: n,\n          sourceNodeIndex: inputNodeIndex\n        });\n      }\n    }\n  }\n  return linkData;\n}\n\n\n/**\n * Color scale wrapper (support artificially lighter color!)\n * @param {function} colorScale D3 color scale function\n * @param {number} range Color range (max - min)\n * @param {number} value Color value\n * @param {number} gap Tail of the color scale to skip\n */\nexport const gappedColorScale = (colorScale, range, value, gap) => {\n  if (gap === undefined) { gap = 0; }\n  let normalizedValue = (value + range / 2) / range;\n  return colorScale(normalizedValue * (1 - 2 * gap) + gap);\n}","/* global d3, SmoothScroll */\n\nimport {\n  svgStore, vSpaceAroundGapStore, hSpaceAroundGapStore, cnnStore,\n  nodeCoordinateStore, selectedScaleLevelStore, cnnLayerRangesStore,\n  detailedModeStore, cnnLayerMinMaxStore, hoverInfoStore\n} from '../stores.js';\nimport {\n  getExtent, getLinkData\n} from './draw-utils.js';\nimport { overviewConfig } from '../config.js';\n\n// Configs\nconst layerColorScales = overviewConfig.layerColorScales;\nconst nodeLength = overviewConfig.nodeLength;\nconst numLayers = overviewConfig.numLayers;\nconst edgeOpacity = overviewConfig.edgeOpacity;\nconst edgeInitColor = overviewConfig.edgeInitColor;\nconst edgeStrokeWidth = overviewConfig.edgeStrokeWidth;\nconst svgPaddings = overviewConfig.svgPaddings;\nconst gapRatio = overviewConfig.gapRatio;\nconst classLists = overviewConfig.classLists;\nconst formater = d3.format('.4f');\n\n// Shared variables\nlet svg = undefined;\nsvgStore.subscribe( value => {svg = value;} )\n\nlet vSpaceAroundGap = undefined;\nvSpaceAroundGapStore.subscribe( value => {vSpaceAroundGap = value;} )\n\nlet hSpaceAroundGap = undefined;\nhSpaceAroundGapStore.subscribe( value => {hSpaceAroundGap = value;} )\n\nlet cnn = undefined;\ncnnStore.subscribe( value => {cnn = value;} )\n\nlet nodeCoordinate = undefined;\nnodeCoordinateStore.subscribe( value => {nodeCoordinate = value;} )\n\nlet selectedScaleLevel = undefined;\nselectedScaleLevelStore.subscribe( value => {selectedScaleLevel = value;} )\n\nlet cnnLayerRanges = undefined;\ncnnLayerRangesStore.subscribe( value => {cnnLayerRanges = value;} )\n\nlet cnnLayerMinMax = undefined;\ncnnLayerMinMaxStore.subscribe( value => {cnnLayerMinMax = value;} )\n\nlet detailedMode = undefined;\ndetailedModeStore.subscribe( value => {detailedMode = value;} )\n\n/**\n * Use bounded d3 data to draw one canvas\n * @param {object} d d3 data\n * @param {index} i d3 data index\n * @param {[object]} g d3 group\n * @param {number} range color range map (max - min)\n */\nexport const drawOutput = (d, i, g, range) => {\n  let image = g[i];\n  let colorScale = layerColorScales[d.type];\n\n  if (d.type === 'input') {\n    colorScale = colorScale[d.index];\n  }\n\n  // Set up a second convas in order to resize image\n  let imageLength = d.output.length === undefined ? 1 : d.output.length;\n  let bufferCanvas = document.createElement(\"canvas\");\n  let bufferContext = bufferCanvas.getContext(\"2d\");\n  bufferCanvas.width = imageLength;\n  bufferCanvas.height = imageLength;\n\n  // Fill image pixel array\n  let imageSingle = bufferContext.getImageData(0, 0, imageLength, imageLength);\n  let imageSingleArray = imageSingle.data;\n\n  if (imageLength === 1) {\n    imageSingleArray[0] = d.output;\n  } else {\n    for (let i = 0; i < imageSingleArray.length; i+=4) {\n      let pixeIndex = Math.floor(i / 4);\n      let row = Math.floor(pixeIndex / imageLength);\n      let column = pixeIndex % imageLength;\n      let color = undefined;\n      if (d.type === 'input' || d.type === 'fc' ) {\n        color = d3.rgb(colorScale(1 - d.output[row][column]))\n      } else {\n        color = d3.rgb(colorScale((d.output[row][column] + range / 2) / range));\n      }\n\n      imageSingleArray[i] = color.r;\n      imageSingleArray[i + 1] = color.g;\n      imageSingleArray[i + 2] = color.b;\n      imageSingleArray[i + 3] = 255;\n    }\n  }\n\n  // canvas.toDataURL() only exports image in 96 DPI, so we can hack it to have\n  // higher DPI by rescaling the image using canvas magic\n  let largeCanvas = document.createElement('canvas');\n  largeCanvas.width = nodeLength * 3;\n  largeCanvas.height = nodeLength * 3;\n  let largeCanvasContext = largeCanvas.getContext('2d');\n\n  // Use drawImage to resize the original pixel array, and put the new image\n  // (canvas) into corresponding canvas\n  bufferContext.putImageData(imageSingle, 0, 0);\n  largeCanvasContext.drawImage(bufferCanvas, 0, 0, imageLength, imageLength,\n    0, 0, nodeLength * 3, nodeLength * 3);\n  \n  let imageDataURL = largeCanvas.toDataURL();\n  d3.select(image).attr('xlink:href', imageDataURL);\n\n  // Destory the buffer canvas\n  bufferCanvas.remove();\n  largeCanvas.remove();\n}\n\n/**\n * Draw bar chart to encode the output value\n * @param {object} d d3 data\n * @param {index} i d3 data index\n * @param {[object]} g d3 group\n * @param {function} scale map value to length\n */\nconst drawOutputScore = (d, i, g, scale) => {\n  let group = d3.select(g[i]);\n  group.select('rect.output-rect')\n    .transition('output')\n    .delay(500)\n    .duration(800)\n    .ease(d3.easeCubicIn)\n    .attr('width', scale(d.output))\n}\n\nexport const drawCustomImage = (image, inputLayer) => {\n\n  let imageWidth = image.width;\n  // Set up a second convas in order to resize image\n  let imageLength = inputLayer[0].output.length;\n  let bufferCanvas = document.createElement(\"canvas\");\n  let bufferContext = bufferCanvas.getContext(\"2d\");\n  bufferCanvas.width = imageLength;\n  bufferCanvas.height = imageLength;\n\n  // Fill image pixel array\n  let imageSingle = bufferContext.getImageData(0, 0, imageLength, imageLength);\n  let imageSingleArray = imageSingle.data;\n\n  for (let i = 0; i < imageSingleArray.length; i+=4) {\n    let pixeIndex = Math.floor(i / 4);\n    let row = Math.floor(pixeIndex / imageLength);\n    let column = pixeIndex % imageLength;\n\n    let red = inputLayer[0].output[row][column];\n    let green = inputLayer[1].output[row][column];\n    let blue = inputLayer[2].output[row][column];\n\n    imageSingleArray[i] = red * 255;\n    imageSingleArray[i + 1] = green * 255;\n    imageSingleArray[i + 2] = blue * 255;\n    imageSingleArray[i + 3] = 255;\n  }\n\n  // canvas.toDataURL() only exports image in 96 DPI, so we can hack it to have\n  // higher DPI by rescaling the image using canvas magic\n  let largeCanvas = document.createElement('canvas');\n  largeCanvas.width = imageWidth * 3;\n  largeCanvas.height = imageWidth * 3;\n  let largeCanvasContext = largeCanvas.getContext('2d');\n\n  // Use drawImage to resize the original pixel array, and put the new image\n  // (canvas) into corresponding canvas\n  bufferContext.putImageData(imageSingle, 0, 0);\n  largeCanvasContext.drawImage(bufferCanvas, 0, 0, imageLength, imageLength,\n    0, 0, imageWidth * 3, imageWidth * 3);\n  \n  let imageDataURL = largeCanvas.toDataURL();\n  // d3.select(image).attr('xlink:href', imageDataURL);\n  image.src = imageDataURL;\n\n  // Destory the buffer canvas\n  bufferCanvas.remove();\n  largeCanvas.remove();\n}\n\n/**\n * Create color gradient for the legend\n * @param {[object]} g d3 group\n * @param {function} colorScale Colormap\n * @param {string} gradientName Label for gradient def\n * @param {number} min Min of legend value\n * @param {number} max Max of legend value\n */\nconst getLegendGradient = (g, colorScale, gradientName, min, max) => {\n  if (min === undefined) { min = 0; }\n  if (max === undefined) { max = 1; }\n  let gradient = g.append('defs')\n    .append('svg:linearGradient')\n    .attr('id', `${gradientName}`)\n    .attr('x1', '0%')\n    .attr('y1', '100%')\n    .attr('x2', '100%')\n    .attr('y2', '100%')\n    .attr('spreadMethod', 'pad');\n  let interpolation = 10\n  for (let i = 0; i < interpolation; i++) {\n    let curProgress = i / (interpolation - 1);\n    let curColor = colorScale(curProgress * (max - min) + min);\n    gradient.append('stop')\n      .attr('offset', `${curProgress * 100}%`)\n      .attr('stop-color', curColor)\n      .attr('stop-opacity', 1);\n  }\n}\n\n/**\n * Draw all legends\n * @param {object} legends Parent group\n * @param {number} legendHeight Height of the legend element\n */\nconst drawLegends = (legends, legendHeight) => {\n  // Add local legends\n  for (let i = 0; i < 2; i++){\n    let start = 1 + i * 5;\n    let range1 = cnnLayerRanges.local[start];\n    let range2 = cnnLayerRanges.local[start + 2];\n\n    let localLegendScale1 = d3.scaleLinear()\n      .range([0, 2 * nodeLength + hSpaceAroundGap - 1.2])\n      .domain([-range1 / 2, range1 / 2]);\n    \n    let localLegendScale2 = d3.scaleLinear()\n      .range([0, 3 * nodeLength + 2 * hSpaceAroundGap - 1.2])\n      .domain([-range2 / 2, range2 / 2]);\n\n    let localLegendAxis1 = d3.axisBottom()\n      .scale(localLegendScale1)\n      .tickFormat(d3.format('.2f'))\n      .tickValues([-range1 / 2, 0, range1 / 2]);\n    \n    let localLegendAxis2 = d3.axisBottom()\n      .scale(localLegendScale2)\n      .tickFormat(d3.format('.2f'))\n      .tickValues([-range2 / 2, 0, range2 / 2]);\n\n    let localLegend1 = legends.append('g')\n      .attr('class', 'legend local-legend')\n      .attr('id', `local-legend-${i}-1`)\n      .classed('hidden', !detailedMode || selectedScaleLevel !== 'local')\n      .attr('transform', `translate(${nodeCoordinate[start][0].x}, ${0})`);\n\n    localLegend1.append('g')\n      .attr('transform', `translate(0, ${legendHeight - 3})`)\n      .call(localLegendAxis1)\n\n    localLegend1.append('rect')\n      .attr('width', 2 * nodeLength + hSpaceAroundGap)\n      .attr('height', legendHeight)\n      .style('fill', 'url(#convGradient)');\n\n    let localLegend2 = legends.append('g')\n      .attr('class', 'legend local-legend')\n      .attr('id', `local-legend-${i}-2`)\n      .classed('hidden', !detailedMode || selectedScaleLevel !== 'local')\n      .attr('transform', `translate(${nodeCoordinate[start + 2][0].x}, ${0})`);\n\n    localLegend2.append('g')\n      .attr('transform', `translate(0, ${legendHeight - 3})`)\n      .call(localLegendAxis2)\n\n    localLegend2.append('rect')\n      .attr('width', 3 * nodeLength + 2 * hSpaceAroundGap)\n      .attr('height', legendHeight)\n      .style('fill', 'url(#convGradient)');\n  }\n\n  // Add module legends\n  for (let i = 0; i < 2; i++){\n    let start = 1 + i * 5;\n    let range = cnnLayerRanges.module[start];\n\n    let moduleLegendScale = d3.scaleLinear()\n      .range([0, 5 * nodeLength + 3 * hSpaceAroundGap +\n        1 * hSpaceAroundGap * gapRatio - 1.2])\n      .domain([-range / 2, range / 2]);\n\n    let moduleLegendAxis = d3.axisBottom()\n      .scale(moduleLegendScale)\n      .tickFormat(d3.format('.2f'))\n      .tickValues([-range / 2, -(range / 4), 0, range / 4, range / 2]);\n\n    let moduleLegend = legends.append('g')\n      .attr('class', 'legend module-legend')\n      .attr('id', `module-legend-${i}`)\n      .classed('hidden', !detailedMode || selectedScaleLevel !== 'module')\n      .attr('transform', `translate(${nodeCoordinate[start][0].x}, ${0})`);\n    \n    moduleLegend.append('g')\n      .attr('transform', `translate(0, ${legendHeight - 3})`)\n      .call(moduleLegendAxis)\n\n    moduleLegend.append('rect')\n      .attr('width', 5 * nodeLength + 3 * hSpaceAroundGap +\n        1 * hSpaceAroundGap * gapRatio)\n      .attr('height', legendHeight)\n      .style('fill', 'url(#convGradient)');\n  }\n\n  // Add global legends\n  let start = 1;\n  let range = cnnLayerRanges.global[start];\n\n  let globalLegendScale = d3.scaleLinear()\n    .range([0, 10 * nodeLength + 6 * hSpaceAroundGap +\n      3 * hSpaceAroundGap * gapRatio - 1.2])\n    .domain([-range / 2, range / 2]);\n\n  let globalLegendAxis = d3.axisBottom()\n    .scale(globalLegendScale)\n    .tickFormat(d3.format('.2f'))\n    .tickValues([-range / 2, -(range / 4), 0, range / 4, range / 2]);\n\n  let globalLegend = legends.append('g')\n    .attr('class', 'legend global-legend')\n    .attr('id', 'global-legend')\n    .classed('hidden', !detailedMode || selectedScaleLevel !== 'global')\n    .attr('transform', `translate(${nodeCoordinate[start][0].x}, ${0})`);\n\n  globalLegend.append('g')\n    .attr('transform', `translate(0, ${legendHeight - 3})`)\n    .call(globalLegendAxis)\n\n  globalLegend.append('rect')\n    .attr('width', 10 * nodeLength + 6 * hSpaceAroundGap +\n      3 * hSpaceAroundGap * gapRatio)\n    .attr('height', legendHeight)\n    .style('fill', 'url(#convGradient)');\n\n\n  // Add output legend\n  let outputRectScale = d3.scaleLinear()\n        .domain(cnnLayerRanges.output)\n        .range([0, nodeLength - 1.2]);\n\n  let outputLegendAxis = d3.axisBottom()\n    .scale(outputRectScale)\n    .tickFormat(d3.format('.1f'))\n    .tickValues([0, cnnLayerRanges.output[1]])\n  \n  let outputLegend = legends.append('g')\n    .attr('class', 'legend output-legend')\n    .attr('id', 'output-legend')\n    .classed('hidden', !detailedMode)\n    .attr('transform', `translate(${nodeCoordinate[11][0].x}, ${0})`);\n  \n  outputLegend.append('g')\n    .attr('transform', `translate(0, ${legendHeight - 3})`)\n    .call(outputLegendAxis);\n\n  outputLegend.append('rect')\n    .attr('width', nodeLength)\n    .attr('height', legendHeight)\n    .style('fill', 'gray');\n  \n  // Add input image legend\n  let inputScale = d3.scaleLinear()\n    .range([0, nodeLength - 1.2])\n    .domain([0, 1]);\n\n  let inputLegendAxis = d3.axisBottom()\n    .scale(inputScale)\n    .tickFormat(d3.format('.1f'))\n    .tickValues([0, 0.5, 1]);\n\n  let inputLegend = legends.append('g')\n    .attr('class', 'legend input-legend')\n    .classed('hidden', !detailedMode)\n    .attr('transform', `translate(${nodeCoordinate[0][0].x}, ${0})`);\n  \n  inputLegend.append('g')\n    .attr('transform', `translate(0, ${legendHeight - 3})`)\n    .call(inputLegendAxis);\n\n  inputLegend.append('rect')\n    .attr('x', 0.3)\n    .attr('width', nodeLength - 0.3)\n    .attr('height', legendHeight)\n    .attr('transform', `rotate(180, ${nodeLength/2}, ${legendHeight/2})`)\n    .style('stroke', 'rgb(20, 20, 20)')\n    .style('stroke-width', 0.3)\n    .style('fill', 'url(#inputGradient)');\n}\n\n/**\n * Draw the overview\n * @param {number} width Width of the cnn group\n * @param {number} height Height of the cnn group\n * @param {object} cnnGroup Group to appen cnn elements to\n * @param {function} nodeMouseOverHandler Callback func for mouseOver\n * @param {function} nodeMouseLeaveHandler Callback func for mouseLeave\n * @param {function} nodeClickHandler Callback func for click\n */\nexport const drawCNN = (width, height, cnnGroup, nodeMouseOverHandler,\n  nodeMouseLeaveHandler, nodeClickHandler) => {\n  // Draw the CNN\n  // There are 8 short gaps and 5 long gaps\n  hSpaceAroundGap = (width - nodeLength * numLayers) / (8 + 5 * gapRatio);\n  hSpaceAroundGapStore.set(hSpaceAroundGap);\n  let leftAccuumulatedSpace = 0;\n\n  // Iterate through the cnn to draw nodes in each layer\n  for (let l = 0; l < cnn.length; l++) {\n    let curLayer = cnn[l];\n    let isOutput = curLayer[0].layerName === 'output';\n\n    nodeCoordinate.push([]);\n\n    // Compute the x coordinate of the whole layer\n    // Output layer and conv layer has long gaps\n    if (isOutput || curLayer[0].type === 'conv') {\n      leftAccuumulatedSpace += hSpaceAroundGap * gapRatio;\n    } else {\n      leftAccuumulatedSpace += hSpaceAroundGap;\n    }\n\n    // All nodes share the same x coordiante (left in div style)\n    let left = leftAccuumulatedSpace;\n\n    let layerGroup = cnnGroup.append('g')\n      .attr('class', 'cnn-layer-group')\n      .attr('id', `cnn-layer-group-${l}`);\n\n    vSpaceAroundGap = (height - nodeLength * curLayer.length) /\n      (curLayer.length + 1);\n    vSpaceAroundGapStore.set(vSpaceAroundGap);\n\n    let nodeGroups = layerGroup.selectAll('g.node-group')\n      .data(curLayer, d => d.index)\n      .enter()\n      .append('g')\n      .attr('class', 'node-group')\n      .style('cursor', 'pointer')\n      .style('pointer-events', 'all')\n      .on('click', nodeClickHandler)\n      .on('mouseover', nodeMouseOverHandler)\n      .on('mouseleave', nodeMouseLeaveHandler)\n      .classed('node-output', isOutput)\n      .attr('id', (d, i) => {\n        // Compute the coordinate\n        // Not using transform on the group object because of a decade old\n        // bug on webkit (safari)\n        // https://bugs.webkit.org/show_bug.cgi?id=23113\n        let top = i * nodeLength + (i + 1) * vSpaceAroundGap;\n        top += svgPaddings.top;\n        nodeCoordinate[l].push({x: left, y: top});\n        return `layer-${l}-node-${i}`\n      });\n    \n    // Overwrite the mouseover and mouseleave function for output nodes to show\n    // hover info in the UI\n    layerGroup.selectAll('g.node-output')\n      .on('mouseover', (d, i, g) => {\n        nodeMouseOverHandler(d, i, g);\n        hoverInfoStore.set( {show: true, text: `Output value: ${formater(d.output)}`} );\n      })\n      .on('mouseleave', (d, i, g) => {\n        nodeMouseLeaveHandler(d, i, g);\n        hoverInfoStore.set( {show: false, text: `Output value: ${formater(d.output)}`} );\n      });\n    \n    if (curLayer[0].layerName !== 'output') {\n      // Embed raster image in these groups\n      nodeGroups.append('image')\n        .attr('class', 'node-image')\n        .attr('width', nodeLength)\n        .attr('height', nodeLength)\n        .attr('x', left)\n        .attr('y', (d, i) => nodeCoordinate[l][i].y);\n      \n      // Add a rectangle to show the border\n      nodeGroups.append('rect')\n        .attr('class', 'bounding')\n        .attr('width', nodeLength)\n        .attr('height', nodeLength)\n        .attr('x', left)\n        .attr('y', (d, i) => nodeCoordinate[l][i].y)\n        .style('fill', 'none')\n        .style('stroke', 'gray')\n        .style('stroke-width', 1)\n        .classed('hidden', true);\n    } else {\n      nodeGroups.append('rect')\n        .attr('class', 'output-rect')\n        .attr('x', left)\n        .attr('y', (d, i) => nodeCoordinate[l][i].y + nodeLength / 2 + 8)\n        .attr('height', nodeLength / 4)\n        .attr('width', 0)\n        .style('fill', 'gray');\n      nodeGroups.append('text')\n        .attr('class', 'output-text')\n        .attr('x', left)\n        .attr('y', (d, i) => nodeCoordinate[l][i].y + nodeLength / 2)\n        .style('dominant-baseline', 'middle')\n        .style('font-size', '11px')\n        .style('fill', 'black')\n        .style('opacity', 0.5)\n        .text((d, i) => classLists[i]);\n      \n      // Add annotation text to tell readers the exact output probability\n      // nodeGroups.append('text')\n      //   .attr('class', 'annotation-text')\n      //   .attr('id', (d, i) => `output-prob-${i}`)\n      //   .attr('x', left)\n      //   .attr('y', (d, i) => nodeCoordinate[l][i].y + 10)\n      //   .text(d => `(${d3.format('.4f')(d.output)})`);\n    }\n    leftAccuumulatedSpace += nodeLength;\n  }\n\n  // Share the nodeCoordinate\n  nodeCoordinateStore.set(nodeCoordinate)\n\n  // Compute the scale of the output score width (mapping the the node\n  // width to the max output score)\n  let outputRectScale = d3.scaleLinear()\n        .domain(cnnLayerRanges.output)\n        .range([0, nodeLength]);\n\n  // Draw the canvas\n  for (let l = 0; l < cnn.length; l++) {\n    let range = cnnLayerRanges[selectedScaleLevel][l];\n    svg.select(`g#cnn-layer-group-${l}`)\n      .selectAll('image.node-image')\n      .each((d, i, g) => drawOutput(d, i, g, range));\n  }\n\n  svg.selectAll('g.node-output').each(\n    (d, i, g) => drawOutputScore(d, i, g, outputRectScale)\n  );\n\n  // Add layer label\n  let layerNames = cnn.map(d => {\n    if (d[0].layerName === 'output') {\n      return {\n        name: d[0].layerName,\n        dimension: `(${d.length})`\n      }\n    } else {\n      return {\n        name: d[0].layerName,\n        dimension: `(${d[0].output.length}, ${d[0].output.length}, ${d.length})`\n      }\n    }\n  });\n\n  let svgHeight = Number(d3.select('#cnn-svg').style('height').replace('px', '')) + 150;\n  let scroll = new SmoothScroll('a[href*=\"#\"]', {offset: -svgHeight});\n  \n  let detailedLabels = svg.selectAll('g.layer-detailed-label')\n    .data(layerNames)\n    .enter()\n    .append('g')\n    .attr('class', 'layer-detailed-label')\n    .attr('id', (d, i) => `layer-detailed-label-${i}`)\n    .classed('hidden', !detailedMode)\n    .attr('transform', (d, i) => {\n      let x = nodeCoordinate[i][0].x + nodeLength / 2;\n      let y = (svgPaddings.top + vSpaceAroundGap) / 2 - 6;\n      return `translate(${x}, ${y})`;\n    })\n    .style('cursor', d => d.name.includes('output') ? 'default' : 'help')\n    .on('click', (d) => {\n      let target = '';\n      if (d.name.includes('conv')) { target = 'convolution' }\n      if (d.name.includes('relu')) { target = 'relu' }\n      if (d.name.includes('max_pool')) { target = 'pooling'}\n      if (d.name.includes('input')) { target = 'input'}\n\n      // Scroll to a article element\n      let anchor = document.querySelector(`#article-${target}`);\n      scroll.animateScroll(anchor);\n    });\n  \n  detailedLabels.append('title')\n    .text('Move to article section');\n    \n  detailedLabels.append('text')\n    .style('opacity', 0.7)\n    .style('dominant-baseline', 'middle')\n    .append('tspan')\n    .style('font-size', '12px')\n    .text(d => d.name)\n    .append('tspan')\n    .style('font-size', '8px')\n    .style('font-weight', 'normal')\n    .attr('x', 0)\n    .attr('dy', '1.5em')\n    .text(d => d.dimension);\n  \n  let labels = svg.selectAll('g.layer-label')\n    .data(layerNames)\n    .enter()\n    .append('g')\n    .attr('class', 'layer-label')\n    .attr('id', (d, i) => `layer-label-${i}`)\n    .classed('hidden', detailedMode)\n    .attr('transform', (d, i) => {\n      let x = nodeCoordinate[i][0].x + nodeLength / 2;\n      let y = (svgPaddings.top + vSpaceAroundGap) / 2 + 5;\n      return `translate(${x}, ${y})`;\n    })\n    .style('cursor', d => d.name.includes('output') ? 'default' : 'help')\n    .on('click', (d) => {\n      let target = '';\n      if (d.name.includes('conv')) { target = 'convolution' }\n      if (d.name.includes('relu')) { target = 'relu' }\n      if (d.name.includes('max_pool')) { target = 'pooling'}\n      if (d.name.includes('input')) { target = 'input'}\n\n      // Scroll to a article element\n      let anchor = document.querySelector(`#article-${target}`);\n      scroll.animateScroll(anchor);\n    });\n  \n  labels.append('title')\n    .text('Move to article section');\n  \n  labels.append('text')\n    .style('dominant-baseline', 'middle')\n    .style('opacity', 0.8)\n    .text(d => {\n      if (d.name.includes('conv')) { return 'conv' }\n      if (d.name.includes('relu')) { return 'relu' }\n      if (d.name.includes('max_pool')) { return 'max_pool'}\n      return d.name\n    });\n\n  // Add layer color scale legends\n  getLegendGradient(svg, layerColorScales.conv, 'convGradient');\n  getLegendGradient(svg, layerColorScales.input[0], 'inputGradient');\n\n  let legendHeight = 5;\n  let legends = svg.append('g')\n      .attr('class', 'color-legend')\n      .attr('transform', `translate(${0}, ${\n        svgPaddings.top + vSpaceAroundGap * (10) + vSpaceAroundGap +\n        nodeLength * 10\n      })`);\n  \n  drawLegends(legends, legendHeight);\n\n  // Add edges between nodes\n  let linkGen = d3.linkHorizontal()\n    .x(d => d.x)\n    .y(d => d.y);\n  \n  let linkData = getLinkData(nodeCoordinate, cnn);\n\n  let edgeGroup = cnnGroup.append('g')\n    .attr('class', 'edge-group');\n  \n  edgeGroup.selectAll('path.edge')\n    .data(linkData)\n    .enter()\n    .append('path')\n    .attr('class', d =>\n      `edge edge-${d.targetLayerIndex} edge-${d.targetLayerIndex}-${d.targetNodeIndex}`)\n    .attr('id', d => \n      `edge-${d.targetLayerIndex}-${d.targetNodeIndex}-${d.sourceNodeIndex}`)\n    .attr('d', d => linkGen({source: d.source, target: d.target}))\n    .style('fill', 'none')\n    .style('stroke-width', edgeStrokeWidth)\n    .style('opacity', edgeOpacity)\n    .style('stroke', edgeInitColor);\n\n  // Add input channel annotations\n  let inputAnnotation = cnnGroup.append('g')\n    .attr('class', 'input-annotation');\n\n  let redChannel = inputAnnotation.append('text')\n    .attr('x', nodeCoordinate[0][0].x + nodeLength / 2)\n    .attr('y', nodeCoordinate[0][0].y + nodeLength + 5)\n    .attr('class', 'annotation-text')\n    .style('dominant-baseline', 'hanging')\n    .style('text-anchor', 'middle');\n  \n  redChannel.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .style('fill', '#C95E67')\n    .text('Red');\n  \n  redChannel.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .text(' channel');\n\n  inputAnnotation.append('text')\n    .attr('x', nodeCoordinate[0][1].x + nodeLength / 2)\n    .attr('y', nodeCoordinate[0][1].y + nodeLength + 5)\n    .attr('class', 'annotation-text')\n    .style('dominant-baseline', 'hanging')\n    .style('text-anchor', 'middle')\n    .style('fill', '#3DB665')\n    .text('Green');\n\n  inputAnnotation.append('text')\n    .attr('x', nodeCoordinate[0][2].x + nodeLength / 2)\n    .attr('y', nodeCoordinate[0][2].y + nodeLength + 5)\n    .attr('class', 'annotation-text')\n    .style('dominant-baseline', 'hanging')\n    .style('text-anchor', 'middle')\n    .style('fill', '#3F7FBC')\n    .text('Blue');\n}\n\n/**\n * Update canvas values when user changes input image\n */\nexport const updateCNN = () => {\n  // Compute the scale of the output score width (mapping the the node\n  // width to the max output score)\n  let outputRectScale = d3.scaleLinear()\n      .domain(cnnLayerRanges.output)\n      .range([0, nodeLength]);\n\n  // Rebind the cnn data to layer groups layer by layer\n  for (let l = 0; l < cnn.length; l++) {\n    let curLayer = cnn[l];\n    let range = cnnLayerRanges[selectedScaleLevel][l];\n    let layerGroup = svg.select(`g#cnn-layer-group-${l}`);\n\n    let nodeGroups = layerGroup.selectAll('g.node-group')\n      .data(curLayer);\n\n    if (l < cnn.length - 1) {\n      // Redraw the canvas and output node\n      nodeGroups.transition('disappear')\n        .duration(300)\n        .ease(d3.easeCubicOut)\n        .style('opacity', 0)\n        .on('end', function() {\n          d3.select(this)\n            .select('image.node-image')\n            .each((d, i, g) => drawOutput(d, i, g, range));\n          d3.select(this).transition('appear')\n            .duration(700)\n            .ease(d3.easeCubicIn)\n            .style('opacity', 1);\n        });\n    } else {\n      nodeGroups.each(\n        (d, i, g) => drawOutputScore(d, i, g, outputRectScale)\n      );\n    }\n  }\n\n  // Update the color scale legend\n  // Local legends\n  for (let i = 0; i < 2; i++){\n    let start = 1 + i * 5;\n    let range1 = cnnLayerRanges.local[start];\n    let range2 = cnnLayerRanges.local[start + 2];\n\n    let localLegendScale1 = d3.scaleLinear()\n      .range([0, 2 * nodeLength + hSpaceAroundGap])\n      .domain([-range1 / 2, range1 / 2]);\n    \n    let localLegendScale2 = d3.scaleLinear()\n      .range([0, 3 * nodeLength + 2 * hSpaceAroundGap])\n      .domain([-range2 / 2, range2 / 2]);\n\n    let localLegendAxis1 = d3.axisBottom()\n      .scale(localLegendScale1)\n      .tickFormat(d3.format('.2f'))\n      .tickValues([-range1 / 2, 0, range1 / 2]);\n    \n    let localLegendAxis2 = d3.axisBottom()\n      .scale(localLegendScale2)\n      .tickFormat(d3.format('.2f'))\n      .tickValues([-range2 / 2, 0, range2 / 2]);\n    \n    svg.select(`g#local-legend-${i}-1`).select('g').call(localLegendAxis1);\n    svg.select(`g#local-legend-${i}-2`).select('g').call(localLegendAxis2);\n  }\n\n  // Module legend\n  for (let i = 0; i < 2; i++){\n    let start = 1 + i * 5;\n    let range = cnnLayerRanges.local[start];\n\n    let moduleLegendScale = d3.scaleLinear()\n      .range([0, 5 * nodeLength + 3 * hSpaceAroundGap +\n        1 * hSpaceAroundGap * gapRatio - 1.2])\n      .domain([-range, range]);\n\n    let moduleLegendAxis = d3.axisBottom()\n      .scale(moduleLegendScale)\n      .tickFormat(d3.format('.2f'))\n      .tickValues([-range, -(range / 2), 0, range/2, range]);\n    \n    svg.select(`g#module-legend-${i}`).select('g').call(moduleLegendAxis);\n  }\n\n  // Global legend\n  let start = 1;\n  let range = cnnLayerRanges.global[start];\n\n  let globalLegendScale = d3.scaleLinear()\n    .range([0, 10 * nodeLength + 6 * hSpaceAroundGap +\n      3 * hSpaceAroundGap * gapRatio - 1.2])\n    .domain([-range, range]);\n\n  let globalLegendAxis = d3.axisBottom()\n    .scale(globalLegendScale)\n    .tickFormat(d3.format('.2f'))\n    .tickValues([-range, -(range / 2), 0, range/2, range]);\n\n  svg.select(`g#global-legend`).select('g').call(globalLegendAxis);\n\n  // Output legend\n  let outputLegendAxis = d3.axisBottom()\n    .scale(outputRectScale)\n    .tickFormat(d3.format('.1f'))\n    .tickValues([0, cnnLayerRanges.output[1]]);\n  \n  svg.select('g#output-legend').select('g').call(outputLegendAxis);\n}\n\n/**\n * Update the ranges for current CNN layers\n */\nexport const updateCNNLayerRanges = () => {\n  // Iterate through all nodes to find a output ranges for each layer\n  let cnnLayerRangesLocal = [1];\n  let curRange = undefined;\n\n  // Also track the min/max of each layer (avoid computing during intermediate\n  // layer)\n  cnnLayerMinMax = [];\n\n  for (let l = 0; l < cnn.length - 1; l++) {\n    let curLayer = cnn[l];\n\n    // Compute the min max\n    let outputExtents = curLayer.map(l => getExtent(l.output));\n    let aggregatedExtent = outputExtents.reduce((acc, cur) => {\n      return [Math.min(acc[0], cur[0]), Math.max(acc[1], cur[1])];\n    })\n    cnnLayerMinMax.push({min: aggregatedExtent[0], max: aggregatedExtent[1]});\n\n    // conv layer refreshes curRange counting\n    if (curLayer[0].type === 'conv' || curLayer[0].type === 'fc') {\n      aggregatedExtent = aggregatedExtent.map(Math.abs);\n      // Plus 0.1 to offset the rounding error (avoid black color)\n      curRange = 2 * (0.1 + \n        Math.round(Math.max(...aggregatedExtent) * 1000) / 1000);\n    }\n\n    if (curRange !== undefined){\n      cnnLayerRangesLocal.push(curRange);\n    }\n  }\n\n  // Finally, add the output layer range\n  cnnLayerRangesLocal.push(1);\n  cnnLayerMinMax.push({min: 0, max: 1});\n\n  // Support different levels of scales (1) lcoal, (2) component, (3) global\n  let cnnLayerRangesComponent = [1];\n  let numOfComponent = (numLayers - 2) / 5;\n  for (let i = 0; i < numOfComponent; i++) {\n    let curArray = cnnLayerRangesLocal.slice(1 + 5 * i, 1 + 5 * i + 5);\n    let maxRange = Math.max(...curArray);\n    for (let j = 0; j < 5; j++) {\n      cnnLayerRangesComponent.push(maxRange);\n    }\n  }\n  cnnLayerRangesComponent.push(1);\n\n  let cnnLayerRangesGlobal = [1];\n  let maxRange = Math.max(...cnnLayerRangesLocal.slice(1,\n    cnnLayerRangesLocal.length - 1));\n  for (let i = 0; i < numLayers - 2; i++) {\n    cnnLayerRangesGlobal.push(maxRange);\n  }\n  cnnLayerRangesGlobal.push(1);\n\n  // Update the ranges dictionary\n  cnnLayerRanges.local = cnnLayerRangesLocal;\n  cnnLayerRanges.module = cnnLayerRangesComponent;\n  cnnLayerRanges.global = cnnLayerRangesGlobal;\n  cnnLayerRanges.output = [0, d3.max(cnn[cnn.length - 1].map(d => d.output))];\n\n  cnnLayerRangesStore.set(cnnLayerRanges);\n  cnnLayerMinMaxStore.set(cnnLayerMinMax);\n}","/* global d3 */\n\nimport { svgStore, vSpaceAroundGapStore } from '../stores.js';\nimport { overviewConfig } from '../config.js';\n\n// Configs\nconst layerColorScales = overviewConfig.layerColorScales;\nconst nodeLength = overviewConfig.nodeLength;\nconst intermediateColor = overviewConfig.intermediateColor;\nconst svgPaddings = overviewConfig.svgPaddings;\n\n// Shared variables\nlet svg = undefined;\nsvgStore.subscribe( value => {svg = value;} )\n\nlet vSpaceAroundGap = undefined;\nvSpaceAroundGapStore.subscribe( value => {vSpaceAroundGap = value;} )\n\n/**\n * Move one layer horizontally\n * @param {object} arg Multiple arguments {\n *   layerIndex: current layer index\n *   targetX: destination x\n *   disable: make this layer unresponsible\n *   delay: animation delay\n *   opacity: change the current layer's opacity\n *   specialIndex: avoid manipulating `specialIndex`th node\n *   onEndFunc: call this function when animation finishes\n *   transitionName: animation ID\n * }\n */\nexport const moveLayerX = (arg) => {\n  let layerIndex = arg.layerIndex;\n  let targetX = arg.targetX;\n  let disable = arg.disable;\n  let delay = arg.delay;\n  let opacity = arg.opacity;\n  let specialIndex = arg.specialIndex;\n  let onEndFunc = arg.onEndFunc;\n  let transitionName = arg.transitionName === undefined ? 'move' : arg.transitionName;\n  let duration = arg.duration === undefined ? 500 : arg.duration;\n\n  // Move the selected layer\n  let curLayer = svg.select(`g#cnn-layer-group-${layerIndex}`);\n  curLayer.selectAll('g.node-group').each((d, i, g) => {\n    d3.select(g[i])\n      .style('cursor', disable && i !== specialIndex ? 'default' : 'pointer')\n      .style('pointer-events', disable && i !== specialIndex ? 'none' : 'all')\n      .select('image')\n      .transition(transitionName)\n      .ease(d3.easeCubicInOut)\n      .delay(delay)\n      .duration(duration)\n      .attr('x', targetX);\n    \n    d3.select(g[i])\n      .select('rect.bounding')\n      .transition(transitionName)\n      .ease(d3.easeCubicInOut)\n      .delay(delay)\n      .duration(duration)\n      .attr('x', targetX);\n    \n    if (opacity !== undefined && i !== specialIndex) {\n      d3.select(g[i])\n        .select('image')\n        .style('opacity', opacity);\n    }\n  });\n  \n  // Also move the layer labels\n  svg.selectAll(`g#layer-label-${layerIndex}`)\n    .transition(transitionName)\n    .ease(d3.easeCubicInOut)\n    .delay(delay)\n    .duration(duration)\n    .attr('transform', () => {\n      let x = targetX + nodeLength / 2;\n      let y = (svgPaddings.top + vSpaceAroundGap) / 2 + 5;\n      return `translate(${x}, ${y})`;\n    })\n    .on('end', onEndFunc);\n\n  svg.selectAll(`g#layer-detailed-label-${layerIndex}`)\n    .transition(transitionName)\n    .ease(d3.easeCubicInOut)\n    .delay(delay)\n    .duration(duration)\n    .attr('transform', () => {\n      let x = targetX + nodeLength / 2;\n      let y = (svgPaddings.top + vSpaceAroundGap) / 2 - 6;\n      return `translate(${x}, ${y})`;\n    })\n    .on('end', onEndFunc);\n}\n\n/**\n * Append a gradient definition to `group`\n * @param {string} gradientID CSS ID for the gradient def\n * @param {[{offset: number, color: string, opacity: number}]} stops Gradient stops\n * @param {element} group Element to append def to\n */\nexport const addOverlayGradient = (gradientID, stops, group) => {\n  if (group === undefined) {\n    group = svg;\n  }\n\n  // Create a gradient\n  let defs = group.append(\"defs\")\n    .attr('class', 'overlay-gradient');\n\n  let gradient = defs.append(\"linearGradient\")\n    .attr(\"id\", gradientID)\n    .attr(\"x1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y1\", \"100%\")\n    .attr(\"y2\", \"100%\");\n  \n  stops.forEach(s => {\n    gradient.append('stop')\n      .attr('offset', s.offset)\n      .attr('stop-color', s.color)\n      .attr('stop-opacity', s.opacity);\n  })\n}\n\n/**\n * Draw the legend for intermediate layer\n * @param {object} arg \n * {\n *   legendHeight: height of the legend rectangle\n *   curLayerIndex: the index of selected layer\n *   range: colormap range\n *   group: group to append the legend\n *   minMax: {min: min value, max: max value}\n *   width: width of the legend\n *   x: x position of the legend\n *   y: y position of the legend\n *   isInput: if the legend is for the input layer (special handle black to\n *      white color scale)\n *   colorScale: d3 color scale\n *   gradientAppendingName: name of the appending gradient\n *   gradientGap: gap to make the color lighter\n * }\n */\nexport const drawIntermediateLayerLegend = (arg) => {\n  let legendHeight = arg.legendHeight,\n    curLayerIndex = arg.curLayerIndex,\n    range = arg.range,\n    group = arg.group,\n    minMax = arg.minMax,\n    width = arg.width,\n    x = arg.x,\n    y = arg.y,\n    isInput = arg.isInput,\n    colorScale = arg.colorScale,\n    gradientAppendingName = arg.gradientAppendingName,\n    gradientGap = arg.gradientGap;\n  \n  if (colorScale === undefined) { colorScale = layerColorScales.conv; }\n  if (gradientGap === undefined) { gradientGap = 0; }\n  \n  // Add a legend color gradient\n  let gradientName = 'url(#inputGradient)';\n  let normalizedColor = v => colorScale(v * (1 - 2 * gradientGap) + gradientGap);\n\n  if (!isInput) {\n    let leftValue = (minMax.min + range / 2) / range,\n      zeroValue = (0 + range / 2) / range,\n      rightValue = (minMax.max + range / 2) / range,\n      totalRange = minMax.max - minMax.min,\n      zeroLocation = (0 - minMax.min) / totalRange,\n      leftMidValue = leftValue + (zeroValue - leftValue)/2,\n      rightMidValue = zeroValue + (rightValue - zeroValue)/2;\n\n    let stops = [\n      {offset: 0, color: normalizedColor(leftValue), opacity: 1},\n      {offset: zeroLocation / 2,\n        color: normalizedColor(leftMidValue),\n        opacity: 1},\n      {offset: zeroLocation,\n        color: normalizedColor(zeroValue),\n        opacity: 1},\n      {offset: zeroLocation + (1 - zeroValue) / 2,\n        color: normalizedColor(rightMidValue),\n        opacity: 1},\n      {offset: 1, color: normalizedColor(rightValue), opacity: 1}\n    ];\n\n    if (gradientAppendingName === undefined) {\n      addOverlayGradient('intermediate-legend-gradient', stops, group);\n      gradientName = 'url(#intermediate-legend-gradient)';\n    } else {\n      addOverlayGradient(`${gradientAppendingName}`, stops, group);\n      gradientName = `url(#${gradientAppendingName})`;\n    }\n  }\n\n  let legendScale = d3.scaleLinear()\n    .range([0, width - 1.2])\n    .domain(isInput ? [0, range] : [minMax.min, minMax.max]);\n\n  let legendAxis = d3.axisBottom()\n    .scale(legendScale)\n    .tickFormat(d3.format(isInput ? 'd' : '.2f'))\n    .tickValues(isInput ? [0, range] : [minMax.min, 0, minMax.max]);\n  \n  let intermediateLegend = group.append('g')\n    .attr('class', `intermediate-legend-${curLayerIndex - 1}`)\n    .attr('transform', `translate(${x}, ${y})`);\n  \n  let legendGroup = intermediateLegend.append('g')\n    .attr('transform', `translate(0, ${legendHeight - 3})`)\n    .call(legendAxis);\n  \n  legendGroup.selectAll('text')\n    .style('font-size', '9px')\n    .style('fill', intermediateColor);\n  \n  legendGroup.selectAll('path, line')\n    .style('stroke', intermediateColor);\n\n  intermediateLegend.append('rect')\n    .attr('width', width)\n    .attr('height', legendHeight)\n    .attr('transform', `rotate(${isInput ? 180 : 0},\n      ${width / 2}, ${legendHeight / 2})`)\n    .style('fill', gradientName);\n}\n\n/**\n * Draw an very neat arrow!\n * @param {object} arg \n * {\n *   group: element to append this arrow to\n *   sx: source x\n *   sy: source y\n *   tx: target x\n *   ty: target y\n *   dr: radius of curve (I'm using a circle)\n *   hFlip: the direction to choose the circle (there are always two ways)\n * }\n */\nexport const drawArrow = (arg) => {\n  let group = arg.group,\n    sx = arg.sx,\n    sy = arg.sy,\n    tx = arg.tx,\n    ty = arg.ty,\n    dr = arg.dr,\n    hFlip = arg.hFlip,\n    marker = arg.marker === undefined ? 'marker' : arg.marker;\n\n  /* Cool graphics trick -> merge translate and scale together\n  translateX = (1 - scaleX) * tx,\n  translateY = (1 - scaleY) * ty;\n  */\n  \n  let arrow = group.append('g')\n    .attr('class', 'arrow-group');\n\n  arrow.append('path')\n    .attr(\"d\", `M${sx},${sy}A${dr},${dr} 0 0,${hFlip ? 0 : 1} ${tx},${ty}`)\n    .attr('marker-end', `url(#${marker})`)\n    .style('stroke', 'gray')\n    .style('fill', 'none');\n}\n","/* global d3 */\n\nimport {\n  svgStore, vSpaceAroundGapStore, hSpaceAroundGapStore, cnnStore,\n  nodeCoordinateStore, selectedScaleLevelStore, cnnLayerRangesStore,\n  needRedrawStore, cnnLayerMinMaxStore, shouldIntermediateAnimateStore,\n  hoverInfoStore, detailedModeStore, intermediateLayerPositionStore\n} from '../stores.js';\nimport {\n  getExtent, getOutputKnot, getInputKnot, gappedColorScale\n} from './draw-utils.js';\nimport {\n  drawOutput\n} from './overview-draw.js';\nimport {\n  drawIntermediateLayerLegend, moveLayerX, addOverlayGradient,\n  drawArrow\n} from './intermediate-utils.js';\nimport { singleConv } from '../utils/cnn.js';\nimport { overviewConfig } from '../config.js';\n\n// Configs\nconst layerColorScales = overviewConfig.layerColorScales;\nconst nodeLength = overviewConfig.nodeLength;\nconst plusSymbolRadius = overviewConfig.plusSymbolRadius;\nconst numLayers = overviewConfig.numLayers;\nconst intermediateColor = overviewConfig.intermediateColor;\nconst kernelRectLength = overviewConfig.kernelRectLength;\nconst svgPaddings = overviewConfig.svgPaddings;\nconst gapRatio = overviewConfig.gapRatio;\nconst overlayRectOffset = overviewConfig.overlayRectOffset;\nconst formater = d3.format('.4f');\nlet isEndOfAnimation = false;\n\n// Shared variables\nlet svg = undefined;\nsvgStore.subscribe( value => {svg = value;} )\n\nlet vSpaceAroundGap = undefined;\nvSpaceAroundGapStore.subscribe( value => {vSpaceAroundGap = value;} )\n\nlet hSpaceAroundGap = undefined;\nhSpaceAroundGapStore.subscribe( value => {hSpaceAroundGap = value;} )\n\nlet cnn = undefined;\ncnnStore.subscribe( value => {cnn = value;} )\n\nlet nodeCoordinate = undefined;\nnodeCoordinateStore.subscribe( value => {nodeCoordinate = value;} )\n\nlet selectedScaleLevel = undefined;\nselectedScaleLevelStore.subscribe( value => {selectedScaleLevel = value;} )\n\nlet cnnLayerRanges = undefined;\ncnnLayerRangesStore.subscribe( value => {cnnLayerRanges = value;} )\n\nlet cnnLayerMinMax = undefined;\ncnnLayerMinMaxStore.subscribe( value => {cnnLayerMinMax = value;} )\n\nlet needRedraw = [undefined, undefined];\nneedRedrawStore.subscribe( value => {needRedraw = value;} )\n\nlet shouldIntermediateAnimate = undefined;\nshouldIntermediateAnimateStore.subscribe(value => {\n  shouldIntermediateAnimate = value;\n})\n\nlet detailedMode = undefined;\ndetailedModeStore.subscribe( value => {detailedMode = value;} )\n\nlet intermediateLayerPosition = undefined;\nintermediateLayerPositionStore.subscribe ( value => {intermediateLayerPosition = value;} )\n\n// let curRightX = 0;\n\n/**\n * Draw the intermediate layer activation heatmaps\n * @param {element} image Neuron heatmap image\n * @param {number} range Colormap range\n * @param {function} colorScale Colormap\n * @param {number} length Image length\n * @param {[[number]]} dataMatrix Heatmap matrix\n */\nconst drawIntermidiateImage = (image, range, colorScale, length,\n  dataMatrix) => {\n  // Set up a buffer convas in order to resize image\n  let imageLength = length;\n  let bufferCanvas = document.createElement(\"canvas\");\n  let bufferContext = bufferCanvas.getContext(\"2d\");\n  bufferCanvas.width = imageLength;\n  bufferCanvas.height = imageLength;\n\n  // Fill image pixel array\n  let imageSingle = bufferContext.getImageData(0, 0, imageLength, imageLength);\n  let imageSingleArray = imageSingle.data;\n\n  for (let i = 0; i < imageSingleArray.length; i+=4) {\n    let pixeIndex = Math.floor(i / 4);\n    let row = Math.floor(pixeIndex / imageLength);\n    let column = pixeIndex % imageLength;\n    let color = d3.rgb(colorScale((dataMatrix[row][column] + range / 2) / range));\n\n    imageSingleArray[i] = color.r;\n    imageSingleArray[i + 1] = color.g;\n    imageSingleArray[i + 2] = color.b;\n    imageSingleArray[i + 3] = 255;\n  }\n\n  // canvas.toDataURL() only exports image in 96 DPI, so we can hack it to have\n  // higher DPI by rescaling the image using canvas magic\n  let largeCanvas = document.createElement('canvas');\n  largeCanvas.width = nodeLength * 3;\n  largeCanvas.height = nodeLength * 3;\n  let largeCanvasContext = largeCanvas.getContext('2d');\n\n  // Use drawImage to resize the original pixel array, and put the new image\n  // (canvas) into corresponding canvas\n  bufferContext.putImageData(imageSingle, 0, 0);\n  largeCanvasContext.drawImage(bufferCanvas, 0, 0, imageLength, imageLength,\n    0, 0, nodeLength * 3, nodeLength * 3);\n  \n  let imageDataURL = largeCanvas.toDataURL();\n  image.attr('xlink:href', imageDataURL);\n\n  // Destory the buffer canvas\n  bufferCanvas.remove();\n  largeCanvas.remove();\n}\n\n/**\n * Create a node group for the intermediate layer\n * @param {number} curLayerIndex Intermediate layer index\n * @param {number} selectedI Clicked node index\n * @param {element} groupLayer Group element\n * @param {number} x Node's x\n * @param {number} y Node's y\n * @param {number} nodeIndex Node's index\n * @param {function} intermediateNodeMouseOverHandler Mouse over handler\n * @param {function} intermediateNodeMouseLeaveHandler Mouse leave handler\n * @param {function} intermediateNodeClicked Mouse click handler\n * @param {bool} interaction Whether support interaction\n */\nconst createIntermediateNode = (curLayerIndex, selectedI, groupLayer, x, y,\n  nodeIndex, stride, intermediateNodeMouseOverHandler,\n  intermediateNodeMouseLeaveHandler, intermediateNodeClicked, interaction) => {\n  let newNode = groupLayer.append('g')\n    .datum(cnn[curLayerIndex - 1][nodeIndex])\n    .attr('class', 'intermediate-node')\n    .attr('cursor', interaction ? 'pointer': 'default')\n    .attr('pointer-events', interaction ? 'all': 'none')\n    .attr('node-index', nodeIndex)\n    .on('mouseover', intermediateNodeMouseOverHandler)\n    .on('mouseleave', intermediateNodeMouseLeaveHandler)\n    .on('click', (d, g, i) => intermediateNodeClicked(d, g, i, selectedI,\n      curLayerIndex));\n  \n  newNode.append('image')\n    .attr('width', nodeLength)\n    .attr('height', nodeLength)\n    .attr('x', x)\n    .attr('y', y);\n\n  // Overlay the image with a mask of many small rectangles\n  let strideTime = Math.floor(nodeLength / stride);\n  let overlayGroup = newNode.append('g')\n    .attr('class', 'overlay-group')\n    .attr('transform', `translate(${x}, ${y})`);\n  \n  for (let i = 0; i < strideTime; i++) {\n    for (let j = 0; j < strideTime; j++) {\n      overlayGroup.append('rect')\n        .attr('class', `mask-overlay mask-${i}-${j}`)\n        .attr('width', stride)\n        .attr('height', stride)\n        .attr('x', i * stride)\n        .attr('y', j * stride)\n        .style('fill', 'var(--light-gray)')\n        .style('stroke', 'var(--light-gray)')\n        .style('opacity', 1);\n    }\n  }\n\n  // Add a rectangle to show the border\n  newNode.append('rect')\n    .attr('class', 'bounding')\n    .attr('width', nodeLength)\n    .attr('height', nodeLength)\n    .attr('x', x)\n    .attr('y', y)\n    .style('fill', 'none')\n    .style('stroke', intermediateColor)\n    .style('stroke-width', 1);\n  \n  return newNode;\n}\n\nconst startOutputAnimation = (kernelGroup, tickTime1D, stride, delay,\n  curLayerIndex) => {\n  const slidingAnimation = () => {\n    let originX = +kernelGroup.attr('data-origin-x');\n    let originY = +kernelGroup.attr('data-origin-y');\n    let oldTick = +kernelGroup.attr('data-tick');\n    let i = (oldTick) % tickTime1D;\n    let j = Math.floor((oldTick) / tickTime1D);\n    let x = originX + i * stride;\n    let y = originY + j * stride;\n    let newTick = (oldTick + 1) % (tickTime1D * tickTime1D);\n\n    // Remove one mask rect at each tick\n    svg.selectAll(`rect.mask-${i}-${j}`)\n      .transition('window-sliding-mask')\n      .delay(delay + 100)\n      .duration(300)\n      .style('opacity', 0);\n\n      kernelGroup.attr('data-tick', newTick)\n      .transition('window-sliding-input')\n      .delay(delay)\n      .duration(200)\n      .attr('transform', `translate(${x}, ${y})`)\n      .on('end', () => {\n        if (newTick === 0) {\n          /* Uncomment to wrap the sliding\n          svg.selectAll(`rect.mask-overlay`)\n            .transition('window-sliding-mask')\n            .delay(delay - 200)\n            .duration(300)\n            .style('opacity', 1);\n          */\n\n          // Stop the animation\n          // Be careful with animation racing so call this function here instead\n          // of under selectALL\n          if (!isEndOfAnimation) {\n            animationButtonClicked(curLayerIndex);\n          }\n        }\n        if (shouldIntermediateAnimate) {\n          slidingAnimation();\n        }\n      });\n  }\n  slidingAnimation();\n}\n\nconst startIntermediateAnimation = (kernelGroupInput, kernelGroupResult,\n  tickTime1D, stride) => {\n  let delay = 200;\n  const slidingAnimation = () => {\n    let originX = +kernelGroupInput.attr('data-origin-x');\n    let originY = +kernelGroupInput.attr('data-origin-y');\n    let originXResult = +kernelGroupResult.attr('data-origin-x');\n    let oldTick = +kernelGroupInput.attr('data-tick');\n    let i = (oldTick) % tickTime1D;\n    let j = Math.floor((oldTick) / tickTime1D);\n    let x = originX + i * stride;\n    let y = originY + j * stride;\n    let xResult = originXResult + (oldTick % tickTime1D) * stride;\n    let newTick = (oldTick + 1) % (tickTime1D * tickTime1D);\n\n    // Remove one mask rect at each tick\n    svg.selectAll(`rect.mask-${i}-${j}`)\n      .transition('window-sliding-mask')\n      .delay(delay + 100)\n      .duration(300)\n      .style('opacity', 0);\n\n    kernelGroupInput.attr('data-tick', newTick)\n      .transition('window-sliding-input')\n      .delay(delay)\n      .duration(200)\n      .attr('transform', `translate(${x}, ${y})`);\n\n    kernelGroupResult.attr('data-tick', newTick)\n      .transition('window-sliding-result')\n      .delay(delay)\n      .duration(200)\n      .attr('transform', `translate(${xResult}, ${y})`)\n      .on('end', () => {\n        /* Uncomment to wrap the sliding\n        if (newTick === 0) {\n          svg.selectAll(`rect.mask-overlay`)\n            .transition('window-sliding-mask')\n            .delay(delay - 200)\n            .duration(300)\n            .style('opacity', 1);\n        }\n        */\n        if (shouldIntermediateAnimate) {\n          slidingAnimation();\n        }\n      });\n  }\n  slidingAnimation();\n}\n\nconst animationButtonClicked = (curLayerIndex) => {\n  if (d3.event !== null) {\n    d3.event.stopPropagation();\n  }\n  \n  let delay = 200;\n  let tickTime1D = nodeLength / (kernelRectLength * 3);\n  let stride = kernelRectLength * 3; \n\n  if (isEndOfAnimation) {\n    // Start the animation\n    shouldIntermediateAnimateStore.set(true);\n\n    // Show kernel\n    svg.selectAll('.kernel-clone')\n      .transition()\n      .duration(300)\n      .style('opacity', 1)\n\n    // Restore the mask\n    svg.selectAll(`rect.mask-overlay`)\n      .transition()\n      .duration(300)\n      .style('opacity', 1);\n\n    // Start the intermediate animation\n    for (let i  = 0; i < nodeCoordinate[curLayerIndex - 1].length; i++) {\n      startIntermediateAnimation(d3.select(`.kernel-input-${i}`),\n        d3.select(`.kernel-result-${i}`), tickTime1D, stride);\n    }\n\n    // Start the output animation\n    startOutputAnimation(d3.select('.kernel-output'),\n      tickTime1D, stride, delay, curLayerIndex);\n    \n    // Change the flow edge style\n    svg.selectAll('path.flow-edge')\n      .attr('stroke-dasharray', '4 2')\n      .attr('stroke-dashoffset', 0)\n      .each((d, i, g) => animateEdge(d, i, g, 0 - 1000));\n\n    // Change button icon\n    svg.select('.animation-control-button')\n      .attr('xlink:href', 'PUBLIC_URL/assets/img/fast_forward.svg');\n    \n    isEndOfAnimation = false;\n\n  } else {\n    // End the animation\n    shouldIntermediateAnimateStore.set(false);\n    \n    // Show all intermediate and output results\n    svg.selectAll(`rect.mask-overlay`)\n      .transition('skip')\n      .duration(600)\n      .style('opacity', 0);\n    \n    // Move kernel to the beginning to prepare for the next animation\n    let kernelClones = svg.selectAll('.kernel-clone');\n    kernelClones.attr('data-tick', 0)\n      .transition('skip')\n      .duration(300)\n      .style('opacity', 0)\n      .on('end', (d, i, g) => {\n        let element = d3.select(g[i]);\n        let originX = +element.attr('data-origin-x');\n        let originY = +element.attr('data-origin-y');\n        element.attr('transform', `translate(${originX}, ${originY})`);\n      });\n    \n    // Change flow edge style\n    svg.selectAll('path.flow-edge')\n      .interrupt()\n      .attr('stroke-dasharray', '0 0');\n    \n    // Change button icon\n    svg.select('.animation-control-button')\n      .attr('xlink:href', 'PUBLIC_URL/assets/img/redo.svg');\n    \n    isEndOfAnimation = true;\n  }\n}\n\nconst animateEdge = (d, i, g, dashoffset) => {\n  let curPath = d3.select(g[i]);\n  curPath.transition()\n    .duration(60000)\n    .ease(d3.easeLinear)\n    .attr('stroke-dashoffset', dashoffset)\n    .on('end', (d, i, g) => {\n      if (shouldIntermediateAnimate) {\n        animateEdge(d, i, g, dashoffset - 2000);\n      }\n    });\n}\n\n/**\n * Draw one intermediate layer\n * @param {number} curLayerIndex \n * @param {number} leftX X value of intermediate layer left border\n * @param {number} rightX X value of intermediate layer right border\n * @param {number} rightStart X value of right component starting anchor\n * @param {number} intermediateGap The inner gap\n * @param {number} d Clicked node bounded data\n * @param {number} i Clicked node index\n * @param {function} intermediateNodeMouseOverHandler Mouse over handler\n * @param {function} intermediateNodeMouseLeaveHandler Mouse leave handler\n * @param {function} intermediateNodeClicked Mouse click handler\n */\nconst drawIntermediateLayer = (curLayerIndex, leftX, rightX, rightStart,\n  intermediateGap, d, i, intermediateNodeMouseOverHandler,\n  intermediateNodeMouseLeaveHandler, intermediateNodeClicked) => {\n  \n  // curRightX = rightStart;\n\n  // Add the intermediate layer\n  let intermediateLayer = svg.append('g')\n    .attr('class', 'intermediate-layer')\n    .style('opacity', 0);\n  \n  // Recovert the animation counter\n  isEndOfAnimation = false;\n  \n  // Tried to add a rectangle to block the intermediate because of webkit's\n  // horrible support (decade old bug) for foreignObject. It doesnt work either.\n  // https://bugs.webkit.org/show_bug.cgi?id=23113\n  // (1). ForeignObject's inside position is wrong on webkit\n  // (2). 'opacity' of ForeignObject doesn't work on webkit\n  // (3). ForeignObject always show up at the front regardless the svg\n  //      stacking order on webkit\n\n  let intermediateX1 = leftX + nodeLength + intermediateGap;\n  let intermediateX2 = intermediateX1 + nodeLength + intermediateGap * 1.5;\n\n  let range = cnnLayerRanges[selectedScaleLevel][curLayerIndex];\n  let colorScale = layerColorScales[d.type];\n  let intermediateMinMax = [];\n  \n  // Copy the previsious layer to construct foreignObject placeholder\n  // Also add edges from/to the intermediate layer in this loop\n  let linkData = [];\n\n  // Accumulate the intermediate sum\n  // let itnermediateSumMatrix = init2DArray(d.output.length,\n  //  d.output.length, 0);\n\n  // Compute the min max of all kernel weights in the intermediate layer\n  let kernelExtents = d.inputLinks.map(link => getExtent(link.weight));\n  let kernelExtent = kernelExtents.reduce((acc, cur) => {\n    return [Math.min(acc[0], cur[0]), Math.max(acc[1], cur[1])];\n  })\n  let kernelRange = 2 * (Math.round(\n    Math.max(...kernelExtent.map(Math.abs)) * 1000) / 1000);\n  let kernelColorGap = 0.2;\n\n  // Compute stride for the kernel animation\n  let stride = kernelRectLength * 3; \n\n  // Also add the overlay mask on the output node\n  let outputY = nodeCoordinate[curLayerIndex][i].y;\n  let curNode = svg.select(`#layer-${curLayerIndex}-node-${i}`);\n  let outputOverlayGroup = curNode.append('g')\n    .attr('class', 'overlay-group')\n    .attr('transform', `translate(${rightX}, ${outputY})`);\n\n  let strideTime = Math.floor(nodeLength / stride);\n  \n  for (let i = 0; i < strideTime; i++) {\n    for (let j = 0; j < strideTime; j++) {\n      outputOverlayGroup.append('rect')\n        .attr('class', `mask-overlay mask-${i}-${j}`)\n        .attr('width', stride)\n        .attr('height', stride)\n        .attr('x', i * stride)\n        .attr('y', j * stride)\n        .style('fill', 'var(--light-gray)')\n        .style('stroke', 'var(--light-gray)')\n        .style('opacity', 1);\n    }\n  }\n\n  // Make sure the bounding box is on top of other things\n  curNode.select('rect.bounding').raise();\n\n  // Add sliding kernel for the output node\n  let kernelGroup = intermediateLayer.append('g')\n    .attr('class', `kernel kernel-output kernel-clone`)\n    .attr('transform', `translate(${rightX}, ${outputY})`);\n\n  kernelGroup.append('rect')\n    .attr('x', 0)\n    .attr('y', 0)\n    .attr('width', kernelRectLength * 3)\n    .attr('height', kernelRectLength * 3)\n    .attr('fill', 'none')\n    .attr('stroke', intermediateColor);\n  \n  kernelGroup.attr('data-tick', 0)\n    .attr('data-origin-x', rightX)\n    .attr('data-origin-y', outputY);\n\n  let delay = 200;\n  let tickTime1D = nodeLength / (kernelRectLength * 3);\n\n  startOutputAnimation(kernelGroup, tickTime1D, stride, delay, curLayerIndex);\n\n  // First intermediate layer\n  nodeCoordinate[curLayerIndex - 1].forEach((n, ni) => {\n\n    // Compute the intermediate value\n    let inputMatrix = cnn[curLayerIndex - 1][ni].output;\n    let kernelMatrix = cnn[curLayerIndex][i].inputLinks[ni].weight;\n    let interMatrix = singleConv(inputMatrix, kernelMatrix);\n\n    // Compute the intermediate layer min max\n    intermediateMinMax.push(getExtent(interMatrix));\n\n    // Update the intermediate sum\n    // itnermediateSumMatrix = matrixAdd(itnermediateSumMatrix, interMatrix);\n\n    // Layout the canvas and rect\n    let newNode = createIntermediateNode(curLayerIndex, i, intermediateLayer,\n      intermediateX1, n.y, ni, stride, intermediateNodeMouseOverHandler,\n      intermediateNodeMouseLeaveHandler, intermediateNodeClicked, true);\n    \n    // Draw the image\n    let image = newNode.select('image');\n    drawIntermidiateImage(image, range, colorScale, d.output.length,\n      interMatrix);      \n\n    // Edge: input -> intermediate1\n    linkData.push({\n      source: getOutputKnot({x: leftX, y: n.y}),\n      target: getInputKnot({x: intermediateX1, y: n.y}),\n      name: `input-${ni}-inter1-${ni}`\n    });\n\n    // Edge: intermediate1 -> intermediate2-1\n    linkData.push({\n      source: getOutputKnot({x: intermediateX1, y: n.y}),\n      target: getInputKnot({x: intermediateX2,\n        y: nodeCoordinate[curLayerIndex][i].y}),\n      name: `inter1-${ni}-inter2-1`\n    });\n\n    // Create a small kernel illustration\n    // Here we minus 2 because of no padding\n    // let tickTime1D = nodeLength / (kernelRectLength) - 2;\n    let kernelRectX = leftX - kernelRectLength * 3 * 2;\n    let kernelGroup = intermediateLayer.append('g')\n      .attr('class', `kernel kernel-${ni}`)\n      .attr('transform', `translate(${kernelRectX}, ${n.y})`);\n\n    let weightText = 'Kernel weights: [';\n    let f2 = d3.format('.2f');\n    for (let r = 0; r < kernelMatrix.length; r++) {\n      for (let c = 0; c < kernelMatrix[0].length; c++) {\n        kernelGroup.append('rect')\n          .attr('class', 'kernel')\n          .attr('x', kernelRectLength * c)\n          .attr('y', kernelRectLength * r)\n          .attr('width', kernelRectLength)\n          .attr('height', kernelRectLength)\n          .attr('fill', gappedColorScale(layerColorScales.weight, kernelRange,\n            kernelMatrix[r][c], kernelColorGap));\n\n        let sep = '';\n        if (c === 0 && r == 0) { sep = ''; }\n        else if (c === 0) { sep = '; '; }\n        else { sep = ', '; }\n        weightText = weightText.concat(sep, `${f2(kernelMatrix[r][c])}`);\n      }\n    }\n    weightText = weightText.concat(']');\n\n    kernelGroup.append('rect')\n      .attr('x', 0)\n      .attr('y', 0)\n      .attr('width', kernelRectLength * 3)\n      .attr('height', kernelRectLength * 3)\n      .attr('fill', 'none')\n      .attr('stroke', intermediateColor);\n    \n    kernelGroup.style('pointer-events', 'all')\n      .style('cursor', 'crosshair')\n      .on('mouseover', () => {\n        hoverInfoStore.set( {show: true, text: weightText} );\n      })\n      .on('mouseleave', () => {\n        hoverInfoStore.set( {show: false, text: weightText} );\n      })\n      .on('click', () => {d3.event.stopPropagation()});\n\n    // Sliding the kernel on the input channel and result channel at the same\n    // time\n    let kernelGroupInput = kernelGroup.clone(true)\n      .style('pointer-events', 'none')\n      .style('cursor', 'pointer')\n      .classed('kernel-clone', true)\n      .classed(`kernel-input-${ni}`, true);\n\n    kernelGroupInput.style('opacity', 0.9)\n      .selectAll('rect.kernel')\n      .style('opacity', 0.7);\n\n    kernelGroupInput.attr('transform', `translate(${leftX}, ${n.y})`)\n      .attr('data-tick', 0)\n      .attr('data-origin-x', leftX)\n      .attr('data-origin-y', n.y);\n\n    let kernelGroupResult = kernelGroup.clone(true)\n      .style('pointer-events', 'none')\n      .style('cursor', 'pointer')\n      .classed('kernel-clone', true)\n      .classed(`kernel-result-${ni}`, true);\n\n    kernelGroupResult.style('opacity', 0.9)\n      .selectAll('rect.kernel')\n      .style('fill', 'none');\n\n    kernelGroupResult.attr('transform',\n      `translate(${intermediateX1}, ${n.y})`)\n      .attr('data-origin-x', intermediateX1)\n      .attr('data-origin-y', n.y);\n    \n    startIntermediateAnimation(kernelGroupInput, kernelGroupResult, tickTime1D,\n      stride);\n  });\n\n  // Aggregate the intermediate min max\n  let aggregatedExtent = intermediateMinMax.reduce((acc, cur) => {\n    return [Math.min(acc[0], cur[0]), Math.max(acc[1], cur[1])];\n  })\n  let aggregatedMinMax = {min: aggregatedExtent[0], max: aggregatedExtent[1]};\n\n  // Draw the plus operation symbol\n  let symbolY = nodeCoordinate[curLayerIndex][i].y + nodeLength / 2;\n  let symbolRectHeight = 1;\n  let symbolGroup = intermediateLayer.append('g')\n    .attr('class', 'plus-symbol')\n    .attr('transform', `translate(${intermediateX2 + plusSymbolRadius}, ${symbolY})`);\n  \n  symbolGroup.append('rect')\n    .attr('x', -plusSymbolRadius)\n    .attr('y', -plusSymbolRadius)\n    .attr('width', 2 * plusSymbolRadius)\n    .attr('height', 2 * plusSymbolRadius)\n    .attr('rx', 3)\n    .attr('ry', 3)\n    .style('fill', 'none')\n    .style('stroke', intermediateColor);\n  \n  symbolGroup.append('rect')\n    .attr('x', -(plusSymbolRadius - 3))\n    .attr('y', -symbolRectHeight / 2)\n    .attr('width', 2 * (plusSymbolRadius - 3))\n    .attr('height', symbolRectHeight)\n    .style('fill', intermediateColor);\n\n  symbolGroup.append('rect')\n    .attr('x', -symbolRectHeight / 2)\n    .attr('y', -(plusSymbolRadius - 3))\n    .attr('width', symbolRectHeight)\n    .attr('height', 2 * (plusSymbolRadius - 3))\n    .style('fill', intermediateColor);\n\n  // Place the bias rectangle below the plus sign if user clicks the firrst\n  // conv node\n  if (i == 0) {\n    // Add bias symbol to the plus symbol\n    symbolGroup.append('circle')\n        .attr('cx', 0)\n        .attr('cy', nodeLength / 2 + kernelRectLength)\n        .attr('r', 4)\n        .style('stroke', intermediateColor)\n        .style('cursor', 'crosshair')\n        .style('fill', gappedColorScale(layerColorScales.weight, kernelRange,\n          d.bias, kernelColorGap))\n        .on('mouseover', () => {\n          hoverInfoStore.set( {show: true, text: `Bias: ${formater(d.bias)}`} );\n        })\n        .on('mouseleave', () => {\n          hoverInfoStore.set( {show: false, text: `Bias: ${formater(d.bias)}`} );\n        });\n\n    // Link from bias to the plus symbol\n    linkData.push({\n      source: {x: intermediateX2 + plusSymbolRadius,\n        y: nodeCoordinate[curLayerIndex][i].y + nodeLength},\n      target: {x: intermediateX2 + plusSymbolRadius,\n        y: nodeCoordinate[curLayerIndex][i].y + nodeLength / 2 + plusSymbolRadius},\n      name: `bias-plus`\n    });\n  } else {\n    // Add bias symbol to the plus symbol\n    symbolGroup.append('circle')\n      .attr('cx', 0)\n      .attr('cy', -nodeLength / 2 - kernelRectLength)\n      .attr('r', 4)\n      .style('stroke', intermediateColor)\n      .style('cursor', 'crosshair')\n      .style('fill', gappedColorScale(layerColorScales.weight, kernelRange,\n        d.bias, kernelColorGap))\n      .on('mouseover', () => {\n        hoverInfoStore.set( {show: true, text: `Bias: ${formater(d.bias)}`} );\n      })\n      .on('mouseleave', () => {\n        hoverInfoStore.set( {show: false, text: `Bias: ${formater(d.bias)}`} );\n      });\n    \n    // Link from bias to the plus symbol\n    linkData.push({\n      source: {x: intermediateX2 + plusSymbolRadius,\n        y: nodeCoordinate[curLayerIndex][i].y},\n      target: {x: intermediateX2 + plusSymbolRadius,\n        y: nodeCoordinate[curLayerIndex][i].y + nodeLength / 2 - plusSymbolRadius},\n      name: `bias-plus`\n    });\n  }\n\n  // Link from the plus symbol to the output\n  linkData.push({\n    source: getOutputKnot({x: intermediateX2 + 2 * plusSymbolRadius - nodeLength,\n      y: nodeCoordinate[curLayerIndex][i].y}),\n    target: getInputKnot({x: rightX,\n      y: nodeCoordinate[curLayerIndex][i].y}),\n    name: `symbol-output`\n  });\n  \n  // Output -> next layer\n  linkData.push({\n    source: getOutputKnot({x: rightX,\n      y: nodeCoordinate[curLayerIndex][i].y}),\n    target: getInputKnot({x: rightStart,\n      y: nodeCoordinate[curLayerIndex][i].y}),\n    name: `output-next`\n  });\n\n  // Draw the layer label\n  intermediateLayer.append('g')\n    .attr('class', 'layer-intermediate-label layer-label')\n    .attr('transform', () => {\n      let x = intermediateX1 + nodeLength / 2;\n      let y = (svgPaddings.top + vSpaceAroundGap) / 2 + 5;\n      return `translate(${x}, ${y})`;\n    })\n    .classed('hidden', detailedMode)\n    .append('text')\n    .style('text-anchor', 'middle')\n    .style('dominant-baseline', 'middle')\n    .style('font-weight', 800)\n    .style('opacity', '0.8')\n    .text('intermediate');\n  \n  intermediateLayer.append('g')\n    .attr('class', 'animation-control')\n    .attr('transform', () => {\n      let x = intermediateX1 + nodeLength / 2;\n      let y = (svgPaddings.top + vSpaceAroundGap) / 2 - 4;\n      return `translate(${x}, ${y})`;\n    })\n    .on('click', () => animationButtonClicked(curLayerIndex))\n    .append('image')\n    .attr('class', 'animation-control-button')\n    .attr('xlink:href', 'PUBLIC_URL/assets/img/fast_forward.svg')\n    .attr('x', 50)\n    .attr('y', 0)\n    .attr('height', 13)\n    .attr('width', 13);\n\n  // Draw the detailed model layer label\n  intermediateLayer.append('g')\n    .attr('class', 'layer-intermediate-label layer-detailed-label')\n    .attr('transform', () => {\n      let x = intermediateX1 + nodeLength / 2;\n      let y = (svgPaddings.top + vSpaceAroundGap) / 2 - 5;\n      return `translate(${x}, ${y})`;\n    })\n    .classed('hidden', !detailedMode)\n    .append('text')\n    .style('text-anchor', 'middle')\n    .style('dominant-baseline', 'middle')\n    .style('opacity', '0.7')\n    .style('font-weight', 800)\n    .append('tspan')\n    .text('intermediate')\n    .append('tspan')\n    .style('font-size', '8px')\n    .style('font-weight', 'normal')\n    .attr('x', 0)\n    .attr('dy', '1.5em')\n    .text(`(${cnn[curLayerIndex][0].output.length},\n      ${cnn[curLayerIndex][0].output[0].length},\n      ${cnn[curLayerIndex].length})`);\n\n  // Draw the edges\n  let linkGen = d3.linkHorizontal()\n    .x(d => d.x)\n    .y(d => d.y);\n  \n  let edgeGroup = intermediateLayer.append('g')\n    .attr('class', 'edge-group')\n    .lower();\n  \n  let dashoffset = 0;\n\n  edgeGroup.selectAll('path')\n    .data(linkData)\n    .enter()\n    .append('path')\n    .classed('flow-edge', d => d.name !== 'output-next')\n    .attr('id', d => `edge-${d.name}`)\n    .attr('d', d => linkGen({source: d.source, target: d.target}))\n    .style('fill', 'none')\n    .style('stroke-width', 1)\n    .style('stroke', intermediateColor);\n\n  edgeGroup.select('#edge-output-next')\n    .style('opacity', 0.1);\n  \n  edgeGroup.selectAll('path.flow-edge')\n    .attr('stroke-dasharray', '4 2')\n    .attr('stroke-dashoffset', 0)\n    .each((d, i, g) => animateEdge(d, i, g, dashoffset - 1000));\n  \n  return {intermediateLayer: intermediateLayer,\n    intermediateMinMax: aggregatedMinMax,\n    kernelRange: kernelRange,\n    kernelMinMax: {min: kernelExtent[0], max: kernelExtent[1]}};\n}\n\n/**\n * Add an annotation for the kernel and the sliding\n * @param {object} arg \n * {\n *  leftX: X value of the left border of intermedaite layer\n *  group: element group\n *  intermediateGap: the inner gap of intermediate layer\n *  isFirstConv: if this intermediate layer is after the first layer\n *  i: index of the selected node\n * }\n */\nconst drawIntermediateLayerAnnotation = (arg) => {\n  let leftX = arg.leftX,\n    curLayerIndex = arg.curLayerIndex,\n    group = arg.group,\n    intermediateGap = arg.intermediateGap,\n    isFirstConv = arg.isFirstConv,\n    i = arg.i;\n\n  let kernelAnnotation = group.append('g')\n    .attr('class', 'kernel-annotation');\n  \n  kernelAnnotation.append('text')\n    .text('Kernel')\n    .attr('class', 'annotation-text')\n    .attr('x', leftX - 2.5 * kernelRectLength * 3)\n    .attr('y', nodeCoordinate[curLayerIndex - 1][0].y + kernelRectLength * 3)\n    .style('dominant-baseline', 'baseline')\n    .style('text-anchor', 'end');\n\n  let sliderX, sliderY, arrowSX, arrowSY, dr;\n  let sliderX2, sliderY2, arrowSX2, arrowSY2, dr2, arrowTX2, arrowTY2;\n  \n  if (isFirstConv) {\n    sliderX = leftX;\n    sliderY = nodeCoordinate[curLayerIndex - 1][0].y + nodeLength +\n      kernelRectLength * 3;\n    arrowSX = leftX - 5;\n    arrowSY = nodeCoordinate[curLayerIndex - 1][0].y + nodeLength +\n      kernelRectLength * 3 + 5;\n    dr = 20;\n\n    sliderX2 = leftX;\n      sliderY2 = nodeCoordinate[curLayerIndex - 1][1].y + nodeLength +\n    kernelRectLength * 3;\n    arrowSX2 = leftX - kernelRectLength * 3;\n    arrowSY2 = nodeCoordinate[curLayerIndex - 1][1].y + nodeLength + 15;\n    arrowTX2 = leftX - 13;\n    arrowTY2 =  nodeCoordinate[curLayerIndex - 1][1].y + 15;\n    dr2 = 35;\n  } else {\n    sliderX = leftX - 3 * kernelRectLength * 3;\n    sliderY = nodeCoordinate[curLayerIndex - 1][0].y + nodeLength / 3;\n    arrowSX = leftX - 2 * kernelRectLength * 3 - 5;\n    arrowSY = nodeCoordinate[curLayerIndex - 1][0].y + nodeLength - 10;\n    dr = 50;\n\n    sliderX2 = leftX - 3 * kernelRectLength * 3;\n    sliderY2 = nodeCoordinate[curLayerIndex - 1][2].y - 3;\n    arrowTX2 = leftX - kernelRectLength * 3 - 4;\n    arrowTY2 = nodeCoordinate[curLayerIndex - 1][2].y + kernelRectLength * 3 + 6;\n    arrowSX2 = leftX - kernelRectLength * 3 - 13;\n    arrowSY2 = nodeCoordinate[curLayerIndex - 1][2].y + 26;\n    dr2 = 20;\n  }\n\n  let slideText = kernelAnnotation.append('text')\n    .attr('x', sliderX)\n    .attr('y', sliderY)\n    .attr('class', 'annotation-text')\n    .style('dominant-baseline', 'hanging')\n    .style('text-anchor', isFirstConv ? 'start' : 'end');\n  \n  slideText.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .text('Slide kernel over input channel');\n\n  slideText.append('tspan')\n    .attr('x', sliderX)\n    .attr('dy', '1em')\n    .style('dominant-baseline', 'hanging')\n    .text('to get intermediate result');\n\n  // slideText.append('tspan')\n  //   .attr('x', sliderX)\n  //   .attr('dy', '1em')\n  //   .style('dominant-baseline', 'hanging')\n  //   .text('');\n\n  slideText.append('tspan')\n    .attr('x', sliderX)\n    .attr('dy', '1.2em')\n    .style('dominant-baseline', 'hanging')\n    .style('font-weight', 700)\n    .text('Click ');\n  \n  slideText.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .style('font-weight', 400)\n    .text('to learn more')\n\n  drawArrow({\n    group: group,\n    tx: leftX - 7,\n    ty: nodeCoordinate[curLayerIndex - 1][0].y + nodeLength / 2,\n    sx: arrowSX,\n    sy: arrowSY,\n    hFlip: !isFirstConv,\n    dr: dr,\n    marker: 'marker'\n  });\n\n  // Add kernel annotation\n  let slideText2 = kernelAnnotation.append('text')\n    .attr('x', sliderX2)\n    .attr('y', sliderY2)\n    .attr('class', 'annotation-text')\n    .style('dominant-baseline', 'hanging')\n    .style('text-anchor', isFirstConv ? 'start' : 'end');\n\n  slideText2.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .text('Each input chanel');\n\n  slideText2.append('tspan')\n    .attr('x', sliderX)\n    .attr('dy', '1em')\n    .style('dominant-baseline', 'hanging')\n    .text('gets a different kernel');\n\n  slideText2.append('tspan')\n    .attr('x', sliderX)\n    .attr('dy', '1.3em')\n    .style('font-weight', 700)\n    .style('dominant-baseline', 'hanging')\n    .text('Hover over ');\n\n  slideText2.append('tspan')\n    .style('font-weight', 400)\n    .style('dominant-baseline', 'hanging')\n    .text('to see value!')\n\n  drawArrow({\n    group: group,\n    tx: arrowTX2,\n    ty: arrowTY2,\n    sx: arrowSX2,\n    sy: arrowSY2,\n    dr: dr2,\n    hFlip: !isFirstConv,\n    marker: 'marker'\n  });\n\n\n  // Add annotation for the sum operation\n  let plusAnnotation = group.append('g')\n    .attr('class', 'plus-annotation');\n  \n  let intermediateX2 = leftX + 2 * nodeLength + 2.5 * intermediateGap;\n  let textX = intermediateX2;\n  let textY = nodeCoordinate[curLayerIndex][i].y + nodeLength +\n      kernelRectLength * 3;\n  \n  // Special case 1: first node\n  if (i === 0) { textX += 30; }\n\n  // Special case 2: last node \n  if (i === 9) {\n    textX = intermediateX2 + plusSymbolRadius - 10;\n    textY -= 2.5 * nodeLength;\n  }\n\n  let plusText = plusAnnotation.append('text')\n    .attr('x', textX)\n    .attr('y', textY)\n    .attr('class', 'annotation-text')\n    .style('dominant-baseline', 'hanging')\n    .style('text-anchor', 'start');\n  \n  plusText.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .text('Add up all intermediate');\n  \n  plusText.append('tspan')\n    .attr('x', textX)\n    .attr('dy', '1em')\n    .style('dominant-baseline', 'hanging')\n    .text('results and then add bias');\n  \n  if (i === 9) {\n    drawArrow({\n      group: group,\n      sx: intermediateX2 + 50,\n      sy: nodeCoordinate[curLayerIndex][i].y - (nodeLength / 2 + kernelRectLength * 2),\n      tx: intermediateX2 + 2 * plusSymbolRadius + 5,\n      ty: nodeCoordinate[curLayerIndex][i].y + nodeLength / 2 - plusSymbolRadius,\n      dr: 50,\n      hFlip: false,\n      marker: 'marker-alt'\n    });\n  } else {\n    drawArrow({\n      group: group,\n      sx: intermediateX2 + 35,\n      sy: nodeCoordinate[curLayerIndex][i].y + nodeLength + kernelRectLength * 2,\n      tx: intermediateX2 + 2 * plusSymbolRadius + 5,\n      ty: nodeCoordinate[curLayerIndex][i].y + nodeLength / 2 + plusSymbolRadius,\n      dr: 30,\n      hFlip: true,\n      marker: 'marker-alt'\n    });\n  }\n\n  // Add annotation for the bias\n  let biasTextY = nodeCoordinate[curLayerIndex][i].y;\n  if (i === 0) {\n    biasTextY += nodeLength + 3 * kernelRectLength;\n  } else {\n    biasTextY -= 2 * kernelRectLength + 5;\n  }\n  plusAnnotation.append('text')\n    .attr('class', 'annotation-text')\n    .attr('x', intermediateX2 + plusSymbolRadius)\n    .attr('y', biasTextY)\n    .style('text-anchor', 'middle')\n    .style('dominant-baseline', i === 0 ? 'hanging' : 'baseline')\n    .text('Bias');\n}\n\n/**\n * Append a filled rectangle under a pair of nodes.\n * @param {number} curLayerIndex Index of the selected layer\n * @param {number} i Index of the selected node\n * @param {number} leftX X value of the left border of intermediate layer\n * @param {number} intermediateGap Inner gap of this intermediate layer\n * @param {number} padding Padding around the rect\n * @param {function} intermediateNodeMouseOverHandler Mouse over handler\n * @param {function} intermediateNodeMouseLeaveHandler Mouse leave handler\n * @param {function} intermediateNodeClicked Mouse click handler\n */\nconst addUnderneathRect = (curLayerIndex, i, leftX,\n  intermediateGap, padding, intermediateNodeMouseOverHandler,\n  intermediateNodeMouseLeaveHandler, intermediateNodeClicked) => {\n  // Add underneath rects\n  let underGroup = svg.select('g.underneath');\n\n  for (let n = 0; n < cnn[curLayerIndex - 1].length; n++) {\n    underGroup.append('rect')\n      .attr('class', 'underneath-gateway')\n      .attr('id', `underneath-gateway-${n}`)\n      .attr('x', leftX - padding)\n      .attr('y', nodeCoordinate[curLayerIndex - 1][n].y - padding)\n      .attr('width', (2 * nodeLength + intermediateGap) + 2 * padding)\n      .attr('height', nodeLength + 2 * padding)\n      .attr('rx', 10)\n      .style('fill', 'rgba(160, 160, 160, 0.2)')\n      .style('opacity', 0);\n    \n    // Register new events for input layer nodes\n    svg.select(`g#layer-${curLayerIndex - 1}-node-${n}`)\n      .style('pointer-events', 'all')\n      .style('cursor', 'pointer')\n      .on('mouseover', intermediateNodeMouseOverHandler)\n      .on('mouseleave', intermediateNodeMouseLeaveHandler)\n      .on('click', (d, ni, g) => intermediateNodeClicked(d, ni, g,\n        i, curLayerIndex));\n      // .on('click', (d, i) => {console.log(i)});\n  }\n  underGroup.lower();\n}\n\n/**\n * Add an overlaying rect\n * @param {string} gradientName Gradient name of overlay rect\n * @param {number} x X value of the overlaying rect\n * @param {number} y Y value of the overlaying rect\n * @param {number} width Rect width\n * @param {number} height Rect height\n */\nexport const addOverlayRect = (gradientName, x, y, width, height) => {\n  if (svg.select('.intermediate-layer-overlay').empty()) {\n    svg.append('g').attr('class', 'intermediate-layer-overlay');\n  }\n\n  let intermediateLayerOverlay = svg.select('.intermediate-layer-overlay');\n\n  let overlayRect = intermediateLayerOverlay.append('rect')\n    .attr('class', 'overlay')\n    .style('fill', `url(#${gradientName})`)\n    .style('stroke', 'none')\n    .attr('width', width)\n    .attr('height', height)\n    .attr('x', x)\n    .attr('y', y)\n    .style('opacity', 0);\n  \n  overlayRect.transition('move')\n    .duration(800)\n    .ease(d3.easeCubicInOut)\n    .style('opacity', 1);\n}\n\n/**\n * Redraw the layer if needed (entering the intermediate view to make sure\n * all layers have the same color scale)\n * @param {number} curLayerIndex Index of the selected layer\n * @param {number} i Index of the selected node\n */\nconst redrawLayerIfNeeded = (curLayerIndex, i) => {\n  // Determine the range for this layerview, and redraw the layer with\n  // smaller range so all layers have the same range\n  let rangePre = cnnLayerRanges[selectedScaleLevel][curLayerIndex - 1];\n  let rangeCur = cnnLayerRanges[selectedScaleLevel][curLayerIndex];\n  let range = Math.max(rangePre, rangeCur);\n\n  if (rangePre > rangeCur) {\n    // Redraw the current layer (selected node)\n    svg.select(`g#layer-${curLayerIndex}-node-${i}`)\n      .select('image.node-image')\n      .each((d, g, i) => drawOutput(d, g, i, range));\n    \n    // Record the change so we will re-redraw the layer when user quits\n    // the intermediate view\n    needRedraw = [curLayerIndex, i];\n    needRedrawStore.set(needRedraw);\n    \n  } else if (rangePre < rangeCur) {\n    // Redraw the previous layer (whole layer)\n    svg.select(`g#cnn-layer-group-${curLayerIndex - 1}`)\n      .selectAll('image.node-image')\n      .each((d, g, i) => drawOutput(d, g, i, range));\n\n    // Record the change so we will re-redraw the layer when user quits\n    // the intermediate view\n    needRedraw = [curLayerIndex - 1, undefined];\n    needRedrawStore.set(needRedraw);\n  }\n\n  // Compute the min, max value of all nodes in pre-layer and the selected\n  // node of cur-layer\n  let min = cnnLayerMinMax[curLayerIndex - 1].min,\n    max = cnnLayerMinMax[curLayerIndex - 1].max;\n\n  // Selected node\n  let n = cnn[curLayerIndex][i];\n  for (let r = 0; r < n.output.length; r++) {\n    for (let c = 0; c < n.output[0].length; c++) {\n      if (n.output[r][c] < min) { min = n.output[r][c]; }\n      if (n.output[r][c] > max) { max = n.output[r][c]; }\n    }\n  }\n\n  return {range: range, minMax: {min: min, max: max}};\n}\n\n/**\n * Draw the intermediate layer before conv_1_1\n * @param {number} curLayerIndex Index of the selected layer\n * @param {object} d Bounded d3 data\n * @param {number} i Index of the selected node\n * @param {number} width CNN group width\n * @param {number} height CNN group height\n * @param {function} intermediateNodeMouseOverHandler mouse over handler\n * @param {function} intermediateNodeMouseLeaveHandler mouse leave handler\n * @param {function} intermediateNodeClicked node clicking handler\n */\nexport const drawConv1 = (curLayerIndex, d, i, width, height,\n  intermediateNodeMouseOverHandler, intermediateNodeMouseLeaveHandler,\n  intermediateNodeClicked) => {\n  // Compute the target location\n  let targetX = nodeCoordinate[curLayerIndex - 1][0].x + 2 * nodeLength +\n    2 * hSpaceAroundGap * gapRatio + plusSymbolRadius * 2;\n  let intermediateGap = (hSpaceAroundGap * gapRatio * 2) / 3;\n  let leftX = nodeCoordinate[curLayerIndex - 1][0].x;\n\n  // Record the left x position for dynamic detial view positioning\n  intermediateLayerPosition['conv_1_1'] = targetX + nodeLength;\n  intermediateLayerPositionStore.set(intermediateLayerPosition);\n\n  // Hide the edges\n  svg.select('g.edge-group')\n    .style('visibility', 'hidden');\n\n  // Move the selected layer\n  moveLayerX({layerIndex: curLayerIndex, targetX: targetX, disable: true,\n    delay: 0, opacity: 0.15, specialIndex: i});\n\n  // Compute the gap in the right shrink region\n  let rightStart = targetX + nodeLength + hSpaceAroundGap * gapRatio;\n  let rightGap = (width - rightStart - 10 * nodeLength) / 10;\n\n  // Move the right layers\n  for (let i = curLayerIndex + 1; i < numLayers; i++) {\n    let curX = rightStart + (i - (curLayerIndex + 1)) * (nodeLength + rightGap);\n    moveLayerX({layerIndex: i, targetX: curX, disable: true, delay: 0});\n  }\n\n  // Add an overlay gradient and rect\n  let stops = [{offset: '0%', color: 'rgb(250, 250, 250)', opacity: 0.85},\n  {offset: '50%', color: 'rgb(250, 250, 250)', opacity: 0.95},\n  {offset: '100%', color: 'rgb(250, 250, 250)', opacity: 1}];\n  addOverlayGradient('overlay-gradient', stops);\n\n  addOverlayRect('overlay-gradient', rightStart - overlayRectOffset / 2,\n  0, width - rightStart + overlayRectOffset,\n  height + svgPaddings.top + svgPaddings.bottom);\n\n  // Draw the intermediate layer\n  let {intermediateLayer, intermediateMinMax, kernelRange, kernelMinMax} =\n  drawIntermediateLayer(curLayerIndex, leftX, targetX, rightStart,\n    intermediateGap, d, i, intermediateNodeMouseOverHandler,\n    intermediateNodeMouseLeaveHandler, intermediateNodeClicked);\n  addUnderneathRect(curLayerIndex, i, leftX, intermediateGap, 8,\n    intermediateNodeMouseOverHandler, intermediateNodeMouseLeaveHandler,\n    intermediateNodeClicked);\n\n  // Compute the selected node's min max\n  // Selected node\n  let min = Infinity, max = -Infinity;\n  let n = cnn[curLayerIndex][i];\n  for (let r = 0; r < n.output.length; r++) {\n  for (let c = 0; c < n.output[0].length; c++) {\n    if (n.output[r][c] < min) { min = n.output[r][c]; }\n    if (n.output[r][c] > max) { max = n.output[r][c]; }\n  }\n  }\n\n  let finalMinMax = {\n  min: Math.min(min, intermediateMinMax.min),\n  max: Math.max(max, intermediateMinMax.max)\n  }\n\n  // Add annotation to the intermediate layer\n  let intermediateLayerAnnotation = svg.append('g')\n  .attr('class', 'intermediate-layer-annotation')\n  .style('opacity', 0);\n\n  drawIntermediateLayerAnnotation({\n    leftX: leftX,\n    curLayerIndex: curLayerIndex,\n    group: intermediateLayerAnnotation,\n    intermediateGap: intermediateGap,\n    isFirstConv: true,\n    i: i\n  });\n\n  let range = cnnLayerRanges.local[curLayerIndex];\n\n  drawIntermediateLayerLegend({\n    legendHeight: 5,\n    curLayerIndex: curLayerIndex,\n    range: 1,\n    group: intermediateLayer,\n    width: 2 * nodeLength + intermediateGap,\n    isInput: true,\n    x: leftX,\n    y: svgPaddings.top + vSpaceAroundGap * (10) + vSpaceAroundGap + \n      nodeLength * 10 - 25\n  });\n\n  drawIntermediateLayerLegend({\n    legendHeight: 5,\n    curLayerIndex: curLayerIndex,\n    range: range,\n    minMax: finalMinMax,\n    group: intermediateLayer,\n    width: 2 * nodeLength + intermediateGap,\n    x: nodeCoordinate[curLayerIndex - 1][2].x,\n    y: svgPaddings.top + vSpaceAroundGap * (10) + vSpaceAroundGap + \n      nodeLength * 10\n  });\n\n  drawIntermediateLayerLegend({\n    legendHeight: 5,\n    curLayerIndex: curLayerIndex,\n    range: kernelRange,\n    minMax: kernelMinMax,\n    group: intermediateLayer,\n    width: 2 * nodeLength + intermediateGap,\n    x: targetX + nodeLength - (2 * nodeLength + intermediateGap),\n    y: svgPaddings.top + vSpaceAroundGap * (10) + vSpaceAroundGap + \n      nodeLength * 10,\n    gradientAppendingName: 'kernelColorGradient',\n    colorScale: layerColorScales.weight,\n    gradientGap: 0.2\n  });\n\n  // Show everything\n  svg.selectAll('g.intermediate-layer, g.intermediate-layer-annotation')\n    .transition()\n    .delay(500)\n    .duration(500)\n    .ease(d3.easeCubicInOut)\n    .style('opacity', 1);\n}\n\n/**\n * Draw the intermediate layer before conv_1_2\n * @param {number} curLayerIndex Index of the selected layer\n * @param {object} d Bounded d3 data\n * @param {number} i Index of the selected node\n * @param {number} width CNN group width\n * @param {number} height CNN group height\n * @param {function} intermediateNodeMouseOverHandler mouse over handler\n * @param {function} intermediateNodeMouseLeaveHandler mouse leave handler\n * @param {function} intermediateNodeClicked node clicking handler\n */\nexport const drawConv2 = (curLayerIndex, d, i, width, height,\n  intermediateNodeMouseOverHandler, intermediateNodeMouseLeaveHandler,\n  intermediateNodeClicked) => {\n  let targetX = nodeCoordinate[curLayerIndex - 1][0].x + 2 * nodeLength +\n    2 * hSpaceAroundGap * gapRatio + plusSymbolRadius * 2;\n  let intermediateGap = (hSpaceAroundGap * gapRatio * 2) / 3;\n\n  // Record the left x position for dynamic detial view positioning\n  intermediateLayerPosition['conv_1_2'] = targetX + nodeLength;\n  intermediateLayerPositionStore.set(intermediateLayerPosition);\n\n  // Make sure two layers have the same range\n  let {range, minMax} = redrawLayerIfNeeded(curLayerIndex, i);\n\n  // Hide the edges\n  svg.select('g.edge-group')\n    .style('visibility', 'hidden');\n\n  // Move the selected layer\n  moveLayerX({layerIndex: curLayerIndex, targetX: targetX, disable: true,\n    delay: 0, opacity: 0.15, specialIndex: i});\n\n  // Compute the gap in the right shrink region\n  let rightStart = targetX + nodeLength + hSpaceAroundGap * gapRatio;\n  let rightGap = (width - rightStart - 8 * nodeLength) / 8;\n\n  // Move the right layers\n  for (let i = curLayerIndex + 1; i < numLayers; i++) {\n    let curX = rightStart + (i - (curLayerIndex + 1)) * (nodeLength + rightGap);\n    moveLayerX({layerIndex: i, targetX: curX, disable: true, delay: 0});\n  }\n\n  // Add an overlay\n  let stops = [{offset: '0%', color: 'rgb(250, 250, 250)', opacity: 0.85},\n    {offset: '50%', color: 'rgb(250, 250, 250)', opacity: 0.95},\n    {offset: '100%', color: 'rgb(250, 250, 250)', opacity: 1}];\n  addOverlayGradient('overlay-gradient-right', stops);\n\n  let leftRightRatio = (2 * nodeLength + hSpaceAroundGap * gapRatio) /\n    (8 * nodeLength + intermediateGap * 7);\n  let endingGradient = 0.85 + (0.95 - 0.85) * leftRightRatio;\n  stops = [{offset: '0%', color: 'rgb(250, 250, 250)', opacity: endingGradient},\n    {offset: '100%', color: 'rgb(250, 250, 250)', opacity: 0.85}];\n  addOverlayGradient('overlay-gradient-left', stops);\n\n  addOverlayRect('overlay-gradient-right', rightStart - overlayRectOffset / 2,\n    0, width - rightStart + overlayRectOffset,\n    height + svgPaddings.top + svgPaddings.bottom);\n\n  addOverlayRect('overlay-gradient-left', nodeCoordinate[0][0].x - overlayRectOffset / 2,\n    0, nodeLength * 2 + hSpaceAroundGap * gapRatio + overlayRectOffset,\n    height + svgPaddings.top + svgPaddings.bottom);\n\n  // Draw the intermediate layer\n  let leftX = nodeCoordinate[curLayerIndex - 1][0].x;\n  let {intermediateLayer, intermediateMinMax, kernelRange, kernelMinMax} =\n    drawIntermediateLayer(curLayerIndex, leftX, targetX, rightStart,\n      intermediateGap, d, i, intermediateNodeMouseOverHandler,\n      intermediateNodeMouseLeaveHandler, intermediateNodeClicked);\n  addUnderneathRect(curLayerIndex, i, leftX, intermediateGap, 5,\n    intermediateNodeMouseOverHandler, intermediateNodeMouseLeaveHandler,\n    intermediateNodeClicked);\n\n  // After getting the intermediateMinMax, we can finally aggregate it with\n  // the preLayer minmax, curLayer minmax\n  let finalMinMax = {\n    min: Math.min(minMax.min, intermediateMinMax.min),\n    max: Math.max(minMax.max, intermediateMinMax.max)\n  }\n\n  // Add annotation to the intermediate layer\n  let intermediateLayerAnnotation = svg.append('g')\n    .attr('class', 'intermediate-layer-annotation')\n    .style('opacity', 0);\n\n  drawIntermediateLayerAnnotation({\n    leftX: leftX,\n    curLayerIndex: curLayerIndex,\n    group: intermediateLayerAnnotation,\n    intermediateGap: intermediateGap,\n    i: i\n  });\n\n  drawIntermediateLayerLegend({\n    legendHeight: 5,\n    curLayerIndex: curLayerIndex,\n    range: range,\n    minMax: finalMinMax,\n    group: intermediateLayer,\n    width: 2 * nodeLength + intermediateGap,\n    x: leftX,\n    y: svgPaddings.top + vSpaceAroundGap * (10) + vSpaceAroundGap + \n      nodeLength * 10\n  });\n\n  drawIntermediateLayerLegend({\n    legendHeight: 5,\n    curLayerIndex: curLayerIndex,\n    range: kernelRange,\n    minMax: kernelMinMax,\n    group: intermediateLayer,\n    width: 2 * nodeLength + intermediateGap,\n    x: targetX + nodeLength - (2 * nodeLength + intermediateGap),\n    y: svgPaddings.top + vSpaceAroundGap * (10) + vSpaceAroundGap + \n      nodeLength * 10,\n    gradientAppendingName: 'kernelColorGradient',\n    colorScale: layerColorScales.weight,\n    gradientGap: 0.2\n  });\n\n  // Show everything\n  svg.selectAll('g.intermediate-layer, g.intermediate-layer-annotation')\n    .transition()\n    .delay(500)\n    .duration(500)\n    .ease(d3.easeCubicInOut)\n    .style('opacity', 1);\n}\n\n/**\n * Draw the intermediate layer before conv_2_1\n * @param {number} curLayerIndex Index of the selected layer\n * @param {object} d Bounded d3 data\n * @param {number} i Index of the selected node\n * @param {number} width CNN group width\n * @param {number} height CNN group height\n * @param {function} intermediateNodeMouseOverHandler mouse over handler\n * @param {function} intermediateNodeMouseLeaveHandler mouse leave handler\n * @param {function} intermediateNodeClicked node clicking handler\n */\nexport const drawConv3 = (curLayerIndex, d, i, width, height,\n  intermediateNodeMouseOverHandler, intermediateNodeMouseLeaveHandler,\n  intermediateNodeClicked) => {\n\n  let targetX = nodeCoordinate[curLayerIndex][0].x;\n  let leftX = targetX - (2 * nodeLength +\n    2 * hSpaceAroundGap * gapRatio + plusSymbolRadius * 2);\n  let intermediateGap = (hSpaceAroundGap * gapRatio * 2) / 3;\n\n  // Record the left x position for dynamic detial view positioning\n  intermediateLayerPosition['conv_2_1'] = targetX + nodeLength;\n  intermediateLayerPositionStore.set(intermediateLayerPosition);\n\n  // Hide the edges\n  svg.select('g.edge-group')\n    .style('visibility', 'hidden');\n\n  // Make sure two layers have the same range\n  let {range, minMax} = redrawLayerIfNeeded(curLayerIndex, i);\n\n  // Move the previous layer\n  moveLayerX({layerIndex: curLayerIndex - 1, targetX: leftX,\n    disable: true, delay: 0});\n\n  moveLayerX({layerIndex: curLayerIndex,\n    targetX: targetX, disable: true,\n    delay: 0, opacity: 0.15, specialIndex: i});\n\n  // Compute the gap in the left shrink region\n  let leftEnd = leftX - hSpaceAroundGap;\n  let leftGap = (leftEnd - nodeCoordinate[0][0].x - 5 * nodeLength) / 5;\n  let rightStart = nodeCoordinate[curLayerIndex][0].x +\n    nodeLength + hSpaceAroundGap;\n\n  // Move the left layers\n  for (let i = 0; i < curLayerIndex - 1; i++) {\n    let curX = nodeCoordinate[0][0].x + i * (nodeLength + leftGap);\n    moveLayerX({layerIndex: i, targetX: curX, disable: true, delay: 0});\n  }\n\n  // Add an overlay\n  let stops = [{offset: '0%', color: 'rgb(250, 250, 250)', opacity: 1},\n    {offset: '50%', color: 'rgb(250, 250, 250)', opacity: 0.9},\n    {offset: '100%', color: 'rgb(250, 250, 250)', opacity: 0.85}];\n  addOverlayGradient('overlay-gradient-left', stops);\n\n  stops = [{offset: '0%', color: 'rgb(250, 250, 250)', opacity: 0.85},\n    {offset: '50%', color: 'rgb(250, 250, 250)', opacity: 0.95},\n    {offset: '100%', color: 'rgb(250, 250, 250)', opacity: 1}];\n  addOverlayGradient('overlay-gradient-right', stops);\n\n  addOverlayRect('overlay-gradient-left', nodeCoordinate[0][0].x - overlayRectOffset / 2,\n    0, leftEnd - nodeCoordinate[0][0].x + overlayRectOffset,\n    height + svgPaddings.top + svgPaddings.bottom);\n  \n  addOverlayRect('overlay-gradient-right', rightStart - overlayRectOffset / 2,\n    0, width - rightStart + overlayRectOffset,\n    height + svgPaddings.top + svgPaddings.bottom);\n  \n  // Draw the intermediate layer\n  let {intermediateLayer, intermediateMinMax, kernelRange, kernelMinMax} =\n    drawIntermediateLayer(curLayerIndex, leftX,\n      nodeCoordinate[curLayerIndex][0].x, rightStart, intermediateGap,\n      d, i, intermediateNodeMouseOverHandler,\n      intermediateNodeMouseLeaveHandler, intermediateNodeClicked);\n  addUnderneathRect(curLayerIndex, i, leftX, intermediateGap, 5,\n    intermediateNodeMouseOverHandler, intermediateNodeMouseLeaveHandler,\n    intermediateNodeClicked);\n          \n  // After getting the intermediateMinMax, we can finally aggregate it with\n  // the preLayer minmax, curLayer minmax\n  let finalMinMax = {\n    min: Math.min(minMax.min, intermediateMinMax.min),\n    max: Math.max(minMax.max, intermediateMinMax.max)\n  }\n\n  // Add annotation to the intermediate layer\n  let intermediateLayerAnnotation = svg.append('g')\n    .attr('class', 'intermediate-layer-annotation')\n    .style('opacity', 0);\n\n  drawIntermediateLayerAnnotation({\n    leftX: leftX,\n    curLayerIndex: curLayerIndex,\n    group: intermediateLayerAnnotation,\n    intermediateGap: intermediateGap,\n    i: i\n  });\n\n  drawIntermediateLayerLegend({\n    legendHeight: 5,\n    curLayerIndex: curLayerIndex,\n    range: range,\n    group: intermediateLayer,\n    width: 2 * nodeLength + intermediateGap,\n    minMax: finalMinMax,\n    x: leftX,\n    y: svgPaddings.top + vSpaceAroundGap * (10) + vSpaceAroundGap + \n      nodeLength * 10\n  });\n\n  drawIntermediateLayerLegend({\n    legendHeight: 5,\n    curLayerIndex: curLayerIndex,\n    range: kernelRange,\n    minMax: kernelMinMax,\n    group: intermediateLayer,\n    width: 2 * nodeLength + intermediateGap,\n    x: targetX + nodeLength - (2 * nodeLength + intermediateGap),\n    y: svgPaddings.top + vSpaceAroundGap * (10) + vSpaceAroundGap + \n      nodeLength * 10,\n    gradientAppendingName: 'kernelColorGradient',\n    colorScale: layerColorScales.weight,\n    gradientGap: 0.2\n  });\n\n  // Show everything\n  svg.selectAll('g.intermediate-layer, g.intermediate-layer-annotation')\n    .transition()\n    .delay(500)\n    .duration(500)\n    .ease(d3.easeCubicInOut)\n    .style('opacity', 1);\n}\n\n/**\n * Draw the intermediate layer before conv_2_2\n * @param {number} curLayerIndex Index of the selected layer\n * @param {object} d Bounded d3 data\n * @param {number} i Index of the selected node\n * @param {number} width CNN group width\n * @param {number} height CNN group height\n * @param {function} intermediateNodeMouseOverHandler mouse over handler\n * @param {function} intermediateNodeMouseLeaveHandler mouse leave handler\n * @param {function} intermediateNodeClicked node clicking handler\n */\nexport const drawConv4 = (curLayerIndex, d, i, width, height,\n  intermediateNodeMouseOverHandler, intermediateNodeMouseLeaveHandler,\n  intermediateNodeClicked) => {\n  let targetX = nodeCoordinate[curLayerIndex][0].x;\n  let leftX = targetX - (2 * nodeLength +\n    2 * hSpaceAroundGap * gapRatio + plusSymbolRadius * 2);\n  let intermediateGap = (hSpaceAroundGap * gapRatio * 2) / 3;\n\n  // Record the left x position for dynamic detial view positioning\n  intermediateLayerPosition['conv_2_2'] = leftX;\n  intermediateLayerPositionStore.set(intermediateLayerPosition);\n\n  // Hide the edges\n  svg.select('g.edge-group')\n    .style('visibility', 'hidden');\n\n  // Make sure two layers have the same range\n  let {range, minMax} = redrawLayerIfNeeded(curLayerIndex, i);\n\n  // Move the previous layer\n  moveLayerX({layerIndex: curLayerIndex - 1, targetX: leftX,\n    disable: true, delay: 0});\n\n  moveLayerX({layerIndex: curLayerIndex,\n    targetX: targetX, disable: true,\n    delay: 0, opacity: 0.15, specialIndex: i});\n\n  // Compute the gap in the left shrink region\n  let leftEnd = leftX - hSpaceAroundGap;\n  let leftGap = (leftEnd - nodeCoordinate[0][0].x - 7 * nodeLength) / 7;\n  let rightStart = targetX + nodeLength + hSpaceAroundGap;\n\n  // Move the left layers\n  for (let i = 0; i < curLayerIndex - 1; i++) {\n    let curX = nodeCoordinate[0][0].x + i * (nodeLength + leftGap);\n    moveLayerX({layerIndex: i, targetX: curX, disable: true, delay: 0});\n  }\n\n  // Add an overlay\n  let stops = [{offset: '0%', color: 'rgb(250, 250, 250)', opacity: 1},\n    {offset: '50%', color: 'rgb(250, 250, 250)', opacity: 0.95},\n    {offset: '100%', color: 'rgb(250, 250, 250)', opacity: 0.85}];\n  addOverlayGradient('overlay-gradient-left', stops);\n\n  stops = [{offset: '0%', color: 'rgb(250, 250, 250)', opacity: 0.85},\n    {offset: '50%', color: 'rgb(250, 250, 250)', opacity: 0.95},\n    {offset: '100%', color: 'rgb(250, 250, 250)', opacity: 1}];\n  addOverlayGradient('overlay-gradient-right', stops);\n\n  addOverlayRect('overlay-gradient-left', nodeCoordinate[0][0].x - overlayRectOffset / 2,\n    0, leftEnd - nodeCoordinate[0][0].x + overlayRectOffset,\n    height + svgPaddings.top + svgPaddings.bottom);\n  \n  addOverlayRect('overlay-gradient-right', rightStart - overlayRectOffset / 2,\n    0, width - rightStart + overlayRectOffset,\n    height + svgPaddings.top + svgPaddings.bottom);\n  \n  // Draw the intermediate layer\n  let {intermediateLayer, intermediateMinMax, kernelRange, kernelMinMax} =\n    drawIntermediateLayer(curLayerIndex, leftX,\n      nodeCoordinate[curLayerIndex][0].x, rightStart, intermediateGap,\n      d, i, intermediateNodeMouseOverHandler,\n      intermediateNodeMouseLeaveHandler, intermediateNodeClicked);\n  addUnderneathRect(curLayerIndex, i, leftX, intermediateGap, 5,\n    intermediateNodeMouseOverHandler, intermediateNodeMouseLeaveHandler,\n    intermediateNodeClicked);\n          \n  // After getting the intermediateMinMax, we can finally aggregate it with\n  // the preLayer minmax, curLayer minmax\n  let finalMinMax = {\n    min: Math.min(minMax.min, intermediateMinMax.min),\n    max: Math.max(minMax.max, intermediateMinMax.max)\n  }\n\n  // Add annotation to the intermediate layer\n  let intermediateLayerAnnotation = svg.append('g')\n    .attr('class', 'intermediate-layer-annotation')\n    .style('opacity', 0);\n\n  drawIntermediateLayerAnnotation({\n    leftX: leftX,\n    curLayerIndex: curLayerIndex,\n    group: intermediateLayerAnnotation,\n    intermediateGap: intermediateGap,\n    i: i\n  });\n\n  drawIntermediateLayerLegend({\n    legendHeight: 5,\n    curLayerIndex: curLayerIndex,\n    range: range,\n    group: intermediateLayer,\n    minMax: finalMinMax,\n    width: 2 * nodeLength + intermediateGap,\n    x: leftX,\n    y: svgPaddings.top + vSpaceAroundGap * (10) + vSpaceAroundGap + \n      nodeLength * 10\n  });\n\n  drawIntermediateLayerLegend({\n    legendHeight: 5,\n    curLayerIndex: curLayerIndex,\n    range: kernelRange,\n    minMax: kernelMinMax,\n    group: intermediateLayer,\n    width: 2 * nodeLength + intermediateGap,\n    x: targetX + nodeLength - (2 * nodeLength + intermediateGap),\n    y: svgPaddings.top + vSpaceAroundGap * (10) + vSpaceAroundGap + \n      nodeLength * 10,\n    gradientAppendingName: 'kernelColorGradient',\n    colorScale: layerColorScales.weight,\n    gradientGap: 0.2\n  });\n\n  // Show everything\n  svg.selectAll('g.intermediate-layer, g.intermediate-layer-annotation')\n    .transition()\n    .delay(500)\n    .duration(500)\n    .ease(d3.easeCubicInOut)\n    .style('opacity', 1);\n}\n","/* global d3, SmoothScroll */\n\nimport {\n  svgStore, vSpaceAroundGapStore, hSpaceAroundGapStore, cnnStore,\n  nodeCoordinateStore, selectedScaleLevelStore, cnnLayerRangesStore,\n  cnnLayerMinMaxStore, isInSoftmaxStore, softmaxDetailViewStore,\n  hoverInfoStore, allowsSoftmaxAnimationStore, detailedModeStore\n} from '../stores.js';\nimport {\n  getOutputKnot, getInputKnot, gappedColorScale, getMidCoords\n} from './draw-utils.js';\nimport {\n  drawIntermediateLayerLegend, moveLayerX, addOverlayGradient,\n  drawArrow\n} from './intermediate-utils.js';\nimport { overviewConfig } from '../config.js';\n\n// Configs\nconst layerColorScales = overviewConfig.layerColorScales;\nconst nodeLength = overviewConfig.nodeLength;\nconst plusSymbolRadius = overviewConfig.plusSymbolRadius;\nconst intermediateColor = overviewConfig.intermediateColor;\nconst kernelRectLength = overviewConfig.kernelRectLength;\nconst svgPaddings = overviewConfig.svgPaddings;\nconst gapRatio = overviewConfig.gapRatio;\nconst classList = overviewConfig.classLists;\nconst formater = d3.format('.4f');\n\n// Shared variables\nlet svg = undefined;\nsvgStore.subscribe( value => {svg = value;} )\n\nlet vSpaceAroundGap = undefined;\nvSpaceAroundGapStore.subscribe( value => {vSpaceAroundGap = value;} )\n\nlet hSpaceAroundGap = undefined;\nhSpaceAroundGapStore.subscribe( value => {hSpaceAroundGap = value;} )\n\nlet cnn = undefined;\ncnnStore.subscribe( value => {cnn = value;} )\n\nlet nodeCoordinate = undefined;\nnodeCoordinateStore.subscribe( value => {nodeCoordinate = value;} )\n\nlet selectedScaleLevel = undefined;\nselectedScaleLevelStore.subscribe( value => {selectedScaleLevel = value;} )\n\nlet cnnLayerRanges = undefined;\ncnnLayerRangesStore.subscribe( value => {cnnLayerRanges = value;} )\n\nlet cnnLayerMinMax = undefined;\ncnnLayerMinMaxStore.subscribe( value => {cnnLayerMinMax = value;} )\n\nlet isInSoftmax = undefined;\nisInSoftmaxStore.subscribe( value => {isInSoftmax = value;} )\n\nlet allowsSoftmaxAnimation = undefined;\nallowsSoftmaxAnimationStore.subscribe( value => {allowsSoftmaxAnimation = value;} )\n\nlet softmaxDetailViewInfo = undefined;\nsoftmaxDetailViewStore.subscribe( value => {softmaxDetailViewInfo = value;} )\n\nlet hoverInfo = undefined;\nhoverInfoStore.subscribe( value => {hoverInfo = value;} )\n\nlet detailedMode = undefined;\ndetailedModeStore.subscribe( value => {detailedMode = value;} )\n\nlet layerIndexDict = {\n  'input': 0,\n  'conv_1_1': 1,\n  'relu_1_1': 2,\n  'conv_1_2': 3,\n  'relu_1_2': 4,\n  'max_pool_1': 5,\n  'conv_2_1': 6,\n  'relu_2_1': 7,\n  'conv_2_2': 8,\n  'relu_2_2': 9,\n  'max_pool_2': 10,\n  'output': 11\n}\n\nlet hasInitialized = false;\nlet logits = [];\nlet flattenFactoredFDict = {};\n\nconst moveLegend = (d, i, g, moveX, duration, restore) => {\n  let legend = d3.select(g[i]);\n\n  if (!restore) {\n    let previousTransform = legend.attr('transform');\n    let previousLegendX = +previousTransform.replace(/.*\\(([\\d\\.]+),.*/, '$1');\n    let previousLegendY = +previousTransform.replace(/.*,\\s([\\d\\.]+)\\)/, '$1');\n  \n    legend.transition('softmax')\n      .duration(duration)\n      .ease(d3.easeCubicInOut)\n      .attr('transform', `translate(${previousLegendX - moveX}, ${previousLegendY})`);\n    \n    // If not in restore mode, we register the previous location to the DOM element\n    legend.attr('data-preX', previousLegendX);\n    legend.attr('data-preY', previousLegendY);\n  } else {\n    // Restore the recorded location\n    let previousLegendX = +legend.attr('data-preX');\n    let previousLegendY = +legend.attr('data-preY');\n\n    legend.transition('softmax')\n      .duration(duration)\n      .ease(d3.easeCubicInOut)\n      .attr('transform', `translate(${previousLegendX}, ${previousLegendY})`);\n  }\n}\n\nconst logitCircleMouseOverHandler = (i) => {\n  // Update the hover info UI\n  hoverInfoStore.set({\n    show: true,\n    text: `Logit: ${formater(logits[i])}`\n  })\n\n  // Highlight the text in the detail view\n  softmaxDetailViewInfo.highlightI = i;\n  softmaxDetailViewStore.set(softmaxDetailViewInfo);\n\n  let logitLayer = svg.select('.logit-layer');\n  let logitLayerLower = svg.select('.underneath');\n  let intermediateLayer = svg.select('.intermediate-layer');\n\n  // Highlight the circle\n  logitLayer.select(`#logit-circle-${i}`)\n    .style('stroke-width', 2);\n\n  // Highlight the associated plus symbol\n  intermediateLayer.select(`#plus-symbol-clone-${i}`)\n    .style('opacity', 1)\n    .select('circle')\n    .style('fill', d => d.fill);\n  \n  // Raise the associated edge group\n  logitLayerLower.select(`#logit-lower-${i}`).raise();\n\n  // Highlight the associated edges\n  logitLayerLower.selectAll(`.softmax-abstract-edge-${i}`)\n    .style('stroke-width', 0.8)\n    .style('stroke', '#E0E0E0');\n\n  logitLayerLower.selectAll(`.softmax-edge-${i}`)\n    .style('stroke-width', 1)\n    .style('stroke', '#E0E0E0');\n  \n  logitLayerLower.selectAll(`.logit-output-edge-${i}`)\n    .style('stroke-width', 3)\n    .style('stroke', '#E0E0E0');\n\n  logitLayer.selectAll(`.logit-output-edge-${i}`)\n    .style('stroke-width', 3)\n    .style('stroke', '#E0E0E0');\n}\n\nconst logitCircleMouseLeaveHandler = (i) => {\n  // screenshot\n  // return;\n\n  // Update the hover info UI\n  hoverInfoStore.set({\n    show: false,\n    text: `Logit: ${formater(logits[i])}`\n  })\n\n  // Dehighlight the text in the detail view\n  softmaxDetailViewInfo.highlightI = -1;\n  softmaxDetailViewStore.set(softmaxDetailViewInfo);\n\n  let logitLayer = svg.select('.logit-layer');\n  let logitLayerLower = svg.select('.underneath');\n  let intermediateLayer = svg.select('.intermediate-layer');\n\n  // Restore the circle\n  logitLayer.select(`#logit-circle-${i}`)\n    .style('stroke-width', 1);\n\n  // Restore the associated plus symbol\n  intermediateLayer.select(`#plus-symbol-clone-${i}`)\n    .style('opacity', 0.2);\n\n  // Restore the associated edges\n  logitLayerLower.selectAll(`.softmax-abstract-edge-${i}`)\n    .style('stroke-width', 0.2)\n    .style('stroke', '#EDEDED');\n\n  logitLayerLower.selectAll(`.softmax-edge-${i}`)\n    .style('stroke-width', 0.2)\n    .style('stroke', '#F1F1F1');\n\n  logitLayerLower.selectAll(`.logit-output-edge-${i}`)\n    .style('stroke-width', 1.2)\n    .style('stroke', '#E5E5E5');\n  \n  logitLayer.selectAll(`.logit-output-edge-${i}`)\n    .style('stroke-width', 1.2)\n    .style('stroke', '#E5E5E5');\n}\n\n// This function is binded to the detail view in Overview.svelte\nexport const softmaxDetailViewMouseOverHandler = (event) => {\n  logitCircleMouseOverHandler(event.detail.curI);\n}\n\n// This function is binded to the detail view in Overview.svelte\nexport const softmaxDetailViewMouseLeaveHandler = (event) => {\n  logitCircleMouseLeaveHandler(event.detail.curI);\n}\n\nconst drawLogitLayer = (arg) => {\n  let curLayerIndex = arg.curLayerIndex,\n    moveX = arg.moveX,\n    softmaxLeftMid = arg.softmaxLeftMid,\n    selectedI = arg.selectedI,\n    intermediateX1 = arg.intermediateX1,\n    intermediateX2 = arg.intermediateX2,\n    pixelWidth = arg.pixelWidth,\n    pixelHeight = arg.pixelHeight,\n    topY = arg.topY,\n    bottomY = arg.bottomY,\n    softmaxX = arg.softmaxX,\n    middleGap = arg.middleGap,\n    middleRectHeight = arg.middleRectHeight,\n    symbolGroup = arg.symbolGroup,\n    symbolX = arg.symbolX,\n    flattenRange = arg.flattenRange;\n\n  let logitLayer = svg.select('.intermediate-layer')\n    .append('g')\n    .attr('class', 'logit-layer')\n    .raise();\n  \n  // Minotr layer ordering change\n  let tempClone = svg.select('.intermediate-layer')\n    .select('.flatten-layer')\n    .select('.plus-symbol')\n    .clone(true)\n    .attr('class', 'temp-clone-plus-symbol')\n    .attr('transform', `translate(${symbolX - moveX},\n      ${nodeCoordinate[curLayerIndex][selectedI].y + nodeLength / 2})`)\n    // Cool hack -> d3 clone doesnt clone events, make the front object pointer\n    // event transparent so users can trigger the underlying object's event!\n    .style('pointer-events', 'none')\n    .remove();\n\n  let tempPlusSymbol = logitLayer.append(() => tempClone.node());\n  \n  svg.select('.softmax-symbol').raise();\n\n  let logitLayerLower = svg.select('.underneath')\n    .append('g')\n    .attr('class', 'logit-layer-lower')\n    .lower();\n  \n  // Use circles to encode logit values\n  let centerX = softmaxLeftMid - moveX * 4 / 5;\n\n  // Get all logits\n  logits = [];\n  for (let i = 0; i < cnn[layerIndexDict['output']].length; i++) {\n    logits.push(cnn[layerIndexDict['output']][i].logit);\n  }\n\n  // Construct a color scale for the logit values\n  let logitColorScale = d3.scaleLinear()\n    .domain(d3.extent(logits))\n    .range([0.2, 1]);\n  \n  // Draw the current logit circle before animation\n  let logitRadius = 8;\n  logitLayer.append('circle')\n    .attr('class', 'logit-circle')\n    .attr('id', `logit-circle-${selectedI}`)\n    .attr('cx', centerX)\n    .attr('cy', nodeCoordinate[curLayerIndex - 1][selectedI].y + nodeLength / 2)\n    .attr('r', logitRadius)\n    .style('fill', layerColorScales.logit(logitColorScale(logits[selectedI])))\n    .style('cursor', 'crosshair')\n    .style('pointer-events', 'all')\n    .style('stroke', intermediateColor)\n    .on('mouseover', () => logitCircleMouseOverHandler(selectedI))\n    .on('mouseleave', () => logitCircleMouseLeaveHandler(selectedI))\n    .on('click', () => { d3.event.stopPropagation() });\n  \n  // Show the logit circle corresponding label\n  let softmaxDetailAnnotation = svg.select('.intermediate-layer-annotation')\n    .select('.softmax-detail-annoataion');\n\n  softmaxDetailAnnotation.select(`#logit-text-${selectedI}`)\n    .style('opacity', 1);\n\n  tempPlusSymbol.raise();\n\n  // Draw another line from plus symbol to softmax symbol\n  logitLayer.append('line')\n    .attr('class', `logit-output-edge-${selectedI}`)\n    .attr('x1', intermediateX2 - moveX + plusSymbolRadius * 2)\n    .attr('x2', softmaxX)\n    .attr('y1', nodeCoordinate[curLayerIndex - 1][selectedI].y + nodeLength / 2)\n    .attr('y2', nodeCoordinate[curLayerIndex - 1][selectedI].y + nodeLength / 2)\n    .style('fill', 'none')\n    .style('stroke', '#EAEAEA')\n    .style('stroke-width', '1.2')\n    .lower();\n\n  // Add the flatten to logit links\n  let linkData = [];\n  let flattenLength = cnn.flatten.length / cnn[1].length;\n  let underneathIs = [...Array(cnn[layerIndexDict['output']].length).keys()]\n    .filter(d => d != selectedI);\n  let curIIndex = 0;\n  let linkGen = d3.linkHorizontal()\n    .x(d => d.x)\n    .y(d => d.y);\n\n  const drawOneEdgeGroup = () => {\n    // Only draw the new group if it is in the softmax mode\n    if (!allowsSoftmaxAnimation) {\n      svg.select('.underneath')\n        .selectAll(`.logit-lower`)\n        .remove();\n      return;\n    }\n\n    let curI = underneathIs[curIIndex];\n\n    let curEdgeGroup = svg.select('.underneath')\n      .select(`#logit-lower-${curI}`);\n    \n    if (curEdgeGroup.empty()) {\n      curEdgeGroup = svg.select('.underneath')\n        .append('g')\n        .attr('class', 'logit-lower')\n        .attr('id', `logit-lower-${curI}`)\n        .style('opacity', 0);\n\n      // Hack: now show all edges, only draw 1/3 of the actual edges\n      for (let f = 0; f < flattenLength; f += 3) {\n        let loopFactors = [0, 9];\n        loopFactors.forEach(l => {\n          let factoredF = f + l * flattenLength;\n    \n          // Flatten -> output\n          linkData.push({\n            source: {x: intermediateX1 + pixelWidth + 3 - moveX,\n              y:  l === 0 ? topY + f * pixelHeight : bottomY + f * pixelHeight},\n            target: {x: intermediateX2 - moveX,\n              y: nodeCoordinate[curLayerIndex][curI].y + nodeLength / 2},\n            index: factoredF,\n            weight: cnn.flatten[factoredF].outputLinks[curI].weight,\n            color: '#F1F1F1',\n            width: 0.5,\n            opacity: 1,\n            class: `softmax-edge-${curI}`\n          });\n        });\n      }\n\n      // Draw middle rect to logits\n      for (let vi = 0; vi < cnn[layerIndexDict['output']].length - 2; vi++) {\n        linkData.push({\n          source: {x: intermediateX1 + pixelWidth + 3 - moveX,\n            y: topY + flattenLength * pixelHeight + middleGap * (vi + 1) +\n            middleRectHeight * (vi + 0.5)},\n          target: {x: intermediateX2 - moveX,\n            y: nodeCoordinate[curLayerIndex][curI].y + nodeLength / 2},\n          index: -1,\n          color: '#EDEDED',\n          width: 0.5,\n          opacity: 1,\n          class: `softmax-abstract-edge-${curI}`\n        });\n      }\n\n      // Render the edges on the underneath layer\n      curEdgeGroup.selectAll(`path.softmax-edge-${curI}`)\n        .data(linkData)\n        .enter()\n        .append('path')\n        .attr('class', d => d.class)\n        .attr('id', d => `edge-${d.name}`)\n        .attr('d', d => linkGen({source: d.source, target: d.target}))\n        .style('fill', 'none')\n        .style('stroke-width', d => d.width)\n        .style('stroke', d => d.color === undefined ? intermediateColor : d.color)\n        .style('opacity', d => d.opacity)\n        .style('pointer-events', 'none');\n    }\n    \n    let curNodeGroup = logitLayer.append('g')\n      .attr('class', `logit-layer-${curI}`)\n      .style('opacity', 0);\n    \n    // Draw the plus symbol\n    let symbolClone = symbolGroup.clone(true)\n      .style('opacity', 0);\n\n    // Change the style of the clone\n    symbolClone.attr('class', 'plus-symbol-clone')\n      .attr('id', `plus-symbol-clone-${curI}`)\n      .select('circle')\n      .datum({fill: gappedColorScale(layerColorScales.weight,\n        flattenRange, cnn[layerIndexDict['output']][curI].bias, 0.35)})\n      .style('pointer-events', 'none')\n      .style('fill', '#E5E5E5');\n\n    symbolClone.attr('transform', `translate(${symbolX},\n      ${nodeCoordinate[curLayerIndex][curI].y + nodeLength / 2})`);\n    \n    // Draw the outter link using only merged path\n    let outputEdgeD1 = linkGen({\n      source: {\n        x: intermediateX2 - moveX + plusSymbolRadius * 2,\n        y: nodeCoordinate[curLayerIndex][curI].y + nodeLength / 2\n      },\n      target: {\n        x: centerX + logitRadius,\n        y: nodeCoordinate[curLayerIndex][curI].y + nodeLength / 2\n      }\n    });\n\n    let outputEdgeD2 = linkGen({\n      source: {\n        x: centerX + logitRadius,\n        y: nodeCoordinate[curLayerIndex][curI].y + nodeLength / 2\n      },\n      target: {\n        x: softmaxX,\n        y: nodeCoordinate[curLayerIndex][selectedI].y + nodeLength / 2\n      }\n    });\n\n    // There are ways to combine these two paths into one. However, the animation\n    // for merged path is not continuous, so we use two saperate paths here.\n\n    let outputEdge1 = logitLayerLower.append('path')\n      .attr('class', `logit-output-edge-${curI}`)\n      .attr('d', outputEdgeD1)\n      .style('fill', 'none')\n      .style('stroke', '#EAEAEA')\n      .style('stroke-width', '1.2');\n\n    let outputEdge2 = logitLayerLower.append('path')\n      .attr('class', `logit-output-edge-${curI}`)\n      .attr('d', outputEdgeD2)\n      .style('fill', 'none')\n      .style('stroke', '#EAEAEA')\n      .style('stroke-width', '1.2');\n    \n    let outputEdgeLength1 = outputEdge1.node().getTotalLength();\n    let outputEdgeLength2 = outputEdge2.node().getTotalLength();\n    let totalLength = outputEdgeLength1 + outputEdgeLength2;\n    let totalDuration = hasInitialized ? 500 : 800;\n    let opacityDuration = hasInitialized ? 400 : 600;\n\n    outputEdge1.attr('stroke-dasharray', outputEdgeLength1 + ' ' + outputEdgeLength1)\n      .attr('stroke-dashoffset', outputEdgeLength1);\n    \n    outputEdge2.attr('stroke-dasharray', outputEdgeLength2 + ' ' + outputEdgeLength2)\n      .attr('stroke-dashoffset', outputEdgeLength2);\n\n    outputEdge1.transition('softmax-output-edge')\n      .duration(outputEdgeLength1 / totalLength * totalDuration)\n      .attr('stroke-dashoffset', 0);\n\n    outputEdge2.transition('softmax-output-edge')\n      .delay(outputEdgeLength1 / totalLength * totalDuration)\n      .duration(outputEdgeLength2 / totalLength * totalDuration)\n      .attr('stroke-dashoffset', 0);\n    \n    // Draw the logit circle\n    curNodeGroup.append('circle')\n      .attr('class', 'logit-circle')\n      .attr('id', `logit-circle-${curI}`)\n      .attr('cx', centerX)\n      .attr('cy', nodeCoordinate[curLayerIndex - 1][curI].y + nodeLength / 2)\n      .attr('r', 7)\n      .style('fill', layerColorScales.logit(logitColorScale(logits[curI])))\n      .style('stroke', intermediateColor)\n      .style('cursor', 'crosshair')\n      .on('mouseover', () => logitCircleMouseOverHandler(curI))\n      .on('mouseleave', () => logitCircleMouseLeaveHandler(curI))\n      .on('click', () => { d3.event.stopPropagation() });\n    \n    // Show the element in the detailed view\n    softmaxDetailViewInfo.startAnimation = {\n      i: curI,\n      duration: opacityDuration,\n      // Always show the animation\n      hasInitialized: false\n    };\n    softmaxDetailViewStore.set(softmaxDetailViewInfo);\n\n    // Show the elements with animation    \n    curNodeGroup.transition('softmax-edge')\n      .duration(opacityDuration)\n      .style('opacity', 1);\n\n    if ((selectedI < 3 && curI == 9) || (selectedI >= 3 && curI == 0)) {\n      // Show the hover text\n      softmaxDetailAnnotation.select('.softmax-detail-hover-annotation')\n        .transition('softmax-edge')\n        .duration(opacityDuration)\n        .style('opacity', 1);\n    }\n\n    softmaxDetailAnnotation.select(`#logit-text-${curI}`)\n      .transition('softmax-edge')\n      .duration(opacityDuration)\n      .style('opacity', 1);\n    \n    curEdgeGroup.transition('softmax-edge')\n      .duration(opacityDuration)\n      .style('opacity', 1)\n      .on('end', () => {\n        // Recursive animaiton\n        curIIndex ++;\n        if (curIIndex < underneathIs.length) {\n          linkData = [];\n          drawOneEdgeGroup();\n        } else {\n          hasInitialized = true;\n          softmaxDetailViewInfo.hasInitialized = true;\n          softmaxDetailViewStore.set(softmaxDetailViewInfo);\n        }\n      });\n    \n    symbolClone.transition('softmax-edge')\n      .duration(opacityDuration)\n      .style('opacity', 0.2);\n  }\n\n  // Show the softmax detail view\n  let anchorElement = svg.select('.intermediate-layer')\n    .select('.layer-label').node();\n  let pos = getMidCoords(svg, anchorElement);\n  let wholeSvg = d3.select('#cnn-svg');\n  let svgYMid = +wholeSvg.style('height').replace('px', '') / 2;\n  let detailViewTop = 100 + svgYMid - 192 / 2;\n\n  const detailview = document.getElementById('detailview');\n  detailview.style.top = `${detailViewTop}px`;\n  detailview.style.left = `${pos.left - 490 - 50}px`;\n  detailview.style.position = 'absolute';\n\n  softmaxDetailViewStore.set({\n    show: true,\n    logits: logits,\n    logitColors: logits.map(d => layerColorScales.logit(logitColorScale(d))),\n    selectedI: selectedI,\n    highlightI: -1,\n    outputName: classList[selectedI],\n    outputValue: cnn[layerIndexDict['output']][selectedI].output,\n    startAnimation: {i: -1, duration: 0, hasInitialized: hasInitialized}\n  })\n\n  drawOneEdgeGroup();\n\n  // Draw logit circle color scale\n  drawIntermediateLayerLegend({\n    legendHeight: 5,\n    curLayerIndex: curLayerIndex,\n    range: d3.extent(logits)[1] - d3.extent(logits)[0],\n    minMax: {min: d3.extent(logits)[0], max: d3.extent(logits)[1]},\n    group: logitLayer,\n    width: softmaxX - (intermediateX2 + plusSymbolRadius * 2 - moveX + 5),\n    gradientAppendingName: 'flatten-logit-gradient',\n    gradientGap: 0.1,\n    colorScale: layerColorScales.logit,\n    x: intermediateX2 + plusSymbolRadius * 2 - moveX + 5,\n    y: svgPaddings.top + vSpaceAroundGap * (10) + vSpaceAroundGap + \n      nodeLength * 10\n  });\n\n  // Draw logit layer label\n  let logitLabel = logitLayer.append('g')\n    .attr('class', 'layer-label')\n    .classed('hidden', detailedMode)\n    .attr('transform', () => {\n      let x = centerX;\n      let y = (svgPaddings.top + vSpaceAroundGap) / 2 + 5;\n      return `translate(${x}, ${y})`;\n    });\n\n  logitLabel.append('text')\n    .style('text-anchor', 'middle')\n    .style('dominant-baseline', 'middle')\n    .style('opacity', 0.8)\n    .style('font-weight', 800)\n    .text('logit');\n}\n\nconst removeLogitLayer = () => {\n  svg.select('.logit-layer').remove();\n  svg.select('.logit-layer-lower').remove();\n  svg.selectAll('.plus-symbol-clone').remove();\n\n  // Instead of removing the paths, we hide them, so it is faster to load in\n  // the future\n  svg.select('.underneath')\n    .selectAll('.logit-lower')\n    .style('opacity', 0);\n\n  softmaxDetailViewStore.set({\n      show: false,\n      logits: []\n  })\n}\n\nconst softmaxClicked = (arg) => {\n  let curLayerIndex = arg.curLayerIndex,\n    moveX = arg.moveX,\n    symbolX = arg.symbolX,\n    symbolY = arg.symbolY,\n    outputX = arg.outputX,\n    outputY = arg.outputY,\n    softmaxLeftMid = arg.softmaxLeftMid,\n    selectedI = arg.selectedI,\n    intermediateX1 = arg.intermediateX1,\n    intermediateX2 = arg.intermediateX2,\n    pixelWidth = arg.pixelWidth,\n    pixelHeight = arg.pixelHeight,\n    topY = arg.topY,\n    bottomY = arg.bottomY,\n    middleGap = arg.middleGap,\n    middleRectHeight = arg.middleRectHeight,\n    softmaxX = arg.softmaxX,\n    softmaxTextY = arg.softmaxTextY,\n    softmaxWidth = arg.softmaxWidth,\n    symbolGroup = arg.symbolGroup,\n    flattenRange = arg.flattenRange;\n\n  let duration = 600;\n  let centerX = softmaxLeftMid - moveX * 4 / 5;\n  d3.event.stopPropagation();\n\n  // Clean up the logit elemends before moving anything\n  if (isInSoftmax) {\n    allowsSoftmaxAnimationStore.set(false);\n    removeLogitLayer();\n  } else {\n    allowsSoftmaxAnimationStore.set(true);\n  }\n\n  // Move the overlay gradient\n  svg.select('.intermediate-layer-overlay')\n    .select('rect.overlay')\n    .transition('softmax')\n    .ease(d3.easeCubicInOut)\n    .duration(duration)\n    .attr('transform', `translate(${isInSoftmax ? 0 : -moveX}, ${0})`);\n\n  // Move the legends\n  svg.selectAll(`.intermediate-legend-${curLayerIndex - 1}`)\n    .each((d, i, g) => moveLegend(d, i, g, moveX, duration, isInSoftmax));\n\n  svg.select('.intermediate-layer')\n    .select(`.layer-label`)\n    .each((d, i, g) => moveLegend(d, i, g, moveX, duration, isInSoftmax));\n\n  svg.select('.intermediate-layer')\n    .select(`.layer-detailed-label`)\n    .each((d, i, g) => moveLegend(d, i, g, moveX, duration, isInSoftmax));\n\n  // Also move all layers on the left\n  for (let i = curLayerIndex - 1; i >= 0; i--) {\n    let curLayer = svg.select(`g#cnn-layer-group-${i}`);\n    let previousX = +curLayer.select('image').attr('x');\n    let newX = isInSoftmax ? previousX + moveX : previousX - moveX;\n    moveLayerX({\n      layerIndex: i,\n      targetX: newX,\n      disable: true,\n      delay: 0,\n      transitionName: 'softmax',\n      duration: duration\n    });\n  }\n\n  // Hide the sum up annotation\n  svg.select('.plus-annotation')\n    .transition('softmax')\n    .duration(duration)\n    .style('opacity', isInSoftmax ? 1 : 0)\n    .style('pointer-events', isInSoftmax ? 'all' : 'none');\n\n  // Hide the softmax annotation\n  let softmaxAnnotation = svg.select('.softmax-annotation')\n    .style('pointer-events', isInSoftmax ? 'all' : 'none');\n  \n  let softmaxDetailAnnotation = softmaxAnnotation.selectAll('.softmax-detail-annoataion')\n    .data([0])\n    .enter()\n    .append('g')\n    .attr('class', 'softmax-detail-annoataion');\n\n  // Remove the detailed annoatioan when quitting the detail view\n  if (isInSoftmax) {\n    softmaxAnnotation.selectAll('.softmax-detail-annoataion').remove();\n  }\n\n  softmaxAnnotation.select('.arrow-group')\n    .transition('softmax')\n    .duration(duration)\n    .style('opacity', isInSoftmax ? 1 : 0);\n\n  softmaxAnnotation.select('.annotation-text')\n    .style('cursor', 'help')\n    .style('pointer-events', 'all')\n    .on('click', () => {\n      d3.event.stopPropagation();\n      // Scroll to the article element\n      document.querySelector(`#article-softmax`).scrollIntoView({ \n        behavior: 'smooth' \n      });\n    })\n    .transition('softmax')\n    .duration(duration)\n    .style('opacity', isInSoftmax ? 1 : 0)\n    .on('end', () => {\n      if (!isInSoftmax) {\n        // Add new annotation for the softmax button\n        let textX = softmaxX + softmaxWidth / 2;\n        let textY = softmaxTextY - 10;\n\n        if (selectedI === 0) {\n          textY = softmaxTextY + 70;\n        }\n\n        let text = softmaxDetailAnnotation.append('text')\n          .attr('x', textX)\n          .attr('y', textY)\n          .attr('class', 'annotation-text softmax-detail-text')\n          .style('dominant-baseline', 'baseline')\n          .style('text-anchor', 'middle')\n          .text('Normalize ');\n        \n        text.append('tspan') \n          .attr('dx', 1)\n          .style('fill', '#E56014')\n          .text('logits');\n        \n        text.append('tspan')\n          .attr('dx', 1)\n          .text(' into');\n\n        text.append('tspan')\n          .attr('x', textX)\n          .attr('dy', '1.1em')\n          .text('class probabilities');\n\n        if (selectedI === 0) {\n          drawArrow({\n            group: softmaxDetailAnnotation,\n            sx: softmaxX + softmaxWidth / 2 - 5,\n            sy: softmaxTextY + 44,\n            tx: softmaxX + softmaxWidth / 2,\n            ty: textY - 12,\n            dr: 50,\n            hFlip: true,\n            marker: 'marker-alt'\n          });\n        } else {\n          drawArrow({\n            group: softmaxDetailAnnotation,\n            sx: softmaxX + softmaxWidth / 2 - 5,\n            sy: softmaxTextY + 4,\n            tx: softmaxX + softmaxWidth / 2,\n            ty: symbolY - plusSymbolRadius - 4,\n            dr: 50,\n            hFlip: true,\n            marker: 'marker-alt'\n          });\n        }\n\n        // Add annotation for the logit layer label\n        textX = centerX + 45;\n        textY = (svgPaddings.top + vSpaceAroundGap) / 2 + 5;\n        let arrowTX = centerX + 20;\n        let arrowTY = (svgPaddings.top + vSpaceAroundGap) / 2 + 5;\n\n        softmaxDetailAnnotation.append('g')\n          .attr('class', 'layer-detailed-label')\n          .attr('transform', () => {\n            let x = centerX;\n            let y = (svgPaddings.top + vSpaceAroundGap) / 2 - 5;\n            return `translate(${x}, ${y})`;\n          })\n          .classed('hidden', !detailedMode)\n          .append('text')\n          // .attr('x', centerX)\n          // .attr('y',  (svgPaddings.top + vSpaceAroundGap) / 2 - 6)\n          .style('opacity', 0.7)\n          .style('dominant-baseline', 'middle')\n          .style('font-size', '12px')\n          .style('font-weight', '800')\n          .append('tspan')\n          .attr('x', 0)\n          .text('logit')\n          .append('tspan')\n          .attr('x', 0)\n          .style('font-size', '8px')\n          .style('font-weight', 'normal')\n          .attr('dy', '1.5em')\n          .text('(10)');\n\n        softmaxDetailAnnotation.append('text')\n          .attr('class', 'annotation-text')\n          .attr('x', textX)\n          .attr('y', (svgPaddings.top + vSpaceAroundGap) / 2 + 3)\n          .style('text-anchor', 'start')\n          .text('Before')\n          .append('tspan')\n          .attr('x', textX)\n          .attr('dy', '1em')\n          .text('normalization')\n\n\n        drawArrow({\n          group: softmaxDetailAnnotation,\n          tx: arrowTX,\n          ty: arrowTY,\n          sx: textX - 6,\n          sy: textY + 2,\n          dr: 60,\n          hFlip: false,\n          marker: 'marker-alt'\n        });\n\n        softmaxDetailAnnotation.append('text')\n          .attr('class', 'annotation-text')\n          .attr('x', nodeCoordinate[layerIndexDict['output']][0].x - 35)\n          .attr('y', (svgPaddings.top + vSpaceAroundGap) / 2 + 3)\n          .style('text-anchor', 'end')\n          .text('After')\n          .append('tspan')\n          .attr('x', nodeCoordinate[layerIndexDict['output']][0].x - 35)\n          .attr('dy', '1em')\n          .text('normalization')\n\n        drawArrow({\n          group: softmaxDetailAnnotation,\n          tx: nodeCoordinate[layerIndexDict['output']][0].x - 8,\n          ty: arrowTY,\n          sx: nodeCoordinate[layerIndexDict['output']][0].x - 27,\n          sy: textY + 2,\n          dr: 60,\n          hFlip: true,\n          marker: 'marker-alt'\n        });\n\n        // Add annotation for the logit circle\n        for (let i = 0; i < 10; i++) {\n          softmaxDetailAnnotation.append('text')\n            .attr('x', centerX)\n            .attr('y', nodeCoordinate[curLayerIndex - 1][i].y + nodeLength / 2 + 8)\n            .attr('class', 'annotation-text softmax-detail-text')\n            .attr('id', `logit-text-${i}`)\n            .style('text-anchor', 'middle')\n            .style('dominant-baseline', 'hanging')\n            .style('opacity', 0)\n            .text(`${classList[i]}`);\n        }\n\n        let hoverTextGroup = softmaxDetailAnnotation.append('g')\n          .attr('class', 'softmax-detail-hover-annotation')\n          .style('opacity', 0);\n\n        textX = centerX + 50;\n        textY = nodeCoordinate[curLayerIndex - 1][0].y + nodeLength / 2;\n\n        if (selectedI < 3) {\n          textY = nodeCoordinate[curLayerIndex - 1][9].y + nodeLength / 2;\n        }\n\n        // Add annotation to prompt user to check the logit value\n        let hoverText = hoverTextGroup.append('text')\n          .attr('x', textX)\n          .attr('y', textY)\n          .attr('class', 'annotation-text softmax-detail-text softmax-hover-text')\n          .style('text-anchor', 'start')\n          .style('dominant-baseline', 'baseline')\n          .append('tspan')\n          .style('font-weight', 700)\n          .style('dominant-baseline', 'baseline')\n          .text(`Hover over `)\n          .append('tspan')\n          .style('font-weight', 400)\n          .style('dominant-baseline', 'baseline')\n          .text('to see');\n        \n        hoverText.append('tspan')\n          .style('dominant-baseline', 'baseline')\n          .attr('x', textX)\n          .attr('dy', '1em')\n          .text('its ');\n\n        hoverText.append('tspan')\n          .style('dominant-baseline', 'baseline')\n          .attr('dx', 1)\n          .style('fill', '#E56014')\n          .text('logit');\n        \n        hoverText.append('tspan')\n          .style('dominant-baseline', 'baseline')\n          .attr('dx', 1)\n          .text(' value');\n        \n        drawArrow({\n          group: hoverTextGroup,\n          tx: centerX + 15,\n          ty: textY,\n          sx: textX - 8,\n          sy: textY + 2,\n          dr: 60,\n          hFlip: false\n        });\n      }\n    })\n\n  // Hide the annotation\n  svg.select('.flatten-annotation')\n    .transition('softmax')\n    .duration(duration)\n    .style('opacity', isInSoftmax ? 1 : 0)\n    .style('pointer-events', isInSoftmax ? 'all' : 'none');\n\n  // Move the left part of faltten layer elements\n  let flattenLeftPart = svg.select('.flatten-layer-left');\n  flattenLeftPart.transition('softmax')\n    .duration(duration)\n    .ease(d3.easeCubicInOut)\n    .attr('transform', `translate(${isInSoftmax ? 0 : -moveX}, ${0})`)\n    .on('end', () => {\n      // Add the logit layer\n      if (!isInSoftmax) {\n        let logitArg = {\n          curLayerIndex: curLayerIndex,\n          moveX: moveX,\n          softmaxLeftMid: softmaxLeftMid,\n          selectedI: selectedI,\n          intermediateX1: intermediateX1,\n          intermediateX2: intermediateX2,\n          pixelWidth: pixelWidth,\n          pixelHeight: pixelHeight,\n          topY: topY,\n          bottomY: bottomY,\n          middleGap: middleGap,\n          middleRectHeight: middleRectHeight,\n          softmaxX: softmaxX,\n          symbolGroup: symbolGroup,\n          symbolX: symbolX,\n          flattenRange: flattenRange\n        };\n        drawLogitLayer(logitArg);\n      }\n\n      // Redraw the line from the plus symbol to the output node\n      if (!isInSoftmax) {\n        let newLine = flattenLeftPart.select('.edge-group')\n          .append('line')\n          .attr('class', 'symbol-output-line')\n          .attr('x1', symbolX)\n          .attr('y1', symbolY)\n          .attr('x2', outputX + moveX)\n          .attr('y2', outputY)\n          .style('stroke-width', 1.2)\n          .style('stroke', '#E5E5E5')\n          .style('opacity', 0);\n        \n        newLine.transition('softmax')\n          .delay(duration / 3)\n          .duration(duration * 2 / 3)\n          .style('opacity', 1);\n      } else {\n        flattenLeftPart.select('.symbol-output-line').remove();\n      }\n      \n      isInSoftmax = !isInSoftmax;\n      isInSoftmaxStore.set(isInSoftmax);\n    })\n}\n\n/**\n * Draw the flatten layer before output layer\n * @param {number} curLayerIndex Index of the selected layer\n * @param {object} d Bounded d3 data\n * @param {number} i Index of the selected node\n * @param {number} width CNN group width\n * @param {number} height CNN group height\n */\nexport const drawFlatten = (curLayerIndex, d, i, width, height) => {\n  // Show the output legend\n  svg.selectAll('.output-legend')\n    .classed('hidden', false);\n\n  let pixelWidth = nodeLength / 2;\n  let pixelHeight = 1.1;\n  let totalLength = (2 * nodeLength +\n    5.5 * hSpaceAroundGap * gapRatio + pixelWidth);\n  let leftX = nodeCoordinate[curLayerIndex][0].x - totalLength;\n  let intermediateGap = (hSpaceAroundGap * gapRatio * 4) / 2;\n  const minimumGap = 20;\n  let linkGen = d3.linkHorizontal()\n    .x(d => d.x)\n    .y(d => d.y);\n\n  // Hide the edges\n  svg.select('g.edge-group')\n    .style('visibility', 'hidden');\n\n  // Move the previous layer\n  moveLayerX({layerIndex: curLayerIndex - 1, targetX: leftX,\n    disable: true, delay: 0});\n\n  // Disable the current layer (output layer)\n  moveLayerX({layerIndex: curLayerIndex,\n    targetX: nodeCoordinate[curLayerIndex][0].x, disable: true,\n    delay: 0, opacity: 0.15, specialIndex: i});\n  \n  // Compute the gap in the left shrink region\n  let leftEnd = leftX - hSpaceAroundGap;\n  let leftGap = (leftEnd - nodeCoordinate[0][0].x - 10 * nodeLength) / 10;\n\n  // Different from other intermediate view, we push the left part dynamically\n  // 1. If there is enough space, we fix the first layer position and move all\n  // other layers;\n  // 2. If there is not enough space, we maintain the minimum gap and push all\n  // left layers to the left (could be out-of-screen)\n  if (leftGap > minimumGap) {\n    // Move the left layers\n    for (let i = 0; i < curLayerIndex - 1; i++) {\n      let curX = nodeCoordinate[0][0].x + i * (nodeLength + leftGap);\n      moveLayerX({layerIndex: i, targetX: curX, disable: true, delay: 0});\n    }\n  } else {\n    leftGap = minimumGap;\n    let curLeftBound = leftX - leftGap * 2 - nodeLength;\n    // Move the left layers\n    for (let i = curLayerIndex - 2; i >= 0; i--) {\n      moveLayerX({layerIndex: i, targetX: curLeftBound, disable: true, delay: 0});\n      curLeftBound = curLeftBound - leftGap - nodeLength;\n    }\n  }\n\n  // Add an overlay\n  let stops = [{offset: '0%', color: 'rgb(250, 250, 250)', opacity: 1},\n    {offset: '50%', color: 'rgb(250, 250, 250)', opacity: 0.95},\n    {offset: '100%', color: 'rgb(250, 250, 250)', opacity: 0.85}];\n  addOverlayGradient('overlay-gradient-left', stops);\n\n  let intermediateLayerOverlay = svg.append('g')\n    .attr('class', 'intermediate-layer-overlay');\n\n  intermediateLayerOverlay.append('rect')\n    .attr('class', 'overlay')\n    .style('fill', 'url(#overlay-gradient-left)')\n    .style('stroke', 'none')\n    .attr('width', leftX + svgPaddings.left - (leftGap * 2) + 3)\n    .attr('height', height + svgPaddings.top + svgPaddings.bottom)\n    .attr('x', -svgPaddings.left)\n    .attr('y', 0)\n    .style('opacity', 0);\n  \n  intermediateLayerOverlay.selectAll('rect.overlay')\n    .transition('move')\n    .duration(800)\n    .ease(d3.easeCubicInOut)\n    .style('opacity', 1);\n\n  // Add the intermediate layer\n  let intermediateLayer = svg.append('g')\n    .attr('class', 'intermediate-layer')\n    .style('opacity', 0);\n  \n  let intermediateX1 = leftX + nodeLength + intermediateGap;\n  let intermediateX2 = intermediateX1 + intermediateGap + pixelWidth;\n  let range = cnnLayerRanges[selectedScaleLevel][curLayerIndex - 1];\n  let colorScale = layerColorScales.conv;\n  let flattenLength = cnn.flatten.length / cnn[1].length;\n  let linkData = [];\n\n  let flattenLayer = intermediateLayer.append('g')\n    .attr('class', 'flatten-layer');\n  \n  let flattenLayerLeftPart = flattenLayer.append('g')\n    .attr('class', 'flatten-layer-left');\n  \n  let topY = nodeCoordinate[curLayerIndex - 1][0].y;\n  let bottomY = nodeCoordinate[curLayerIndex - 1][9].y + nodeLength -\n        flattenLength * pixelHeight;\n  \n  // Compute the pre-layer gap\n  let preLayerDimension = cnn[curLayerIndex - 1][0].output.length;\n  let preLayerGap = nodeLength / (2 * preLayerDimension);\n\n  // Compute bounding box length\n  let boundingBoxLength = nodeLength / preLayerDimension;\n\n  // Compute the weight color scale\n  let flattenExtent = d3.extent(cnn.flatten.slice(flattenLength)\n    .map(d => d.outputLinks[i].weight)\n    .concat(cnn.flatten.slice(9 * flattenLength, 10 * flattenLength)\n      .map(d => d.outputLinks[i].weight)));\n\n  let flattenRange = 2 * (Math.round(\n    Math.max(...flattenExtent.map(Math.abs)) * 1000) / 1000);\n\n  let flattenMouseOverHandler = (d) => {\n    let index = d.index;\n    // Screenshot\n    // console.log(index);\n\n    // Update the hover info UI\n    if (d.weight === undefined) {\n      hoverInfo = {\n        show: true,\n        text: `Pixel value: ${formater(flattenFactoredFDict[index])}`\n      };\n    } else {\n      hoverInfo = {\n        show: true,\n        text: `Weight: ${formater(d.weight)}`\n      };\n    }\n    hoverInfoStore.set(hoverInfo);\n\n    flattenLayerLeftPart.select(`#edge-flatten-${index}`)\n      .raise()\n      .style('stroke', intermediateColor)\n      .style('stroke-width', 1);\n\n    flattenLayerLeftPart.select(`#edge-flatten-${index}-output`)\n      .raise()\n      .style('stroke-width', 1)\n      .style('stroke', da => gappedColorScale(layerColorScales.weight,\n        flattenRange, da.weight, 0.1));\n\n    flattenLayerLeftPart.select(`#bounding-${index}`)\n      .raise()\n      .style('opacity', 1);\n  }\n\n  let flattenMouseLeaveHandler = (d) => {\n    let index = d.index;\n\n    // screenshot\n    // if (index === 32) {return;}\n\n    // Update the hover info UI\n    if (d.weight === undefined) {\n      hoverInfo = {\n        show: false,\n        text: `Pixel value: ${formater(flattenFactoredFDict[index])}`\n      };\n    } else {\n      hoverInfo = {\n        show: false,\n        text: `Weight: ${formater(d.weight)}`\n      };\n    }\n    hoverInfoStore.set(hoverInfo);\n\n    flattenLayerLeftPart.select(`#edge-flatten-${index}`)\n      .style('stroke-width', 0.6)\n      .style('stroke', '#E5E5E5')\n\n    flattenLayerLeftPart.select(`#edge-flatten-${index}-output`)\n      .style('stroke-width', 0.6)\n      .style('stroke', da => gappedColorScale(layerColorScales.weight,\n        flattenRange, da.weight, 0.35));\n\n    flattenLayerLeftPart.select(`#bounding-${index}`)\n      .raise()\n      .style('opacity', 0);\n  }\n\n  flattenFactoredFDict = {};\n  for (let f = 0; f < flattenLength; f++) {\n    let loopFactors = [0, 9];\n    loopFactors.forEach(l => {\n      let factoredF = f + l * flattenLength;\n      flattenFactoredFDict[factoredF] = cnn.flatten[factoredF].output;\n      flattenLayerLeftPart.append('rect')\n        .attr('x', intermediateX1)\n        .attr('y', l === 0 ? topY + f * pixelHeight : bottomY + f * pixelHeight)\n        .attr('width', pixelWidth)\n        .attr('height', pixelHeight)\n        .style('cursor', 'crosshair')\n        .style('fill', colorScale((cnn.flatten[factoredF].output + range / 2) / range))\n        .on('mouseover', () => flattenMouseOverHandler({index: factoredF}))\n        .on('mouseleave', () => flattenMouseLeaveHandler({index: factoredF}))\n        .on('click', () => { d3.event.stopPropagation() });\n\n      // Flatten -> output\n      linkData.push({\n        source: {x: intermediateX1 + pixelWidth + 3,\n          y:  l === 0 ? topY + f * pixelHeight : bottomY + f * pixelHeight},\n        target: {x: intermediateX2,\n          //nodeCoordinate[curLayerIndex][i].x - nodeLength,\n          y: nodeCoordinate[curLayerIndex][i].y + nodeLength / 2},\n        index: factoredF,\n        weight: cnn.flatten[factoredF].outputLinks[i].weight,\n        name: `flatten-${factoredF}-output`,\n        color: gappedColorScale(layerColorScales.weight,\n          flattenRange, cnn.flatten[factoredF].outputLinks[i].weight, 0.35),\n        width: 0.6,\n        opacity: 1,\n        class: `flatten-output`\n      });\n\n      // Pre-layer -> flatten\n      let row = Math.floor(f / preLayerDimension);\n      linkData.push({\n        target: {x: intermediateX1 - 3,\n          y:  l === 0 ? topY + f * pixelHeight : bottomY + f * pixelHeight},\n        source: {x: leftX + nodeLength + 3,\n          y: nodeCoordinate[curLayerIndex - 1][l].y + (2 * row + 1) * preLayerGap},\n        index: factoredF,\n        name: `flatten-${factoredF}`,\n        color: '#E5E5E5',\n        // color: gappedColorScale(layerColorScales.conv,\n        //   2 * Math.max(Math.abs(cnnLayerMinMax[10].max), Math.abs(cnnLayerMinMax[10].min)),\n        //   cnn.flatten[factoredF].output, 0.2),\n        width: 0.6,\n        opacity: 1,\n        class: `flatten`\n      });\n\n      // Add original pixel bounding box\n      let loc = cnn.flatten[factoredF].inputLinks[0].weight;\n      flattenLayerLeftPart.append('rect')\n        .attr('id', `bounding-${factoredF}`)\n        .attr('class', 'flatten-bounding')\n        .attr('x', leftX + loc[1] * boundingBoxLength)\n        .attr('y', nodeCoordinate[curLayerIndex - 1][l].y + loc[0] * boundingBoxLength)\n        .attr('width', boundingBoxLength)\n        .attr('height', boundingBoxLength)\n        .style('fill', 'none')\n        .style('stroke', intermediateColor)\n        .style('stroke-length', '0.5')\n        .style('pointer-events', 'all')\n        .style('cursor', 'crosshair')\n        .style('opacity', 0)\n        .on('mouseover', () => flattenMouseOverHandler({index: factoredF}))\n        .on('mouseleave', () => flattenMouseLeaveHandler({index: factoredF}))\n        .on('click', () => {d3.event.stopPropagation()});\n    }) \n  }\n  \n  // Use abstract symbol to represent the flatten nodes in between (between\n  // the first and the last nodes)\n  // Compute the average value of input node and weights\n  let meanValues = [];\n  for (let n = 1; n < cnn[curLayerIndex - 1].length - 1; n++) {\n    /*\n    let meanOutput = d3.mean(cnn.flatten.slice(flattenLength * n,\n      flattenLength * (n + 1)).map(d => d.output));\n    let meanWeight= d3.mean(cnn.flatten.slice(flattenLength * n,\n      flattenLength * (n + 1)).map(d => d.outputLinks[i].weight));\n    meanValues.push({index: n, output: meanOutput, weight: meanWeight});\n    */\n    meanValues.push({index: n});\n  }\n\n  // Compute the middle gap\n  let middleGap = 5;\n  let middleRectHeight = (10 * nodeLength + (10 - 1) * vSpaceAroundGap -\n    pixelHeight * flattenLength * 2 - 5 * (8 + 1)) / 8;\n\n  // Add middle nodes\n  meanValues.forEach((v, vi) => {\n    // Add a small rectangle\n    flattenLayerLeftPart.append('rect')\n      .attr('x', intermediateX1 + pixelWidth / 4)\n      .attr('y', topY + flattenLength * pixelHeight + middleGap * (vi + 1) +\n        middleRectHeight * vi)\n      .attr('width', pixelWidth / 2)\n      .attr('height', middleRectHeight)\n      // .style('fill', colorScale((v.output + range / 2) / range));\n      .style('fill', '#E5E5E5');\n    \n    // Add a triangle next to the input node\n    flattenLayerLeftPart.append('polyline')\n      .attr('points',\n        `${leftX + nodeLength + 3}\n        ${nodeCoordinate[curLayerIndex - 1][v.index].y},\n        ${leftX + nodeLength + 10}\n        ${nodeCoordinate[curLayerIndex - 1][v.index].y + nodeLength / 2},\n        ${leftX + nodeLength + 3}\n        ${nodeCoordinate[curLayerIndex - 1][v.index].y + nodeLength}`)\n      .style('fill', '#E5E5E5')\n      .style('opacity', 1);\n    \n    // Input -> flatten\n    linkData.push({\n      source: {x: leftX + nodeLength + 10,\n        y: nodeCoordinate[curLayerIndex - 1][v.index].y + nodeLength / 2},\n      target: {x: intermediateX1 - 3,\n        y: topY + flattenLength * pixelHeight + middleGap * (vi + 1) +\n          middleRectHeight * (vi + 0.5)},\n      index: -1,\n      width: 1,\n      opacity: 1,\n      name: `flatten-abstract-${v.index}`,\n      color: '#E5E5E5',\n      class: `flatten-abstract`\n    });\n\n    // Flatten -> output\n    linkData.push({\n      source: {x: intermediateX1 + pixelWidth + 3,\n      y: topY + flattenLength * pixelHeight + middleGap * (vi + 1) +\n        middleRectHeight * (vi + 0.5)},\n      target: {x: intermediateX2,\n      y: nodeCoordinate[curLayerIndex][i].y + nodeLength / 2},\n      index: -1,\n      name: `flatten-abstract-${v.index}-output`,\n      // color: gappedColorScale(layerColorScales.weight, flattenRange,\n      //   v.weight, 0.35),\n      color: '#E5E5E5',\n      weight: v.weight,\n      width: 1,\n      opacity: 1,\n      class: `flatten-abstract-output`\n    });\n  })\n\n  // Draw the plus operation symbol\n  let symbolX = intermediateX2 + plusSymbolRadius;\n  let symbolY = nodeCoordinate[curLayerIndex][i].y + nodeLength / 2;\n  let symbolRectHeight = 1;\n  let symbolGroup = flattenLayerLeftPart.append('g')\n    .attr('class', 'plus-symbol')\n    .attr('transform', `translate(${symbolX}, ${symbolY})`);\n  \n  symbolGroup.append('rect')\n    .attr('x', -plusSymbolRadius)\n    .attr('y', -plusSymbolRadius)\n    .attr('width', plusSymbolRadius * 2)\n    .attr('height', plusSymbolRadius * 2)\n    .attr('rx', 3)\n    .attr('ry', 3)\n    .style('fill', 'none')\n    .style('stroke', intermediateColor);\n  \n  symbolGroup.append('rect')\n    .attr('x', -(plusSymbolRadius - 3))\n    .attr('y', -symbolRectHeight / 2)\n    .attr('width', 2 * (plusSymbolRadius - 3))\n    .attr('height', symbolRectHeight)\n    .style('fill', intermediateColor);\n\n  symbolGroup.append('rect')\n    .attr('x', -symbolRectHeight / 2)\n    .attr('y', -(plusSymbolRadius - 3))\n    .attr('width', symbolRectHeight)\n    .attr('height', 2 * (plusSymbolRadius - 3))\n    .style('fill', intermediateColor);\n\n  // Place the bias rectangle below the plus sign if user clicks the first\n  // conv node (no need now, since we added annotaiton for softmax to make it\n  // look better aligned)\n  // Add bias symbol to the plus symbol\n  symbolGroup.append('circle')\n    .attr('cx', 0)\n    .attr('cy', -nodeLength / 2 - 0.5 * kernelRectLength)\n    .attr('r', kernelRectLength * 1.5)\n    .style('stroke', intermediateColor)\n    .style('cursor', 'crosshair')\n    .style('fill', gappedColorScale(layerColorScales.weight,\n        flattenRange, d.bias, 0.35))\n    .on('mouseover', () => {\n      hoverInfoStore.set( {show: true, text: `Bias: ${formater(d.bias)}`} );\n    })\n    .on('mouseleave', () => {\n      hoverInfoStore.set( {show: false, text: `Bias: ${formater(d.bias)}`} );\n    })\n    .on('click', () => { d3.event.stopPropagation(); });\n  \n  // Link from bias to the plus symbol\n  symbolGroup.append('path')\n    .attr('d', linkGen({\n      source: { x: 0, y: 0 },\n      target: { x: 0, y: -nodeLength / 2 - 0.5 * kernelRectLength }\n    }))\n    .attr('id', 'bias-plus')\n    .attr('stroke-width', 1.2)\n    .attr('stroke', '#E5E5E5')\n    .lower();\n\n  // Link from the plus symbol to the output\n  linkData.push({\n    source: getOutputKnot({x: intermediateX2 + 2 * plusSymbolRadius - nodeLength,\n      y: nodeCoordinate[curLayerIndex][i].y}),\n    target: getInputKnot({x: nodeCoordinate[curLayerIndex][i].x - 3,\n      y: nodeCoordinate[curLayerIndex][i].y}),\n    name: `symbol-output`,\n    width: 1.2,\n    color: '#E5E5E5'\n  });\n\n  // Draw softmax operation symbol\n  let softmaxWidth = 55;\n  let emptySpace = ((totalLength - 2 * nodeLength - 2 * intermediateGap)\n    - softmaxWidth) / 2;\n  let symbolEndX = intermediateX2 + plusSymbolRadius * 2;\n  let softmaxX = emptySpace + symbolEndX;\n  let softmaxLeftMid = emptySpace / 2 + symbolEndX;\n  let softmaxTextY = nodeCoordinate[curLayerIndex][i].y - 2 * kernelRectLength - 6;\n  let moveX = (intermediateX2 - (intermediateX1 + pixelWidth + 3)) * 2 / 3;\n\n  let softmaxArg = {\n    curLayerIndex: curLayerIndex,\n    moveX: moveX,\n    symbolX: symbolX,\n    symbolY: symbolY,\n    outputX: nodeCoordinate[curLayerIndex][i].x,\n    outputY: symbolY,\n    softmaxLeftMid: softmaxLeftMid,\n    selectedI: i,\n    intermediateX1: intermediateX1,\n    intermediateX2: intermediateX2,\n    pixelWidth: pixelWidth,\n    pixelHeight: pixelHeight,\n    topY: topY,\n    bottomY: bottomY,\n    middleGap: middleGap,\n    middleRectHeight: middleRectHeight,\n    softmaxX: softmaxX,\n    softmaxWidth: softmaxWidth,\n    softmaxTextY: softmaxTextY,\n    symbolGroup: symbolGroup,\n    flattenRange: flattenRange\n  };\n\n  let softmaxSymbol = intermediateLayer.append('g')\n    .attr('class', 'softmax-symbol')\n    .attr('transform', `translate(${softmaxX}, ${symbolY})`)\n    .style('pointer-event', 'all')\n    .style('cursor', 'pointer')\n    .on('click', () => softmaxClicked(softmaxArg));\n  \n  softmaxSymbol.append('rect')\n    .attr('x', 0)\n    .attr('y', -plusSymbolRadius)\n    .attr('width', softmaxWidth)\n    .attr('height', plusSymbolRadius * 2)\n    .attr('stroke', intermediateColor)\n    .attr('rx', 2)\n    .attr('ry', 2)\n    .attr('fill', '#FAFAFA');\n  \n  softmaxSymbol.append('text')\n    .attr('x', 5)\n    .attr('y', 1)\n    .style('dominant-baseline', 'middle')\n    .style('font-size', '12px')\n    .style('opacity', 0.5)\n    .text('softmax');\n\n  // Draw the layer label\n  let layerLabel = intermediateLayer.append('g')\n    .attr('class', 'layer-label')\n    .classed('hidden', detailedMode)\n    .attr('transform', () => {\n      let x = leftX + nodeLength + (4 * hSpaceAroundGap * gapRatio +\n        pixelWidth) / 2;\n      let y = (svgPaddings.top + vSpaceAroundGap) / 2 + 5;\n      return `translate(${x}, ${y})`;\n    })\n    .style('cursor', 'help')\n    .on('click', () => {\n      d3.event.stopPropagation();\n      // Scroll to the article element\n      document.querySelector(`#article-flatten`).scrollIntoView({ \n        behavior: 'smooth' \n      });\n    });\n  \n  layerLabel.append('text')\n    .style('dominant-baseline', 'middle')\n    .style('opacity', 0.8)\n    .style('font-weight', 800)\n    .text('flatten');\n\n  let svgHeight = Number(d3.select('#cnn-svg').style('height').replace('px', '')) + 150;\n  let scroll = new SmoothScroll('a[href*=\"#\"]', {offset: -svgHeight});\n    \n  let detailedLabelGroup = intermediateLayer.append('g')\n    .attr('transform', () => {\n      let x = leftX + nodeLength + (4 * hSpaceAroundGap * gapRatio + pixelWidth) / 2;\n      let y = (svgPaddings.top + vSpaceAroundGap) / 2 - 5;\n      return `translate(${x}, ${y})`;\n    })\n    .attr('class', 'layer-detailed-label')\n    .classed('hidden', !detailedMode)\n    .style('cursor', 'help')\n    .on('click', () => {\n      d3.event.stopPropagation();\n      // Scroll to the article element\n      let anchor = document.querySelector(`#article-flatten`);\n      scroll.animateScroll(anchor);\n    });\n  \n  detailedLabelGroup.append('title')\n    .text('Move to article section');\n\n  let detailedLabelText = detailedLabelGroup.append('text')\n    .style('text-anchor', 'middle')\n    .style('dominant-baseline', 'middle')\n    .style('opacity', '0.7')\n    .style('font-weight', 800)\n    .append('tspan')\n    .text('flatten');\n  \n  let dimension = cnn[layerIndexDict['max_pool_2']].length * \n    cnn[layerIndexDict['max_pool_2']][0].output.length *\n    cnn[layerIndexDict['max_pool_2']][0].output[0].length;\n\n  detailedLabelText.append('tspan')\n    .attr('x', 0)\n    .attr('dy', '1.5em')\n    .style('font-size', '8px')\n    .style('font-weight', 'normal')\n    .text(`(${dimension})`);\n\n  // Add edges between nodes\n  let edgeGroup = flattenLayerLeftPart.append('g')\n    .attr('class', 'edge-group')\n    .lower();\n  \n  edgeGroup.selectAll('path')\n    .data(linkData)\n    .enter()\n    .append('path')\n    .attr('class', d => d.class)\n    .attr('id', d => `edge-${d.name}`)\n    .attr('d', d => linkGen({source: d.source, target: d.target}))\n    .style('fill', 'none')\n    .style('stroke-width', d => d.width)\n    .style('stroke', d => d.color === undefined ? intermediateColor : d.color)\n    .style('opacity', d => d.opacity);\n  \n  edgeGroup.selectAll('path.flatten-abstract-output')\n    .lower();\n\n  edgeGroup.selectAll('path.flatten,path.flatten-output')\n    .style('cursor', 'crosshair')\n    .style('pointer-events', 'all')\n    .on('mouseover', flattenMouseOverHandler)\n    .on('mouseleave', flattenMouseLeaveHandler)\n    .on('click', () => { d3.event.stopPropagation() });\n  \n  // Add legend\n  drawIntermediateLayerLegend({\n    legendHeight: 5,\n    curLayerIndex: curLayerIndex,\n    range: range,\n    minMax: cnnLayerMinMax[10],\n    group: intermediateLayer,\n    width: intermediateGap + nodeLength - 3,\n    x: leftX,\n    y: svgPaddings.top + vSpaceAroundGap * (10) + vSpaceAroundGap + \n      nodeLength * 10\n  });\n\n  drawIntermediateLayerLegend({\n    legendHeight: 5,\n    curLayerIndex: curLayerIndex,\n    range: flattenRange,\n    minMax: {min: flattenExtent[0], max: flattenExtent[1]},\n    group: intermediateLayer,\n    width: intermediateGap - 3 - 5,\n    gradientAppendingName: 'flatten-weight-gradient',\n    gradientGap: 0.1,\n    colorScale: layerColorScales.weight,\n    x: leftX + intermediateGap + nodeLength + pixelWidth + 3,\n    y: svgPaddings.top + vSpaceAroundGap * (10) + vSpaceAroundGap + \n      nodeLength * 10\n  });\n\n  // Add annotation to the intermediate layer\n  let intermediateLayerAnnotation = svg.append('g')\n    .attr('class', 'intermediate-layer-annotation')\n    .style('opacity', 0);\n\n  // Add annotation for the sum operation\n  let plusAnnotation = intermediateLayerAnnotation.append('g')\n    .attr('class', 'plus-annotation');\n  \n  // let textX = nodeCoordinate[curLayerIndex][i].x - 50;\n  let textX = intermediateX2;\n  let textY = nodeCoordinate[curLayerIndex][i].y + nodeLength +\n    kernelRectLength * 3;\n  let arrowSY = nodeCoordinate[curLayerIndex][i].y + nodeLength +\n    kernelRectLength * 2;\n  let arrowTY = nodeCoordinate[curLayerIndex][i].y + nodeLength / 2 +\n    plusSymbolRadius;\n\n  if (i == 9) {\n    textY -= 110;\n    arrowSY -= 70;\n    arrowTY -= 18;\n  }\n\n  let plusText = plusAnnotation.append('text')\n    .attr('x', textX)\n    .attr('y', textY)\n    .attr('class', 'annotation-text')\n    .style('dominant-baseline', 'hanging')\n    .style('text-anchor', 'middle');\n  \n  plusText.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .text('Add up all products');\n  \n  plusText.append('tspan')\n    .attr('x', textX)\n    .attr('dy', '1em')\n    .style('dominant-baseline', 'hanging')\n    .text('(');\n\n  plusText.append('tspan')\n    .style('fill', '#66a3c8')\n    .style('dominant-baseline', 'hanging')\n    .text('element');\n\n  plusText.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .text('  ');\n\n  plusText.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .style('fill', '#b58946')\n    .text('weight');\n\n  plusText.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .text(')');\n\n  plusText.append('tspan')\n    .attr('x', textX)\n    .attr('dy', '1em')\n    .style('dominant-baseline', 'hanging')\n    .text('and then ');\n\n  plusText.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .style('fill', '#479d94')\n    .text('bias');\n  \n  drawArrow({\n    group: plusAnnotation,\n    sx: intermediateX2 - 2 * plusSymbolRadius - 3,\n    sy: arrowSY,\n    tx: intermediateX2 - 5,\n    ty: arrowTY,\n    dr: 30,\n    hFlip: i === 9,\n    marker: 'marker-alt'\n  });\n\n  // Add annotation for the bias\n  let biasTextY = nodeCoordinate[curLayerIndex][i].y;\n  biasTextY -= 2 * kernelRectLength + 4;\n  \n  flattenLayerLeftPart.append('text')\n    .attr('class', 'annotation-text')\n    .attr('x', intermediateX2 + plusSymbolRadius)\n    .attr('y', biasTextY)\n    .style('text-anchor', 'middle')\n    .style('dominant-baseline', 'baseline')\n    .text('Bias');\n  \n  // Add annotation for the softmax symbol\n  let softmaxAnnotation = intermediateLayerAnnotation.append('g')\n    .attr('class', 'softmax-annotation');\n  \n  softmaxAnnotation.append('text')\n    .attr('x', softmaxX + softmaxWidth / 2)\n    .attr('y', softmaxTextY)\n    .attr('class', 'annotation-text')\n    .style('dominant-baseline', 'baseline')\n    .style('text-anchor', 'middle')\n    .style('font-weight', 700)\n    .text('Click ')\n    .append('tspan')\n    .attr('dx', 1)\n    .style('font-weight', 400)\n    .text('to learn more');\n\n  drawArrow({\n    group: softmaxAnnotation,\n    sx: softmaxX + softmaxWidth / 2 - 5,\n    sy: softmaxTextY + 4,\n    tx: softmaxX + softmaxWidth / 2,\n    ty: symbolY - plusSymbolRadius - 4,\n    dr: 50,\n    hFlip: true\n  });\n\n  // Add annotation for the flatten layer\n  let flattenAnnotation = intermediateLayerAnnotation.append('g')\n    .attr('class', 'flatten-annotation');\n  \n  textX = leftX - 80;\n  textY = nodeCoordinate[curLayerIndex - 1][0].y;\n\n  let flattenText = flattenAnnotation.append('text')\n    .attr('x', textX)\n    .attr('y', textY)\n    .attr('class', 'annotation-text')\n    .style('dominant-baseline', 'hanging')\n    .style('text-anchor', 'middle');\n\n  let tempTspan = flattenText.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .style('font-weight', 700)\n    .text('Hover over ');\n  \n  tempTspan.append('tspan')\n    .attr('dx', 1)\n    .style('font-weight', 400)\n    .style('dominant-baseline', 'hanging')\n    .text('matrix to');\n  \n  flattenText.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .attr('x', textX)\n    .attr('dy', '1em')\n    .text('see how it is flattened');\n  \n  flattenText.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .attr('x', textX)\n    .attr('dy', '1em')\n    .text('into a 1D array!');\n\n  drawArrow({\n    group: flattenAnnotation,\n    sx: textX + 45,\n    sy: textY + nodeLength * 0.4 + 12,\n    tx: leftX - 10,\n    ty: textY + nodeLength / 2,\n    dr: 80,\n    hFlip: true\n  });\n\n  // Add annotation to explain the middle images\n  textY = nodeCoordinate[curLayerIndex - 1][1].y;\n\n  let middleText = flattenAnnotation.append('text')\n    .attr('x', textX)\n    .attr('y', textY)\n    .attr('class', 'annotation-text')\n    .style('dominant-baseline', 'hanging')\n    .style('text-anchor', 'middle');\n\n  middleText.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .text('Same flattening');\n  \n  middleText.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .attr('x', textX)\n    .attr('dy', '1em')\n    .text('operation for');\n\n  middleText.append('tspan')\n    .style('dominant-baseline', 'hanging')\n    .attr('x', textX)\n    .attr('dy', '1em')\n    .text('each neuron');\n\n  drawArrow({\n    group: flattenAnnotation,\n    sx: textX + 39,\n    sy: textY + 25,\n    tx: leftX - 10,\n    ty: textY + nodeLength / 2 - 2,\n    dr: 80,\n    hFlip: true,\n    marker: 'marker-alt'\n  });\n\n\n  // Add annotation for the output neuron\n  let outputAnnotation = intermediateLayerAnnotation.append('g')\n    .attr('class', 'output-annotation');\n  \n  outputAnnotation.append('text')\n    .attr('x', nodeCoordinate[layerIndexDict['output']][i].x)\n    .attr('y', nodeCoordinate[layerIndexDict['output']][i].y + 10)\n    .attr('class', 'annotation-text')\n    .text(`(${d3.format('.4f')(cnn[layerIndexDict['output']][i].output)})`);\n\n\n  /* Prototype of using arc to represent the flatten layer (future)\n  let pie = d3.pie()\n    .padAngle(0)\n    .sort(null)\n    .value(d => d.output)\n    .startAngle(0)\n    .endAngle(-Math.PI);\n\n  let radius = 490 / 2;\n  let arc = d3.arc()\n    .innerRadius(radius - 20)\n    .outerRadius(radius);\n\n  let arcs = pie(cnn.flatten);\n  console.log(arcs);\n\n  let test = svg.append('g')\n    .attr('class', 'test')\n    .attr('transform', 'translate(500, 250)');\n\n  test.selectAll(\"path\")\n    .data(arcs)\n    .join(\"path\")\n      .attr('class', 'arc')\n      .attr(\"fill\", d => colorScale((d.value + range/2) / range))\n      .attr(\"d\", arc);\n  */\n\n  // Show everything\n  svg.selectAll('g.intermediate-layer, g.intermediate-layer-annotation')\n    .transition()\n    .delay(500)\n    .duration(500)\n    .ease(d3.easeCubicInOut)\n    .style('opacity', 1);\n}","<script>\n  // Svelte functions\n  import { onMount } from 'svelte';\n  import {\n    cnnStore, svgStore, vSpaceAroundGapStore, hSpaceAroundGapStore,\n    nodeCoordinateStore, selectedScaleLevelStore, cnnLayerRangesStore,\n    needRedrawStore, cnnLayerMinMaxStore, detailedModeStore,\n    shouldIntermediateAnimateStore, isInSoftmaxStore, softmaxDetailViewStore,\n    hoverInfoStore, allowsSoftmaxAnimationStore, modalStore,\n    intermediateLayerPositionStore\n  } from '../stores.js';\n\n  // Svelte views\n  import ConvolutionView from '../detail-view/Convolutionview.svelte';\n  import ActivationView from '../detail-view/Activationview.svelte';\n  import PoolView from '../detail-view/Poolview.svelte';\n  import SoftmaxView from '../detail-view/Softmaxview.svelte';\n  import Modal from './Modal.svelte'\n  // import Article from '../article/Article.svelte';\n\n  // Overview functions\n  import { loadTrainedModel, constructCNN } from '../utils/cnn-tf.js';\n  import { overviewConfig } from '../config.js';\n\n  import {\n    addOverlayRect, drawConv1, drawConv2, drawConv3, drawConv4\n  } from './intermediate-draw.js';\n\n  import {\n    moveLayerX, addOverlayGradient\n  } from './intermediate-utils.js';\n\n  import {\n    drawFlatten, softmaxDetailViewMouseOverHandler, softmaxDetailViewMouseLeaveHandler\n  } from './flatten-draw.js';\n\n  import {\n    drawOutput, drawCNN, updateCNN, updateCNNLayerRanges, drawCustomImage\n  } from './overview-draw.js';\n\n\n  // View bindings\n  let overviewComponent;\n  let scaleLevelSet = new Set(['local', 'module', 'global']);\n  let selectedScaleLevel = 'local';\n  selectedScaleLevelStore.set(selectedScaleLevel);\n  let previousSelectedScaleLevel = selectedScaleLevel;\n  let wholeSvg = undefined;\n  let svg = undefined;\n\n  $: selectedScaleLevel, selectedScaleLevelChanged();\n\n  // Configs\n  const layerColorScales = overviewConfig.layerColorScales;\n  const nodeLength = overviewConfig.nodeLength;\n  const plusSymbolRadius = overviewConfig.plusSymbolRadius;\n  const numLayers = overviewConfig.numLayers;\n  const edgeOpacity = overviewConfig.edgeOpacity;\n  const edgeInitColor = overviewConfig.edgeInitColor;\n  const edgeHoverColor = overviewConfig.edgeHoverColor;\n  const edgeHoverOuting = overviewConfig.edgeHoverOuting;\n  const edgeStrokeWidth = overviewConfig.edgeStrokeWidth;\n  const intermediateColor = overviewConfig.intermediateColor;\n  const kernelRectLength = overviewConfig.kernelRectLength;\n  const svgPaddings = overviewConfig.svgPaddings;\n  const gapRatio = overviewConfig.gapRatio;\n  const overlayRectOffset = overviewConfig.overlayRectOffset;\n  const classLists = overviewConfig.classLists;\n\n  // Shared properties\n  let needRedraw = [undefined, undefined];\n  needRedrawStore.subscribe( value => {needRedraw = value;} );\n\n  let nodeCoordinate = undefined;\n  nodeCoordinateStore.subscribe( value => {nodeCoordinate = value;} )\n\n  let cnnLayerRanges = undefined;\n  cnnLayerRangesStore.subscribe( value => {cnnLayerRanges = value;} )\n\n  let cnnLayerMinMax = undefined;\n  cnnLayerMinMaxStore.subscribe( value => {cnnLayerMinMax = value;} )\n\n  let detailedMode = undefined;\n  detailedModeStore.subscribe( value => {detailedMode = value;} )\n\n  let shouldIntermediateAnimate = undefined;\n  shouldIntermediateAnimateStore.subscribe(value => {\n    shouldIntermediateAnimate = value;\n  })\n\n  let vSpaceAroundGap = undefined;\n  vSpaceAroundGapStore.subscribe( value => {vSpaceAroundGap = value;} )\n\n  let hSpaceAroundGap = undefined;\n  hSpaceAroundGapStore.subscribe( value => {hSpaceAroundGap = value;} )\n\n  let isInSoftmax = undefined;\n  isInSoftmaxStore.subscribe( value => {isInSoftmax = value;} )\n\n  let softmaxDetailViewInfo = undefined;\n  softmaxDetailViewStore.subscribe( value => {\n    softmaxDetailViewInfo = value;\n  } )\n\n  let modalInfo = undefined;\n  modalStore.subscribe( value => {modalInfo = value;} )\n\n  let hoverInfo = undefined;\n  hoverInfoStore.subscribe( value => {hoverInfo = value;} )\n\n  let intermediateLayerPosition = undefined;\n  intermediateLayerPositionStore.subscribe ( value => {intermediateLayerPosition = value;} )\n\n  let width = undefined;\n  let height = undefined;\n  let model = undefined;\n  let selectedNode = {layerName: '', index: -1, data: null};\n  let isInIntermediateView = false;\n  let isInActPoolDetailView = false;\n  let actPoolDetailViewNodeIndex = -1;\n  let actPoolDetailViewLayerIndex = -1;\n  let detailedViewNum = undefined;\n  let disableControl = false;\n\n  // Wait to load\n  let cnn = undefined;\n\n  let detailedViewAbsCoords = {\n    1 : [600, 270, 490, 290],\n    2: [500, 270, 490, 290],\n    3 : [700, 270, 490, 290],\n    4: [600, 270, 490, 290],\n    5: [650, 270, 490, 290],\n    6 : [775, 270, 490, 290],\n    7 : [100, 270, 490, 290],\n    8 : [60, 270, 490, 290],\n    9 : [200, 270, 490, 290],\n    10 : [300, 270, 490, 290],\n  }\n\n  const layerIndexDict = {\n    'input': 0,\n    'conv_1_1': 1,\n    'relu_1_1': 2,\n    'conv_1_2': 3,\n    'relu_1_2': 4,\n    'max_pool_1': 5,\n    'conv_2_1': 6,\n    'relu_2_1': 7,\n    'conv_2_2': 8,\n    'relu_2_2': 9,\n    'max_pool_2': 10,\n    'output': 11\n  }\n\n  const layerLegendDict = {\n    0: {local: 'input-legend', module: 'input-legend', global: 'input-legend'},\n    1: {local: 'local-legend-0-1', module: 'module-legend-0', global: 'global-legend'},\n    2: {local: 'local-legend-0-1', module: 'module-legend-0', global: 'global-legend'},\n    3: {local: 'local-legend-0-2', module: 'module-legend-0', global: 'global-legend'},\n    4: {local: 'local-legend-0-2', module: 'module-legend-0', global: 'global-legend'},\n    5: {local: 'local-legend-0-2', module: 'module-legend-0', global: 'global-legend'},\n    6: {local: 'local-legend-1-1', module: 'module-legend-1', global: 'global-legend'},\n    7: {local: 'local-legend-1-1', module: 'module-legend-1', global: 'global-legend'},\n    8: {local: 'local-legend-1-2', module: 'module-legend-1', global: 'global-legend'},\n    9: {local: 'local-legend-1-2', module: 'module-legend-1', global: 'global-legend'},\n    10: {local: 'local-legend-1-2', module: 'module-legend-1', global: 'global-legend'},\n    11: {local: 'output-legend', module: 'output-legend', global: 'output-legend'}\n  }\n\n  let imageOptions = [\n    {file: 'boat_1.jpeg', class: 'lifeboat'},\n    {file: 'bug_1.jpeg', class: 'ladybug'},\n    {file: 'pizza_1.jpeg', class: 'pizza'},\n    {file: 'pepper_1.jpeg', class: 'bell pepper'},\n    {file: 'bus_1.jpeg', class: 'bus'},\n    {file: 'koala_1.jpeg', class: 'koala'},\n    {file: 'espresso_1.jpeg', class: 'espresso'},\n    {file: 'panda_1.jpeg', class: 'red panda'},\n    {file: 'orange_1.jpeg', class: 'orange'},\n    {file: 'car_1.jpeg', class: 'sport car'}\n  ];\n  let selectedImage = imageOptions[6].file;\n\n  let nodeData;\n  let selectedNodeIndex = -1;\n  let isExitedFromDetailedView = true;\n  let isExitedFromCollapse = true;\n  let customImageURL = null;\n\n  // Helper functions\n  const selectedScaleLevelChanged = () => {\n    if (svg !== undefined) {\n      if (!scaleLevelSet.add(selectedScaleLevel)) {\n        console.error('Encounter unknown scale level!');\n      }\n\n      // Update nodes and legends\n      if (selectedScaleLevel != previousSelectedScaleLevel){\n        // We can simply redraw all nodes using the new color scale, or we can\n        // make it faster by only redraw certian nodes\n        let updatingLayerIndexDict = {\n          local: {\n            module: [1, 2, 8, 9, 10],\n            global: [1, 2, 3, 4, 5, 8, 9, 10]\n          },\n          module: {\n            local: [1, 2, 8, 9, 10],\n            global: [1, 2, 3, 4, 5, 8, 9, 10]\n          },\n          global: {\n            local: [1, 2, 3, 4, 5, 8, 9, 10],\n            module: [1, 2, 3, 4, 5]\n          }\n        };\n\n        let updatingLayerIndex = updatingLayerIndexDict[\n          previousSelectedScaleLevel][selectedScaleLevel];\n\n        updatingLayerIndex.forEach(l => {\n          let range = cnnLayerRanges[selectedScaleLevel][l];\n          svg.select(`#cnn-layer-group-${l}`)\n            .selectAll('.node-image')\n            .each((d, i, g) => drawOutput(d, i, g, range));\n        });\n \n        // Hide previous legend\n        svg.selectAll(`.${previousSelectedScaleLevel}-legend`)\n          .classed('hidden', true);\n\n        // Show selected legends\n        svg.selectAll(`.${selectedScaleLevel}-legend`)\n          .classed('hidden', !detailedMode);\n      }\n      previousSelectedScaleLevel = selectedScaleLevel;\n      selectedScaleLevelStore.set(selectedScaleLevel);\n    }\n  }\n\n  const intermediateNodeMouseOverHandler = (d, i, g) => {\n    if (detailedViewNum !== undefined) { return; }\n    svg.select(`rect#underneath-gateway-${d.index}`)\n      .style('opacity', 1);\n  }\n\n  const intermediateNodeMouseLeaveHandler = (d, i, g) => {\n    // screenshot\n    // return;\n    if (detailedViewNum !== undefined) { return; }\n    svg.select(`rect#underneath-gateway-${d.index}`)\n      .style('opacity', 0);\n  }\n\n  const intermediateNodeClicked = (d, i, g, selectedI, curLayerIndex) => {\n    d3.event.stopPropagation();\n    isExitedFromCollapse = false;\n    // Use this event to trigger the detailed view\n    if (detailedViewNum === d.index) {\n      // Setting this for testing purposes currently.\n      selectedNodeIndex = -1; \n      // User clicks this node again -> rewind\n      detailedViewNum = undefined;\n      svg.select(`rect#underneath-gateway-${d.index}`)\n        .style('opacity', 0);\n    } \n    // We need to show a new detailed view (two cases: if we need to close the\n    // old detailed view or not)\n    else {\n      // Setting this for testing purposes currently.\n      selectedNodeIndex = d.index;\n      let inputMatrix = d.output;\n      let kernelMatrix = d.outputLinks[selectedI].weight;\n      // let interMatrix = singleConv(inputMatrix, kernelMatrix);\n      let colorScale = layerColorScales.conv;\n\n      // Compute the color range\n      let rangePre = cnnLayerRanges[selectedScaleLevel][curLayerIndex - 1];\n      let rangeCur = cnnLayerRanges[selectedScaleLevel][curLayerIndex];\n      let range = Math.max(rangePre, rangeCur);\n\n      // User triggers a different detailed view\n      if (detailedViewNum !== undefined) {\n        // Change the underneath highlight\n        svg.select(`rect#underneath-gateway-${detailedViewNum}`)\n          .style('opacity', 0);\n        svg.select(`rect#underneath-gateway-${d.index}`)\n          .style('opacity', 1);\n      }\n      \n      // Dynamically position the detail view\n      let wholeSvg = d3.select('#cnn-svg');\n      let svgYMid = +wholeSvg.style('height').replace('px', '') / 2;\n      let svgWidth = +wholeSvg.style('width').replace('px', '');\n      let detailViewTop = 100 + svgYMid - 250 / 2;\n      let positionX = intermediateLayerPosition[Object.keys(layerIndexDict)[curLayerIndex]];\n\n      let posX = 0;\n      if (curLayerIndex > 6) {\n        posX = (positionX - svgPaddings.left) / 2;\n        posX = svgPaddings.left + posX - 486 / 2;\n      } else {\n        posX = (svgWidth + svgPaddings.right - positionX) / 2;\n        posX = positionX + posX - 486 / 2;\n      }\n\n      const detailview = document.getElementById('detailview');\n      detailview.style.top = `${detailViewTop}px`;\n      detailview.style.left = `${posX}px`;\n      detailview.style.position = 'absolute';\n\n      detailedViewNum = d.index;\n\n      // Send the currently used color range to detailed view\n      nodeData.colorRange = range;\n      nodeData.inputIsInputLayer = curLayerIndex <= 1;\n    }\n  }\n\n  // The order of the if/else statements in this function is very critical\n  const emptySpaceClicked = () => {\n    // If detail view -> rewind to intermediate view\n    if (detailedViewNum !== undefined) {\n          // Setting this for testing purposes currently.\n      selectedNodeIndex = -1; \n      // User clicks this node again -> rewind\n      svg.select(`rect#underneath-gateway-${detailedViewNum}`)\n        .style('opacity', 0);\n      detailedViewNum = undefined;\n    }\n\n    // If softmax view -> rewind to flatten layer view\n    else if (isInSoftmax) {\n      svg.select('.softmax-symbol')\n        .dispatch('click');\n    }\n\n    // If intermediate view -> rewind to overview\n    else if (isInIntermediateView) {\n      let curLayerIndex = layerIndexDict[selectedNode.layerName];\n      quitIntermediateView(curLayerIndex, selectedNode.domG, selectedNode.domI);\n      d3.select(selectedNode.domG[selectedNode.domI])\n        .dispatch('mouseleave');\n    }\n\n    // If pool/act detail view -> rewind to overview\n    else if (isInActPoolDetailView) {\n      quitActPoolDetailView();\n    }\n  }\n\n  const prepareToEnterIntermediateView = (d, g, i, curLayerIndex) => {\n    isInIntermediateView = true;\n    // Hide all legends\n    svg.selectAll(`.${selectedScaleLevel}-legend`)\n      .classed('hidden', true);\n    svg.selectAll('.input-legend').classed('hidden', true);\n    svg.selectAll('.output-legend').classed('hidden', true);\n\n    // Hide the input annotation\n    svg.select('.input-annotation')\n      .classed('hidden', true);\n\n    // Highlight the previous layer and this node\n    svg.select(`g#cnn-layer-group-${curLayerIndex - 1}`)\n      .selectAll('rect.bounding')\n      .style('stroke-width', 2);\n    \n    d3.select(g[i])\n      .select('rect.bounding')\n      .style('stroke-width', 2);\n    \n    // Disable control panel UI\n    // d3.select('#level-select').property('disabled', true);\n    // d3.selectAll('.image-container')\n    //   .style('cursor', 'not-allowed')\n    //   .on('mouseclick', () => {});\n    disableControl = true;\n    \n    // Allow infinite animation loop\n    shouldIntermediateAnimateStore.set(true);\n\n    // Highlight the labels\n    svg.selectAll(`g#layer-label-${curLayerIndex - 1},\n      g#layer-detailed-label-${curLayerIndex - 1},\n      g#layer-label-${curLayerIndex},\n      g#layer-detailed-label-${curLayerIndex}`)\n      .style('font-weight', '800');\n    \n    // Register a handler on the svg element so user can click empty space to quit\n    // the intermediate view\n    d3.select('#cnn-svg')\n      .on('click', emptySpaceClicked);\n  }\n\n  const quitActPoolDetailView = () => {\n    isInActPoolDetailView = false;\n    actPoolDetailViewNodeIndex = -1;\n\n    let layerIndex = layerIndexDict[selectedNode.layerName];\n    let nodeIndex = selectedNode.index;\n    svg.select(`g#layer-${layerIndex}-node-${nodeIndex}`)\n      .select('rect.bounding')\n      .classed('hidden', true);\n\n    selectedNode.data.inputLinks.forEach(link => {\n      let layerIndex = layerIndexDict[link.source.layerName];\n      let nodeIndex = link.source.index;\n      svg.select(`g#layer-${layerIndex}-node-${nodeIndex}`)\n        .select('rect.bounding')\n        .classed('hidden', true);\n    })\n\n    // Clean up the underneath rects\n    svg.select('g.underneath')\n      .selectAll('rect')\n      .remove();\n\n    // Show all edges\n    let unimportantEdges = svg.select('g.edge-group')\n      .selectAll('.edge')\n      .filter(d => {\n        return d.targetLayerIndex !== actPoolDetailViewLayerIndex;\n      })\n      .style('visibility', null);\n    \n    // Recover control UI\n    disableControl = false;\n\n    // Show legends if in detailed mode\n    svg.selectAll(`.${selectedScaleLevel}-legend`)\n      .classed('hidden', !detailedMode);\n    svg.selectAll('.input-legend').classed('hidden', !detailedMode);\n    svg.selectAll('.output-legend').classed('hidden', !detailedMode);\n\n    // Also dehighlight the edge\n    let edgeGroup = svg.select('g.cnn-group').select('g.edge-group');\n    edgeGroup.selectAll(`path.edge-${layerIndex}-${nodeIndex}`)\n      .transition()\n      .ease(d3.easeCubicOut)\n      .duration(200)\n      .style('stroke', edgeInitColor)\n      .style('stroke-width', edgeStrokeWidth)\n      .style('opacity', edgeOpacity);\n\n    // Remove the overlay rect\n    svg.selectAll('g.intermediate-layer-overlay, g.intermediate-layer-annotation')\n      .transition('remove')\n      .duration(500)\n      .ease(d3.easeCubicInOut)\n      .style('opacity', 0)\n      .on('end', (d, i, g) => {\n        svg.selectAll('g.intermediate-layer-overlay, g.intermediate-layer-annotation').remove();\n        svg.selectAll('defs.overlay-gradient').remove();\n        svg.select('.input-annotation').classed('hidden', false);\n      });\n\n    // Turn the fade out nodes back\n    svg.select(`g#cnn-layer-group-${layerIndex}`)\n      .selectAll('g.node-group')\n      .each((sd, si, sg) => {\n        d3.select(sg[si])\n          .style('pointer-events', 'all');\n    });\n\n    svg.select(`g#cnn-layer-group-${layerIndex - 1}`)\n      .selectAll('g.node-group')\n      .each((sd, si, sg) => {\n        // Recover the old events\n        d3.select(sg[si])\n          .style('pointer-events', 'all')\n          .on('mouseover', nodeMouseOverHandler)\n          .on('mouseleave', nodeMouseLeaveHandler)\n          .on('click', nodeClickHandler);\n    });\n\n    // Deselect the node\n    selectedNode.layerName = '';\n    selectedNode.index = -1;\n    selectedNode.data = null;\n\n    actPoolDetailViewLayerIndex = -1;\n  }\n\n  const actPoolDetailViewPreNodeMouseOverHandler = (d, i, g) => {\n    // Highlight the edges\n    let layerIndex = layerIndexDict[d.layerName];\n    let nodeIndex = d.index;\n    let edgeGroup = svg.select('g.cnn-group').select('g.edge-group');\n    \n    edgeGroup.selectAll(`path.edge-${actPoolDetailViewLayerIndex}-${nodeIndex}`)\n      .raise()\n      .transition()\n      .ease(d3.easeCubicInOut)\n      .duration(400)\n      .style('stroke', edgeHoverColor)\n      .style('stroke-width', '1')\n      .style('opacity', 1);\n    \n    // Highlight its border\n    d3.select(g[i]).select('rect.bounding')\n      .classed('hidden', false);\n    \n    // Highlight node's pair\n    let associatedLayerIndex = layerIndex - 1;\n    if (layerIndex === actPoolDetailViewLayerIndex - 1) {\n      associatedLayerIndex = layerIndex + 1;\n    }\n\n    svg.select(`g#layer-${associatedLayerIndex}-node-${nodeIndex}`)\n      .select('rect.bounding')\n      .classed('hidden', false);\n  }\n\n  const actPoolDetailViewPreNodeMouseLeaveHandler = (d, i, g) => {\n    // De-highlight the edges\n    let layerIndex = layerIndexDict[d.layerName];\n    let nodeIndex = d.index;\n    let edgeGroup = svg.select('g.cnn-group').select('g.edge-group');\n\n    edgeGroup.selectAll(`path.edge-${actPoolDetailViewLayerIndex}-${nodeIndex}`)\n      .transition()\n      .ease(d3.easeCubicOut)\n      .duration(200)\n      .style('stroke', edgeInitColor)\n      .style('stroke-width', edgeStrokeWidth)\n      .style('opacity', edgeOpacity);\n    \n    // De-highlight its border\n    d3.select(g[i]).select('rect.bounding')\n      .classed('hidden', true);\n    \n    // De-highlight node's pair\n    let associatedLayerIndex = layerIndex - 1;\n    if (layerIndex === actPoolDetailViewLayerIndex - 1) {\n      associatedLayerIndex = layerIndex + 1;\n    }\n\n    svg.select(`g#layer-${associatedLayerIndex}-node-${nodeIndex}`)\n      .select('rect.bounding')\n      .classed('hidden', true);\n  }\n\n  const actPoolDetailViewPreNodeClickHandler = (d, i, g) => {\n    let layerIndex = layerIndexDict[d.layerName];\n    let nodeIndex = d.index;\n\n    // Click the pre-layer node in detail view has the same effect as clicking\n    // the cur-layer node, which is to open a new detail view window\n    svg.select(`g#layer-${layerIndex + 1}-node-${nodeIndex}`)\n      .node()\n      .dispatchEvent(new Event('click'));\n  }\n\n  const enterDetailView = (curLayerIndex, i) => {\n    isInActPoolDetailView = true;\n    actPoolDetailViewNodeIndex = i;\n    actPoolDetailViewLayerIndex = curLayerIndex;\n\n    // Dynamically position the detail view\n    let wholeSvg = d3.select('#cnn-svg');\n    let svgYMid = +wholeSvg.style('height').replace('px', '') / 2;\n    let svgWidth = +wholeSvg.style('width').replace('px', '');\n    let detailViewTop = 100 + svgYMid - 260 / 2;\n\n    let posX = 0;\n    if (curLayerIndex > 5) {\n      posX = nodeCoordinate[curLayerIndex - 1][0].x + 50;\n      posX = posX / 2 - 500 / 2;\n    } else {\n      posX = (svgWidth - nodeCoordinate[curLayerIndex][0].x - nodeLength) / 2;\n      posX = nodeCoordinate[curLayerIndex][0].x + nodeLength + posX - 500 / 2;\n\n    }\n\n    const detailview = document.getElementById('detailview');\n    detailview.style.top = `${detailViewTop}px`;\n    detailview.style.left = `${posX}px`;\n    detailview.style.position = 'absolute';\n\n    // Hide all edges\n    let unimportantEdges = svg.select('g.edge-group')\n      .selectAll('.edge')\n      .filter(d => {\n        return d.targetLayerIndex !== curLayerIndex;\n      })\n      .style('visibility', 'hidden');\n    \n    // Disable UI\n    disableControl = true;\n    \n    // Hide input annotaitons\n    svg.select('.input-annotation')\n      .classed('hidden', true);\n\n    // Hide legends\n    svg.selectAll(`.${selectedScaleLevel}-legend`)\n      .classed('hidden', true);\n    svg.selectAll('.input-legend').classed('hidden', true);\n    svg.selectAll('.output-legend').classed('hidden', true);\n    svg.select(`#${layerLegendDict[curLayerIndex][selectedScaleLevel]}`)\n      .classed('hidden', false);\n\n    // Add overlay rects\n    let leftX = nodeCoordinate[curLayerIndex - 1][i].x;\n    // +5 to cover the detailed mode long label\n    let rightStart = nodeCoordinate[curLayerIndex][i].x + nodeLength + 5;\n\n    // Compute the left and right overlay rect width\n    let rightWidth = width - rightStart - overlayRectOffset / 2;\n    let leftWidth = leftX - nodeCoordinate[0][0].x;\n\n    // The overlay rects should be symmetric\n    if (rightWidth > leftWidth) {\n      let stops = [{offset: '0%', color: 'rgb(250, 250, 250)', opacity: 0.85},\n        {offset: '50%', color: 'rgb(250, 250, 250)', opacity: 0.9},\n        {offset: '100%', color: 'rgb(250, 250, 250)', opacity: 1}];\n      addOverlayGradient('overlay-gradient-right', stops);\n      \n      let leftEndOpacity = 0.85 + (0.95 - 0.85) * (leftWidth / rightWidth);\n      stops = [{offset: '0%', color: 'rgb(250, 250, 250)', opacity: leftEndOpacity},\n        {offset: '100%', color: 'rgb(250, 250, 250)', opacity: 0.85}];\n      addOverlayGradient('overlay-gradient-left', stops);\n    } else {\n      let stops = [{offset: '0%', color: 'rgb(250, 250, 250)', opacity: 1},\n        {offset: '50%', color: 'rgb(250, 250, 250)', opacity: 0.9},\n        {offset: '100%', color: 'rgb(250, 250, 250)', opacity: 0.85}];\n      addOverlayGradient('overlay-gradient-left', stops);\n\n      let rightEndOpacity = 0.85 + (0.95 - 0.85) * (rightWidth / leftWidth);\n      stops = [{offset: '0%', color: 'rgb(250, 250, 250)', opacity: 0.85},\n        {offset: '100%', color: 'rgb(250, 250, 250)', opacity: rightEndOpacity}];\n      addOverlayGradient('overlay-gradient-right', stops);\n    }\n    \n    addOverlayRect('overlay-gradient-right',\n      rightStart + overlayRectOffset / 2 + 0.5,\n      0, rightWidth, height + svgPaddings.top);\n    \n    addOverlayRect('overlay-gradient-left',\n      nodeCoordinate[0][0].x - overlayRectOffset / 2,\n      0, leftWidth, height + svgPaddings.top);\n\n    svg.selectAll('rect.overlay')\n      .on('click', emptySpaceClicked);\n    \n    // Add underneath rectangles\n    let underGroup = svg.select('g.underneath');\n    let padding = 7;\n    for (let n = 0; n < cnn[curLayerIndex - 1].length; n++) {\n      underGroup.append('rect')\n        .attr('class', 'underneath-gateway')\n        .attr('id', `underneath-gateway-${n}`)\n        .attr('x', nodeCoordinate[curLayerIndex - 1][n].x - padding)\n        .attr('y', nodeCoordinate[curLayerIndex - 1][n].y - padding)\n        .attr('width', (2 * nodeLength + hSpaceAroundGap) + 2 * padding)\n        .attr('height', nodeLength + 2 * padding)\n        .attr('rx', 10)\n        .style('fill', 'rgba(160, 160, 160, 0.3)')\n        .style('opacity', 0);\n      \n      // Update the event functions for these two layers\n      svg.select(`g#layer-${curLayerIndex - 1}-node-${n}`)\n        .style('pointer-events', 'all')\n        .style('cursor', 'pointer')\n        .on('mouseover', actPoolDetailViewPreNodeMouseOverHandler)\n        .on('mouseleave', actPoolDetailViewPreNodeMouseLeaveHandler)\n        .on('click', actPoolDetailViewPreNodeClickHandler);\n    }\n    underGroup.lower();\n\n    // Highlight the selcted pair\n    underGroup.select(`#underneath-gateway-${i}`)\n      .style('opacity', 1);\n  }\n\n  const quitIntermediateView = (curLayerIndex, g, i) => {\n    // If it is the softmax detail view, quit that view first\n    if (isInSoftmax) {\n      svg.select('.logit-layer').remove();\n      svg.select('.logit-layer-lower').remove();\n      svg.selectAll('.plus-symbol-clone').remove();\n\n      // Instead of removing the paths, we hide them, so it is faster to load in\n      // the future\n      svg.select('.underneath')\n        .selectAll('.logit-lower')\n        .style('opacity', 0);\n\n      softmaxDetailViewStore.set({\n          show: false,\n          logits: []\n      })\n\n      allowsSoftmaxAnimationStore.set(false);\n    }\n    isInSoftmaxStore.set(false);\n    isInIntermediateView = false;\n\n    // Show the legend\n    svg.selectAll(`.${selectedScaleLevel}-legend`)\n      .classed('hidden', !detailedMode);\n    svg.selectAll('.input-legend').classed('hidden', !detailedMode);\n    svg.selectAll('.output-legend').classed('hidden', !detailedMode);\n\n    // Recover control panel UI\n    disableControl = false;\n\n    // Recover the input layer node's event\n    for (let n = 0; n < cnn[curLayerIndex - 1].length; n++) {\n      svg.select(`g#layer-${curLayerIndex - 1}-node-${n}`)\n        .on('mouseover', nodeMouseOverHandler)\n        .on('mouseleave', nodeMouseLeaveHandler)\n        .on('click', nodeClickHandler);\n    }\n\n    // Clean up the underneath rects\n    svg.select('g.underneath')\n      .selectAll('rect')\n      .remove();\n    detailedViewNum = undefined;\n\n    // Highlight the previous layer and this node\n    svg.select(`g#cnn-layer-group-${curLayerIndex - 1}`)\n      .selectAll('rect.bounding')\n      .style('stroke-width', 1);\n    \n    d3.select(g[i])\n      .select('rect.bounding')\n      .style('stroke-width', 1);\n\n    // Highlight the labels\n    svg.selectAll(`g#layer-label-${curLayerIndex - 1},\n      g#layer-detailed-label-${curLayerIndex - 1},\n      g#layer-label-${curLayerIndex},\n      g#layer-detailed-label-${curLayerIndex}`)\n      .style('font-weight', 'normal');\n\n    // Also unclick the node\n    // Record the current clicked node\n    selectedNode.layerName = '';\n    selectedNode.index = -1;\n    selectedNode.data = null;\n    isExitedFromCollapse = true;\n\n    // Remove the intermediate layer\n    let intermediateLayer = svg.select('g.intermediate-layer');\n\n    // Kill the infinite animation loop\n    shouldIntermediateAnimateStore.set(false);\n\n    intermediateLayer.transition('remove')\n      .duration(500)\n      .ease(d3.easeCubicInOut)\n      .style('opacity', 0)\n      .on('end', (d, i, g) => { d3.select(g[i]).remove()});\n    \n    // Remove the output node overlay mask\n    svg.selectAll('.overlay-group').remove();\n    \n    // Remove the overlay rect\n    svg.selectAll('g.intermediate-layer-overlay, g.intermediate-layer-annotation')\n      .transition('remove')\n      .duration(500)\n      .ease(d3.easeCubicInOut)\n      .style('opacity', 0)\n      .on('end', (d, i, g) => {\n        svg.selectAll('g.intermediate-layer-overlay, g.intermediate-layer-annotation').remove();\n        svg.selectAll('defs.overlay-gradient').remove();\n      });\n    \n    // Recover the layer if we have drdrawn it\n    if (needRedraw[0] !== undefined) {\n      let redrawRange = cnnLayerRanges[selectedScaleLevel][needRedraw[0]];\n      if (needRedraw[1] !== undefined) {\n        svg.select(`g#layer-${needRedraw[0]}-node-${needRedraw[1]}`)\n          .select('image.node-image')\n          .each((d, i, g) => drawOutput(d, i, g, redrawRange));\n      } else {\n        svg.select(`g#cnn-layer-group-${needRedraw[0]}`)\n          .selectAll('image.node-image')\n          .each((d, i, g) => drawOutput(d, i, g, redrawRange));\n      }\n    }\n    \n    // Move all layers to their original place\n    for (let i = 0; i < numLayers; i++) {\n      moveLayerX({layerIndex: i, targetX: nodeCoordinate[i][0].x,\n        disable:false, delay:500, opacity: 1});\n    }\n\n    moveLayerX({layerIndex: numLayers - 2,\n      targetX: nodeCoordinate[numLayers - 2][0].x, opacity: 1,\n      disable:false, delay:500, onEndFunc: () => {\n        // Show all edges on the last moving animation end\n        svg.select('g.edge-group')\n          .style('visibility', 'visible');\n\n        // Recover the input annotation\n        svg.select('.input-annotation')\n          .classed('hidden', false);\n      }});\n  }\n\n  const nodeClickHandler = (d, i, g) => {\n    d3.event.stopPropagation();\n    let nodeIndex = d.index;\n\n    // Record the current clicked node\n    selectedNode.layerName = d.layerName;\n    selectedNode.index = d.index;\n    selectedNode.data = d;\n    selectedNode.domI = i;\n    selectedNode.domG = g;\n\n    // Record data for detailed view.\n    if (d.type === 'conv' || d.type === 'relu' || d.type === 'pool') {\n      let data = [];\n      for (let j = 0; j < d.inputLinks.length; j++) {\n        data.push({\n          input: d.inputLinks[j].source.output,\n          kernel: d.inputLinks[j].weight,\n          output: d.inputLinks[j].dest.output,\n        })\n      }\n      let curLayerIndex = layerIndexDict[d.layerName];\n      data.colorRange = cnnLayerRanges[selectedScaleLevel][curLayerIndex];\n      data.isInputInputLayer = curLayerIndex <= 1;\n      nodeData = data;\n    }\n\n    let curLayerIndex = layerIndexDict[d.layerName];\n\n    if (d.type == 'relu' || d.type == 'pool') {\n      isExitedFromDetailedView = false;\n      if (!isInActPoolDetailView) {\n        // Enter the act pool detail view\n        enterDetailView(curLayerIndex, d.index);\n      } else {\n        if (d.index === actPoolDetailViewNodeIndex) {\n          // Quit the act pool detail view\n          quitActPoolDetailView();\n        } else {\n          // Switch the detail view input to the new clicked pair\n\n          // Remove the previous selection effect\n          svg.select(`g#layer-${curLayerIndex}-node-${actPoolDetailViewNodeIndex}`)\n            .select('rect.bounding')\n            .classed('hidden', true);\n\n          svg.select(`g#layer-${curLayerIndex - 1}-node-${actPoolDetailViewNodeIndex}`)\n            .select('rect.bounding')\n            .classed('hidden', true);\n          \n          let edgeGroup = svg.select('g.cnn-group').select('g.edge-group');\n      \n          edgeGroup.selectAll(`path.edge-${curLayerIndex}-${actPoolDetailViewNodeIndex}`)\n            .transition()\n            .ease(d3.easeCubicOut)\n            .duration(200)\n            .style('stroke', edgeInitColor)\n            .style('stroke-width', edgeStrokeWidth)\n            .style('opacity', edgeOpacity);\n          \n          let underGroup = svg.select('g.underneath');\n          underGroup.select(`#underneath-gateway-${actPoolDetailViewNodeIndex}`)\n            .style('opacity', 0);\n        \n          // Add selection effect on the new selected pair\n          svg.select(`g#layer-${curLayerIndex}-node-${nodeIndex}`)\n            .select('rect.bounding')\n            .classed('hidden', false);\n\n          svg.select(`g#layer-${curLayerIndex - 1}-node-${nodeIndex}`)\n            .select('rect.bounding')\n            .classed('hidden', false);\n\n          edgeGroup.selectAll(`path.edge-${curLayerIndex}-${nodeIndex}`)\n            .raise()\n            .transition()\n            .ease(d3.easeCubicInOut)\n            .duration(400)\n            .style('stroke', edgeHoverColor)\n            .style('stroke-width', '1')\n            .style('opacity', 1);\n\n          underGroup.select(`#underneath-gateway-${nodeIndex}`)\n            .style('opacity', 1);\n\n          actPoolDetailViewNodeIndex = nodeIndex;\n        }\n      }\n    }\n\n    // Enter the second view (layer-view) when user clicks a conv node\n    if ((d.type === 'conv' || d.layerName === 'output') && !isInIntermediateView) {\n      prepareToEnterIntermediateView(d, g, nodeIndex, curLayerIndex);\n\n      if (d.layerName === 'conv_1_1') {\n        drawConv1(curLayerIndex, d, nodeIndex, width, height,\n          intermediateNodeMouseOverHandler, intermediateNodeMouseLeaveHandler,\n          intermediateNodeClicked);\n      }\n\n      else if (d.layerName === 'conv_1_2') {\n        drawConv2(curLayerIndex, d, nodeIndex, width, height,\n          intermediateNodeMouseOverHandler, intermediateNodeMouseLeaveHandler,\n          intermediateNodeClicked);\n      }\n\n      else if (d.layerName === 'conv_2_1') {\n        drawConv3(curLayerIndex, d, nodeIndex, width, height,\n          intermediateNodeMouseOverHandler, intermediateNodeMouseLeaveHandler,\n          intermediateNodeClicked);\n      }\n      \n      else if (d.layerName === 'conv_2_2') {\n        drawConv4(curLayerIndex, d, nodeIndex, width, height,\n          intermediateNodeMouseOverHandler, intermediateNodeMouseLeaveHandler,\n          intermediateNodeClicked);\n      }\n    \n      else if (d.layerName === 'output') {\n        drawFlatten(curLayerIndex, d, nodeIndex, width, height);\n      }\n    }\n    // Quit the layerview\n    else if ((d.type === 'conv' || d.layerName === 'output') && isInIntermediateView) {\n      quitIntermediateView(curLayerIndex, g, i);\n    }\n  }\n\n  const nodeMouseOverHandler = (d, i, g) => {\n    // if (isInIntermediateView || isInActPoolDetailView) { return; }\n    if (isInIntermediateView) { return; }\n\n    // Highlight the edges\n    let layerIndex = layerIndexDict[d.layerName];\n    let nodeIndex = d.index;\n    let edgeGroup = svg.select('g.cnn-group').select('g.edge-group');\n    \n    edgeGroup.selectAll(`path.edge-${layerIndex}-${nodeIndex}`)\n      .raise()\n      .transition()\n      .ease(d3.easeCubicInOut)\n      .duration(400)\n      .style('stroke', edgeHoverColor)\n      .style('stroke-width', '1')\n      .style('opacity', 1);\n    \n    // Highlight its border\n    d3.select(g[i]).select('rect.bounding')\n      .classed('hidden', false);\n    \n    // Highlight source's border\n    if (d.inputLinks.length === 1) {\n      let link = d.inputLinks[0];\n      let layerIndex = layerIndexDict[link.source.layerName];\n      let nodeIndex = link.source.index;\n      svg.select(`g#layer-${layerIndex}-node-${nodeIndex}`)\n        .select('rect.bounding')\n        .classed('hidden', false);\n    } else {\n      svg.select(`g#cnn-layer-group-${layerIndex - 1}`)\n        .selectAll('g.node-group')\n        .selectAll('rect.bounding')\n        .classed('hidden', false);\n    }\n\n    // Highlight the output text\n    if (d.layerName === 'output') {\n      d3.select(g[i])\n        .select('.output-text')\n        .style('opacity', 0.8)\n        .style('text-decoration', 'underline');\n    }\n\n    /* Use the following commented code if we have non-linear model\n    d.inputLinks.forEach(link => {\n      let layerIndex = layerIndexDict[link.source.layerName];\n      let nodeIndex = link.source.index;\n      svg.select(`g#layer-${layerIndex}-node-${nodeIndex}`)\n        .select('rect.bounding')\n        .classed('hidden', false);\n    });\n    */\n  }\n\n  const nodeMouseLeaveHandler = (d, i, g) => {\n    // Screenshot\n    // return;\n\n    if (isInIntermediateView) { return; }\n    \n    // Keep the highlight if user has clicked\n    if (isInActPoolDetailView || (\n      d.layerName !== selectedNode.layerName ||\n      d.index !== selectedNode.index)){\n      let layerIndex = layerIndexDict[d.layerName];\n      let nodeIndex = d.index;\n      let edgeGroup = svg.select('g.cnn-group').select('g.edge-group');\n      \n      edgeGroup.selectAll(`path.edge-${layerIndex}-${nodeIndex}`)\n        .transition()\n        .ease(d3.easeCubicOut)\n        .duration(200)\n        .style('stroke', edgeInitColor)\n        .style('stroke-width', edgeStrokeWidth)\n        .style('opacity', edgeOpacity);\n\n      d3.select(g[i]).select('rect.bounding').classed('hidden', true);\n\n      if (d.inputLinks.length === 1) {\n        let link = d.inputLinks[0];\n        let layerIndex = layerIndexDict[link.source.layerName];\n        let nodeIndex = link.source.index;\n        svg.select(`g#layer-${layerIndex}-node-${nodeIndex}`)\n          .select('rect.bounding')\n          .classed('hidden', true);\n      } else {\n        svg.select(`g#cnn-layer-group-${layerIndex - 1}`)\n          .selectAll('g.node-group')\n          .selectAll('rect.bounding')\n          .classed('hidden', d => d.layerName !== selectedNode.layerName ||\n            d.index !== selectedNode.index);\n      }\n\n      // Dehighlight the output text\n      if (d.layerName === 'output') {\n        d3.select(g[i])\n          .select('.output-text')\n          .style('fill', 'black')\n          .style('opacity', 0.5)\n          .style('text-decoration', 'none');\n      }\n\n      /* Use the following commented code if we have non-linear model\n      d.inputLinks.forEach(link => {\n        let layerIndex = layerIndexDict[link.source.layerName];\n        let nodeIndex = link.source.index;\n        svg.select(`g#layer-${layerIndex}-node-${nodeIndex}`)\n          .select('rect.bounding')\n          .classed('hidden', true);\n      });\n      */\n    }\n  }\n  let logits = [-4.28, 2.96, -0.38, 5.24, -7.56, -3.43, 8.63, 2.63, 6.30, 0.68];\n  let selectedI = 4;\n\n  onMount(async () => {\n    // Create SVG\n    wholeSvg = d3.select(overviewComponent)\n      .select('#cnn-svg');\n    svg = wholeSvg.append('g')\n      .attr('class', 'main-svg')\n      .attr('transform', `translate(${svgPaddings.left}, 0)`);\n    svgStore.set(svg);\n\n    width = Number(wholeSvg.style('width').replace('px', '')) -\n      svgPaddings.left - svgPaddings.right;\n    height = Number(wholeSvg.style('height').replace('px', '')) -\n      svgPaddings.top - svgPaddings.bottom;\n\n    let cnnGroup = svg.append('g')\n      .attr('class', 'cnn-group');\n    \n    let underGroup = svg.append('g')\n      .attr('class', 'underneath');\n\n    let svgYMid = +wholeSvg.style('height').replace('px', '') / 2;\n    detailedViewAbsCoords = {\n      1 : [600, 100 + svgYMid - 220 / 2, 490, 290],\n      2: [500, 100 + svgYMid - 220 / 2, 490, 290],\n      3 : [700, 100 + svgYMid - 220 / 2, 490, 290],\n      4: [600, 100 + svgYMid - 220 / 2, 490, 290],\n      5: [650, 100 + svgYMid - 220 / 2, 490, 290],\n      6 : [850, 100 + svgYMid - 220 / 2, 490, 290],\n      7 : [100, 100 + svgYMid - 220 / 2, 490, 290],\n      8 : [60, 100 + svgYMid - 220 / 2, 490, 290],\n      9 : [200, 100 + svgYMid - 220 / 2, 490, 290],\n      10 : [300, 100 + svgYMid - 220 / 2, 490, 290],\n    }\n    \n    // Define global arrow marker end\n    svg.append(\"defs\")\n      .append(\"marker\")\n      .attr(\"id\", 'marker')\n      .attr(\"viewBox\", \"0 -5 10 10\")\n      .attr(\"refX\", 6)\n      .attr(\"refY\", 0)\n      .attr(\"markerWidth\", 6)\n      .attr(\"markerHeight\", 6)\n      .attr(\"orient\", \"auto\")\n      .append(\"path\")\n      .style('stroke-width', 1.2)\n      .style('fill', 'gray')\n      .style('stroke', 'gray')\n      .attr(\"d\", \"M0,-5L10,0L0,5\");\n\n    // Alternative arrow head style for non-interactive annotation\n    svg.append(\"defs\")\n      .append(\"marker\")\n      .attr(\"id\", 'marker-alt')\n      .attr(\"viewBox\", \"0 -5 10 10\")\n      .attr(\"refX\", 6)\n      .attr(\"refY\", 0)\n      .attr(\"markerWidth\", 6)\n      .attr(\"markerHeight\", 6)\n      .attr(\"orient\", \"auto\")\n      .append(\"path\")\n      .style('fill', 'none')\n      .style('stroke', 'gray')\n      .style('stroke-width', 2)\n      .attr(\"d\", \"M-5,-10L10,0L-5,10\");\n    \n    console.time('Construct cnn');\n    model = await loadTrainedModel('PUBLIC_URL/assets/data/model.json');\n    cnn = await constructCNN(`PUBLIC_URL/assets/img/${selectedImage}`, model);\n    console.timeEnd('Construct cnn');\n    cnnStore.set(cnn);\n\n    // Ignore the flatten layer for now\n    let flatten = cnn[cnn.length - 2];\n    cnn.splice(cnn.length - 2, 1);\n    cnn.flatten = flatten;\n    console.log(cnn);\n\n    updateCNNLayerRanges();\n\n    // Create and draw the CNN view\n    drawCNN(width, height, cnnGroup, nodeMouseOverHandler,\n      nodeMouseLeaveHandler, nodeClickHandler);\n  })\n\n  const detailedButtonClicked = () => {\n    detailedMode = !detailedMode;\n    detailedModeStore.set(detailedMode);\n\n    if (!isInIntermediateView){\n      // Show the legend\n      svg.selectAll(`.${selectedScaleLevel}-legend`)\n        .classed('hidden', !detailedMode);\n      \n      svg.selectAll('.input-legend').classed('hidden', !detailedMode);\n      svg.selectAll('.output-legend').classed('hidden', !detailedMode);\n    }\n    \n    // Switch the layer name\n    svg.selectAll('.layer-detailed-label')\n      .classed('hidden', !detailedMode);\n    \n    svg.selectAll('.layer-label')\n      .classed('hidden', detailedMode);\n  }\n\n  const imageOptionClicked = async (e) => {\n    let newImageName = d3.select(e.target).attr('data-imageName');\n\n    if (newImageName !== selectedImage) {\n      selectedImage = newImageName;\n\n      // Re-compute the CNN using the new input image\n      cnn = await constructCNN(`PUBLIC_URL/assets/img/${selectedImage}`, model);\n\n      // Ignore the flatten layer for now\n      let flatten = cnn[cnn.length - 2];\n      cnn.splice(cnn.length - 2, 1);\n      cnn.flatten = flatten;\n      cnnStore.set(cnn);\n\n      // Update all scales used in the CNN view\n      updateCNNLayerRanges();\n      updateCNN();\n    }\n  }\n\n  const customImageClicked = () => {\n\n    // Case 1: there is no custom image -> show the modal to get user input\n    if (customImageURL === null) {\n      modalInfo.show = true;\n      modalInfo.preImage = selectedImage;\n      modalStore.set(modalInfo);\n    }\n\n    // Case 2: there is an existing custom image, not the focus -> switch to this image\n    else if (selectedImage !== 'custom') {\n      let fakeEvent = {detail: {url: customImageURL}};\n      handleCustomImage(fakeEvent);\n    }\n\n    // Case 3: there is an existing custom image, and its the focus -> let user\n    // upload a new image\n    else {\n      modalInfo.show = true;\n      modalInfo.preImage = selectedImage;\n      modalStore.set(modalInfo);\n    }\n\n    if (selectedImage !== 'custom') {\n      selectedImage = 'custom';\n    }\n\n  }\n\n  const handleModalCanceled = (event) => {\n    // User cancels the modal without a successful image, so we restore the\n    // previous selected image as input\n    selectedImage = event.detail.preImage;\n  }\n\n  const handleCustomImage = async (event) => {\n    // User gives a valid image URL\n    customImageURL = event.detail.url;\n\n    // Re-compute the CNN using the new input image\n    cnn = await constructCNN(customImageURL, model);\n\n    // Ignore the flatten layer for now\n    let flatten = cnn[cnn.length - 2];\n    cnn.splice(cnn.length - 2, 1);\n    cnn.flatten = flatten;\n    cnnStore.set(cnn);\n\n    // Update the UI\n    let customImageSlot = d3.select(overviewComponent)\n      .select('.custom-image').node();\n    drawCustomImage(customImageSlot, cnn[0]);\n\n    // Update all scales used in the CNN view\n    updateCNNLayerRanges();\n    updateCNN();\n  }\n\n  function handleExitFromDetiledConvView(event) {\n    if (event.detail.text) {\n      detailedViewNum = undefined;\n      svg.select(`rect#underneath-gateway-${selectedNodeIndex}`)\n        .style('opacity', 0);\n      selectedNodeIndex = -1; \n    }\n  }\n\n  function handleExitFromDetiledPoolView(event) {\n    if (event.detail.text) {\n      quitActPoolDetailView();\n      isExitedFromDetailedView = true;\n    }\n  }\n\n  function handleExitFromDetiledActivationView(event) {\n    if (event.detail.text) {\n      quitActPoolDetailView();\n      isExitedFromDetailedView = true;\n    }\n  }\n\n  function handleExitFromDetiledSoftmaxView(event) {\n    softmaxDetailViewInfo.show = false;\n    softmaxDetailViewStore.set(softmaxDetailViewInfo);\n  }\n\n</script>\n\n<style>\n  .overview {\n    padding: 0;\n    height: 100%;\n    width: 100%;\n    display: flex;\n    position: relative;\n    flex-direction: column;\n    justify-content: space-between;\n    align-items: flex-start;\n  }\n\n  .control-container {\n    padding: 5px 20px;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    width: 100%;\n  }\n\n  .right-control {\n    display: flex;\n  }\n\n  .left-control {\n    display: flex;\n    align-items: center;\n  }\n\n  .control > .select > #level-select {\n    padding-left: 2em;\n    padding-right: 2em;\n  }\n\n  .cnn {\n    width: 100%;\n    padding: 0;\n    background: var(--light-gray);\n    display: flex;\n  }\n\n  svg {\n    margin: 0 auto;\n    min-height: 490px;\n    max-height: 700px;\n    height: calc(100vh - 100px);\n    width: 100vw;\n  }\n\n  .is-very-small {\n    font-size: 12px;\n  }\n\n  #detailed-button {\n    margin-right: 10px;\n    color: #dbdbdb;\n    transition: border-color 300ms ease-in-out, color 200ms ease-in-out;\n  }\n\n  #detailed-button.is-activated, #detailed-button.is-activated:hover {\n    color: #3273dc;\n    border-color: #3273dc;\n  }\n\n  #detailed-button:hover {\n    color: #b5b5b5;\n  }\n\n  #hover-label {\n    transition: opacity 300ms ease-in-out;\n    text-overflow: ellipsis;\n    pointer-events: none;\n    margin-left: 5px;\n  }\n\n  .image-container {\n    width: 40px;\n    height: 40px;\n    border-radius: 4px;\n    display: inline-block;\n    position: relative;\n    border: 2.5px solid #1E1E1E;\n    margin-right: 10px;\n    cursor: pointer;\n    pointer-events: all;\n    transition: border 300ms ease-in-out;\n  }\n\n  .image-container img {\n    object-fit: cover;\n    max-width: 100%;\n    max-height: 100%;\n    z-index: -1;\n    transition: opacity 300ms ease-in-out;\n  }\n\n  .image-container.inactive {\n    border: 2.5px solid rgb(220, 220, 220);\n  }\n\n  .image-container.inactive > img {\n    opacity: 0.3;\n  }\n\n  .image-container.inactive:hover > img {\n    opacity: 0.6;\n  }\n\n  .image-container.inactive.disabled {\n    border: 2.5px solid rgb(220, 220, 220);\n    cursor: not-allowed;\n  }\n\n  .image-container.inactive.disabled:hover {\n    border: 2.5px solid rgb(220, 220, 220);\n    cursor: not-allowed;\n  }\n\n  .image-container.inactive.disabled > img {\n    opacity: 0.3;\n    cursor: not-allowed;\n  }\n\n  .image-container.inactive.disabled:hover > img {\n    opacity: 0.3;\n    cursor: not-allowed;\n  }\n\n  .image-container.inactive > .edit-icon {\n    color: #BABABA;\n  }\n\n  .image-container.inactive:hover > .edit-icon {\n    color: #777777;\n  }\n\n  .image-container.inactive:hover {\n    border: 2.5px solid #1E1E1E;\n  }\n\n  .edit-icon {\n    position: absolute;\n    bottom: -6px;\n    right: -7px;\n    font-size: 7px;\n    color: #1E1E1E;\n    transition: color 300ms ease-in-out;\n  }\n\n  :global(canvas) {\n    image-rendering: crisp-edges;\n  }\n\n  :global(.layer-label), :global(.layer-detailed-label), :global(.layer-intermediate-label) {\n    font-size: 12px;\n    opacity: 0.8;\n    text-anchor: middle;\n  }\n\n  :global(.colorLegend) {\n    font-size: 10px;\n  }\n\n  :global(.legend) {\n    transition: opacity 400ms ease-in-out;\n  }\n\n  :global(.legend > rect) {\n    opacity: 1;\n  }\n\n  :global(.legend text), :global(.legend line), :global(.legend path) {\n    opacity: 0.7;\n  }\n\n  :global(.legend#output-legend > rect) {\n    opacity: 1;\n  }\n\n  :global(.hidden) {\n    opacity: 0;\n    pointer-events: none;\n  }\n\n  :global(.very-strong) {\n    stroke-width: 3px;\n  }\n\n  :global(.bounding), :global(.edge), :global(.edge-group),\n  :global(foreignObject), :global(.bounding-flatten),\n  :global(.underneath-gateway), :global(.input-annotation) {\n    transition: opacity 300ms ease-in-out;\n  }\n\n  :global(rect.bounding) {\n    transition: stroke-width 800ms ease-in-out, opacity 300ms ease-in-out;\n  }\n\n  :global(.annotation-text) {\n    pointer-events: none;\n    font-size: 10px;\n    font-style: italic;\n    fill: gray;\n  }\n\n  /* Change the cursor style on the detailed view input and output matrices */\n  :global(rect.square) {\n    cursor: crosshair;\n  }\n\n  :global(.animation-control-button) {\n    font-family: FontAwesome;\n    opacity: 0.8;\n    cursor: pointer;\n  }\n\n</style>\n\n<div class=\"overview\"\n  bind:this={overviewComponent}>\n\n  <div class=\"control-container\">\n\n    <div class=\"left-control\">\n      {#each imageOptions as image, i}\n        <div class=\"image-container\"\n          on:click={disableControl ? () => {} : imageOptionClicked}\n          class:inactive={selectedImage !== image.file}\n          class:disabled={disableControl}\n          data-imageName={image.file}>\n          <img src=\"PUBLIC_URL/assets/img/{image.file}\"\n            alt=\"image option\"\n            title=\"{image.class}\"\n            data-imageName={image.file}/>\n        </div>\n      {/each}\n\n      <!-- The plus button -->\n        <div class=\"image-container\"\n          class:inactive={selectedImage !== 'custom'}\n          class:disabled={disableControl}\n          data-imageName={'custom'}\n          on:click={disableControl ? () => {} : customImageClicked}>\n\n          <img class=\"custom-image\"\n            src=\"PUBLIC_URL/assets/img/plus.svg\"\n            alt=\"plus button\"\n            title=\"Add new input image\"\n            data-imageName=\"custom\"/>\n\n          <span class=\"fa-stack edit-icon\"\n            class:hidden={customImageURL === null}>\n            <i class=\"fas fa-circle fa-stack-2x\"></i>\n            <i class=\"fas fa-pen fa-stack-1x fa-inverse\"></i>\n          </span>\n\n        </div>\n\n      <button class=\"button is-very-small is-link is-light\"\n        id=\"hover-label\"\n        style=\"opacity:{hoverInfo.show ? 1 : 0}\">\n        <span class=\"icon\" style=\"margin-right: 5px;\">\n          <i class=\"fas fa-crosshairs \"></i>\n        </span>\n        <span id=\"hover-label-text\">\n          {hoverInfo.text}\n        </span>\n      </button>\n    </div>\n\n    <div class=\"right-control\">\n\n      <button class=\"button is-very-small\"\n        id=\"detailed-button\"\n        disabled={disableControl}\n        class:is-activated={detailedMode}\n        on:click={detailedButtonClicked}>\n        <span class=\"icon\">\n          <i class=\"fas fa-eye\"></i>\n        </span>\n        <span id=\"hover-label-text\">\n          Show detail\n        </span>\n      </button>\n\n      <div class=\"control is-very-small has-icons-left\"\n        title=\"Change color scale range\">\n        <span class=\"icon is-left\">\n          <i class=\"fas fa-palette\"></i>\n        </span>\n\n        <div class=\"select\">\n          <select bind:value={selectedScaleLevel} id=\"level-select\"\n            disabled={disableControl}>\n            <option value=\"local\">Unit</option>\n            <option value=\"module\">Module</option>\n            <option value=\"global\">Global</option>\n          </select>\n        </div>\n      </div>\n\n    </div>\n    \n  </div>\n\n  <div class=\"cnn\">\n    <svg id=\"cnn-svg\"></svg>\n  </div>\n</div>\n\n<div id='detailview'>\n  {#if selectedNode.data && selectedNode.data.type === 'conv' && selectedNodeIndex != -1}\n    <ConvolutionView on:message={handleExitFromDetiledConvView} input={nodeData[selectedNodeIndex].input} \n                      kernel={nodeData[selectedNodeIndex].kernel}\n                      dataRange={nodeData.colorRange}\n                      colorScale={nodeData.inputIsInputLayer ?\n                        layerColorScales.input[0] : layerColorScales.conv}\n                      isInputInputLayer={nodeData.inputIsInputLayer}\n                      isExited={isExitedFromCollapse}/>\n  {:else if selectedNode.data && selectedNode.data.type === 'relu'}\n    <ActivationView on:message={handleExitFromDetiledActivationView} input={nodeData[0].input} \n                    output={nodeData[0].output}\n                    dataRange={nodeData.colorRange}\n                    isExited={isExitedFromDetailedView}/>\n  {:else if selectedNode.data && selectedNode.data.type === 'pool'}\n    <PoolView on:message={handleExitFromDetiledPoolView} input={nodeData[0].input} \n              kernelLength={2}\n              dataRange={nodeData.colorRange}\n              isExited={isExitedFromDetailedView}/>\n  {:else if softmaxDetailViewInfo.show}\n    <SoftmaxView logits={softmaxDetailViewInfo.logits}\n                 logitColors={softmaxDetailViewInfo.logitColors}\n                 selectedI={softmaxDetailViewInfo.selectedI}\n                 highlightI={softmaxDetailViewInfo.highlightI}\n                 outputName={softmaxDetailViewInfo.outputName}\n                 outputValue={softmaxDetailViewInfo.outputValue}\n                 startAnimation={softmaxDetailViewInfo.startAnimation}\n                 on:xClicked={handleExitFromDetiledSoftmaxView}\n                 on:mouseOver={softmaxDetailViewMouseOverHandler}\n                 on:mouseLeave={softmaxDetailViewMouseLeaveHandler}/>\n  {/if}\n</div>\n\n<Modal on:xClicked={handleModalCanceled}\n  on:urlTyped={handleCustomImage}/>","<script>\n  import Overview from './overview/Overview.svelte';\n  import { cnnStore } from './stores.js';\n\n  // Enum to control the displaying view\n  const View = {\n    OVERVIEW: 'overview',\n    LAYERVIEW: 'layerview',\n    DETAILVIEW: 'detailview'\n  };\n\n  let mainView = View.OVERVIEW;\n\n  /* Example to read loaded cnn in other components:\n  $: if ( $cnnStore.length != 0) {\n    console.log($cnnStore);\n  }\n  */\n\n</script>\n\n<style>\n#explainer {\n  width: 100%;\n  padding: 0;\n  margin: auto;\n  /* outline: 1px solid var(--g-dark-gray); */\n}\n</style>\n\n<div id='explainer'>\n    <Overview />\n</div>","<script>\n</script>\n\n<style>\n\t#header {\n\t\theight: 50px;\n\t\tdisplay: flex;\n\t\tpadding: 0 20px;\n\t\talign-items: center;\n\t\tbackground: rgb(30, 30, 30);\n    justify-content: space-between;\n\t}\n\n\t#logo {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t}\n\n\t#logo-text {\n\t\tfont-size: 30px;\n\t\tcolor: var(--light-gray);\n\t\tfont-family: 'A Love of Thunder';\n\t\tmargin-right: 10px;\n\t}\n\n\t#svg-logo-tagline {\n\t\tfont-size: 23px;\n\t\tfill: rgb(255, 255, 255);\n\t\tdominant-baseline: baseline;\n\t\tfont-family: 'Neucha';\n\t}\n\n\t.icons {\n\t\tdisplay: flex;\n\t\tjustify-content: flex-start;\n\t\talign-items: center;\n\t}\n\n\t.icon {\n\t\twidth: 27px;\n\t\theight: 27px;\n\t\tmargin-left: 15px;\n\t}\n\n\t.icon a{\n\t\twidth: 100%;\n\t\theight: 100%;\n\t}\n\n\t.icon img {\n    width: 100%;\n    height: 100%;\n    object-fit: contain;\n\t}\n</style>\n\n<div id=\"header\">\n\n  <div id=\"logo\">\n    <div id=\"logo-text\">\n      CNN Explainer\n    </div>\n\t\t<svg width=\"510px\" height=\"50px\">\n\t\t\t<defs>\n\t\t\t\t<filter x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\" filterUnits=\"objectBoundingBox\" id=\"chalk-texture\">\n\t\t\t\t\t<feTurbulence type=\"fractalNoise\" baseFrequency=\"2\" numOctaves=\"5\" stitchTiles=\"stitch\" result=\"f1\">\n\t\t\t\t\t</feTurbulence>\n\t\t\t\t\t<feColorMatrix type=\"matrix\" values=\"0 0 0 0 0, 0 0 0 0 0, 0 0 0 0 0, 0 0 0 -1.5 1.5\" result=\"f2\">\n\t\t\t\t\t</feColorMatrix>\n\t\t\t\t\t<feComposite operator=\"in\" in2=\"f2\" in=\"SourceGraphic\" result=\"f3\">\n\t\t\t\t\t</feComposite>\n\t\t\t\t</filter>\n\t\t\t</defs>\n\t\t</svg>\n  </div>\n</div>","<script>\n\timport Explainer from './Explainer.svelte';\n\timport Header from './Header.svelte';\n</script>\n\n<style>\n</style>\n\n<div id=\"app-page\">\n\t<Header />\n\t<Explainer />\n</div>\n","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body,\n\tprops: {}\n});\n\nexport default app;"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","src_url_equal_anchor","current_component","src_url_equal","element_src","url","document","createElement","href","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","element","name","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","value","removeAttribute","getAttribute","setAttribute","set_data","wholeText","set_input_value","input","set_style","key","important","style","removeProperty","setProperty","select_option","select","i","length","option","__value","selected","selectedIndex","toggle_class","toggle","classList","set_current_component","component","get_current_component","Error","onMount","$$","on_mount","push","afterUpdate","after_update","createEventDispatcher","type","detail","cancelable","callbacks","bubbles","e","createEvent","initCustomEvent","custom_event","slice","call","defaultPrevented","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","seen_callbacks","Set","flushidx","flush","saved_component","update","pop","callback","has","add","clear","fragment","before_update","dirty","p","ctx","outroing","outros","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","o","d","create_component","mount_component","customElement","m","new_on_destroy","map","filter","on_destroy","destroy_component","detaching","make_dirty","then","fill","init","instance","create_fragment","not_equal","props","append_styles","parent_component","bound","on_disconnect","context","Map","skip_bound","root","ready","ret","rest","hydrate","nodes","Array","from","childNodes","children","l","intro","SvelteComponent","[object Object]","this","$destroy","index","indexOf","splice","$$props","obj","$$set","keys","subscriber_queue","writable","start","stop","subscribers","set","new_value","run_queue","subscriber","subscribe","invalidate","size","cnnStore","svgStore","undefined","vSpaceAroundGapStore","hSpaceAroundGapStore","nodeCoordinateStore","selectedScaleLevelStore","cnnLayerRangesStore","cnnLayerMinMaxStore","needRedrawStore","detailedModeStore","shouldIntermediateAnimateStore","isInSoftmaxStore","softmaxDetailViewStore","allowsSoftmaxAnimationStore","hoverInfoStore","modalStore","intermediateLayerPositionStore","init2DArray","height","width","array","row","matrixDot","mat1","mat2","console","assert","result","j","matrixSlice","mat","xs","xe","ys","ye","s","matrixMax","curMax","Infinity","singleConv","kernel","stride","padding","stepSize","curWindow","dot","singleMaxPooling","kernelWidth","array1d","f","v","array2d","w","generateOutputMappings","output","kernelLength","padded_input_size","dilation","outputMapping","h_out","w_out","h_kern","w_kern","h_im","w_im","compute_input_multiplies_with_weight","hoverH","hoverW","weight_dims","outputMappings","input_multiplies_with_weight","h_weight","w_weight","flat_input","getMatrixSliceFromInputHighlights","matrix","highlights","indices","reduce","total","Math","floor","getMatrixSliceFromOutputHighlights","getVisualizationSizeConstraint","imageLength","getDataRange","image","maxRow","max","apply","minRow","min","range","abs","gridData","constraint","xpos","ypos","column","round","col","x","y","grid_final","isKernelMath","dataRange","outputLength","colorScale","d3","interpolateRdBu","isInputLayer","dispatch","oldHighlight","oldData","redraw","selectAll","remove","constrainedSvgSize","enter","normalizedValue","on","toString","replace","gridFinal","legendFinal","kernelRange","kernelColorScale","interpolateBrBG","multiplicationSymbolPadding","columns","texts","normalizedValueWithGap","isPaused","isInputInputLayer","testInputMatrixSlice","interval","counter","testOutputMatrixSlice","inputHighlights","outputHighlights","startConvolution","clearInterval","setInterval","flat_animated","animatedH","animatedW","inputMatrixSlice","outputMatrixSlice","testImage","testOutput","testKernel","handleScroll","svgHeight","Number","scroll","SmoothScroll","offset","querySelector","animateScroll","isExited","outputFinal","log","gridInputMatrixSlice","gridOutputMatrixSlice","startRelu","gridImage","gridOutput","startMaxPool","createElementNS","softmaxViewComponent","logits","logitColors","selectedI","highlightI","outputName","outputValue","startAnimation","svg","formater","n","format","mouseOverHandler","g","curI","mouseLeaveHandler","formulaRightGroup","denominatorGroup","curX","curText","hasInitialized","curBBox","getBBox","denominatorGroupBBox","numeratorText","formulaLeftGroup","transition","duration","error","show","modalComponent","valiImg","files","inputValue","showLoading","usingURL","errorInfo","modalInfo","canvas","getContext","drawImage","getImageData","src","err","reader","FileReader","onload","readAsDataURL","preImage","crossOrigin","nodeType","Node","layerName","bias","inputLinks","outputLinks","Link","source","dest","weight","constructCNN","async","inputImageFile","model","inputImageTensor","getInputImageArray","preTensor","tf","stack","outputs","layers","curTensor","squeeze","shape","transpose","allOutputs","cnn","inputLayer","inputShape","batchInputShape","inputImageArray","arraySync","curLayerIndex","layer","curLayerType","curLayerNodes","includes","biases","val","weights","preNode","curLink","curLogit","logit","sort","realIndex","link","preNodeWidth","preNodeNum","preNodeIndex","preNodeRow","preNodeCol","curNodeRealIndex","constructCNNFromOutputs","imageDataTo3DTensor","imageData","normalize","imageArray","pixelIndex","channelIndex","curEntry","arr","croppedArray","cropDimensions","startXIdx","startYIdx","networkInputSize","cropCentralSquare","tensor3d","imgFile","cssText","getElementsByTagName","reject","canvasImage","inputImage","Image","resizeCanvas","resizeContext","resizeFactor","translate","scale","rotate","PI","imageWidth","imageHeight","onerror","overviewConfig","nodeLength","plusSymbolRadius","numLayers","edgeOpacity","edgeInitColor","edgeHoverColor","edgeHoverOuting","edgeStrokeWidth","intermediateColor","layerColorScales","interpolateGreys","conv","relu","pool","fc","interpolateOranges","svgPaddings","top","bottom","left","right","kernelRectLength","gapRatio","overlayRectOffset","classLists","getExtent","getOutputKnot","point","getInputKnot","gappedColorScale","gap","vSpaceAroundGap","hSpaceAroundGap","nodeCoordinate","selectedScaleLevel","cnnLayerRanges","cnnLayerMinMax","detailedMode","drawOutput","bufferCanvas","bufferContext","imageSingle","imageSingleArray","pixeIndex","color","rgb","largeCanvas","largeCanvasContext","putImageData","imageDataURL","toDataURL","drawOutputScore","delay","ease","easeCubicIn","getLegendGradient","gradientName","gradient","curProgress","curColor","drawCNN","cnnGroup","nodeMouseOverHandler","nodeMouseLeaveHandler","nodeClickHandler","leftAccuumulatedSpace","curLayer","isOutput","layerGroup","nodeGroups","classed","outputRectScale","scaleLinear","domain","each","layerNames","dimension","detailedLabels","labels","legends","legendHeight","range1","range2","localLegendScale1","localLegendScale2","localLegendAxis1","axisBottom","tickFormat","tickValues","localLegendAxis2","localLegend1","localLegend2","module","moduleLegendScale","moduleLegendAxis","moduleLegend","global","globalLegendScale","globalLegendAxis","globalLegend","outputLegendAxis","outputLegend","inputScale","inputLegendAxis","inputLegend","drawLegends","linkGen","linkHorizontal","linkData","curTarget","inputNodeIndex","flattenDimension","curSource","curWeight","targetLayerIndex","targetNodeIndex","sourceNodeIndex","getLinkData","inputAnnotation","redChannel","updateCNN","easeCubicOut","updateCNNLayerRanges","cnnLayerRangesLocal","curRange","aggregatedExtent","acc","cur","cnnLayerRangesComponent","numOfComponent","curArray","maxRange","cnnLayerRangesGlobal","moveLayerX","arg","layerIndex","targetX","disable","opacity","specialIndex","onEndFunc","transitionName","easeCubicInOut","addOverlayGradient","gradientID","stops","group","drawIntermediateLayerLegend","minMax","isInput","gradientAppendingName","gradientGap","normalizedColor","leftValue","zeroValue","rightValue","totalRange","zeroLocation","leftMidValue","rightMidValue","legendScale","legendAxis","intermediateLegend","legendGroup","drawArrow","sx","sy","tx","ty","dr","hFlip","marker","isEndOfAnimation","needRedraw","shouldIntermediateAnimate","intermediateLayerPosition","startOutputAnimation","kernelGroup","tickTime1D","slidingAnimation","originX","originY","oldTick","newTick","animationButtonClicked","startIntermediateAnimation","kernelGroupInput","kernelGroupResult","originXResult","xResult","stopPropagation","animateEdge","interrupt","dashoffset","easeLinear","drawIntermediateLayer","leftX","rightX","rightStart","intermediateGap","intermediateNodeMouseOverHandler","intermediateNodeMouseLeaveHandler","intermediateNodeClicked","intermediateLayer","intermediateX1","intermediateX2","intermediateMinMax","kernelExtent","outputY","curNode","outputOverlayGroup","strideTime","raise","ni","inputMatrix","kernelMatrix","interMatrix","dataMatrix","drawIntermidiateImage","groupLayer","nodeIndex","interaction","newNode","datum","overlayGroup","createIntermediateNode","kernelRectX","weightText","f2","sep","concat","clone","aggregatedMinMax","symbolY","symbolGroup","edgeGroup","lower","kernelMinMax","drawIntermediateLayerAnnotation","sliderX","sliderY","arrowSX","arrowSY","sliderX2","sliderY2","arrowSX2","arrowSY2","dr2","arrowTX2","arrowTY2","isFirstConv","kernelAnnotation","slideText","slideText2","plusAnnotation","textX","textY","plusText","biasTextY","addUnderneathRect","underGroup","addOverlayRect","redrawLayerIfNeeded","rangePre","rangeCur","drawConv1","rightGap","finalMinMax","intermediateLayerAnnotation","drawConv2","drawConv3","leftEnd","leftGap","drawConv4","isInSoftmax","allowsSoftmaxAnimation","softmaxDetailViewInfo","hoverInfo","layerIndexDict","flattenFactoredFDict","moveLegend","moveX","restore","legend","previousLegendX","previousLegendY","previousTransform","logitCircleMouseOverHandler","logitLayer","logitLayerLower","logitCircleMouseLeaveHandler","softmaxDetailViewMouseOverHandler","softmaxDetailViewMouseLeaveHandler","softmaxClicked","symbolX","outputX","softmaxLeftMid","pixelWidth","pixelHeight","topY","bottomY","middleGap","middleRectHeight","softmaxX","softmaxTextY","softmaxWidth","flattenRange","centerX","previousX","softmaxAnnotation","softmaxDetailAnnotation","scrollIntoView","behavior","arrowTX","arrowTY","hoverTextGroup","hoverText","flattenLeftPart","tempClone","tempPlusSymbol","logitColorScale","extent","flattenLength","flatten","underneathIs","curIIndex","drawOneEdgeGroup","curEdgeGroup","factoredF","class","vi","curNodeGroup","symbolClone","outputEdgeD1","outputEdgeD2","outputEdge1","outputEdge2","outputEdgeLength1","getTotalLength","outputEdgeLength2","totalLength","totalDuration","opacityDuration","anchorElement","pos","elem","targetel","getScreenCTM","ownerSVGElement","createSVGPoint","bbox","matrixTransform","getMidCoords","detailViewTop","detailview","getElementById","position","drawLogitLayer","drawFlatten","curLeftBound","intermediateLayerOverlay","flattenLayerLeftPart","preLayerDimension","preLayerGap","boundingBoxLength","flattenExtent","flattenMouseOverHandler","da","flattenMouseLeaveHandler","loc","meanValues","emptySpace","symbolEndX","softmaxArg","softmaxSymbol","detailedLabelGroup","detailedLabelText","flattenAnnotation","flattenText","middleText","file","colorRange","inputIsInputLayer","iterations","overviewComponent","scaleLevelSet","previousSelectedScaleLevel","wholeSvg","selectedNode","isInIntermediateView","isInActPoolDetailView","actPoolDetailViewNodeIndex","actPoolDetailViewLayerIndex","detailedViewNum","disableControl","conv_1_1","relu_1_1","conv_1_2","relu_1_2","max_pool_1","conv_2_1","relu_2_1","conv_2_2","relu_2_2","max_pool_2","layerLegendDict","0","1","2","3","4","5","6","7","8","9","10","11","nodeData","imageOptions","selectedImage","selectedNodeIndex","isExitedFromDetailedView","isExitedFromCollapse","customImageURL","svgYMid","svgWidth","positionX","posX","emptySpaceClicked","quitIntermediateView","domG","domI","quitActPoolDetailView","sd","si","sg","actPoolDetailViewPreNodeMouseOverHandler","associatedLayerIndex","actPoolDetailViewPreNodeMouseLeaveHandler","actPoolDetailViewPreNodeClickHandler","dispatchEvent","Event","redrawRange","rightWidth","leftWidth","enterDetailView","prepareToEnterIntermediateView","modelFile","time","loadLayersModel","timeEnd","handleCustomImage","red","green","blue","drawCustomImage","newImageName","selected_option","body"],"mappings":"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"}